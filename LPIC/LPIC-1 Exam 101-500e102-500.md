# LPIC-1 Exam 101
#### Version: 5.0
LPIC-1 é a primeira certificação no programa de certificação profissional Linux multinível da LPI. O LPIC-1 validará a capacidade do candidato de realizar tarefas de manutenção na linha de comando, instalar e configurar um computador executando Linux e configurar a rede básica.

#### Anotações para servir de resumo e consulta futuramente

---

## Tópico 101: Arquitetura de Sistema

101.1 Identificar e editar configurações de hardware
 101.1 Lição 1
101.2 Início (boot) do sistema
 101.2 Lição 1
101.3 Alternar runlevels/boot targets, desligar e reiniciar o sistema
 101.3 Lição 1

 ---

### 101.1 Identificar e editar configurações de hardware

---

#### BIOS

BIOS é o firmware da placa mãe, onde é feito o gerenciamento dos dispositivos conectados à placa mãe.

- `BIOS: Basic Input Output System`
- `POST: Power-On Self-Test`
- `Gerencia de dispositivos, IRQ, I/O, DMA, etc`
- `Inicia Processo de Boot`
- `EFI (Extensible Firmware Interface)`
- `UEFI (Unified Extensible Firmware Interface)`

---

#### IRQ

- `IRQ`: Interrupt Request (é um sinal enviado à CPU), podemos ver em `/proc/interrupts` (mostra uma coluna por CPU). O `IRQ` **NÃO** pode haver conflitos

Principais IRQs:
- IRQ0 - Sinal de clock da placa mãe
- **IRQ1 - Teclado**
- IRQ2 - Cascateador de IRQs
- **IRQ3 - Porta serial 2 (RS-232)**
- **IRQ4 - Porta serial 1 (RS-232)**
- IRQ5 - Livre
- IRQ6 - Drive de disquetes
- IRQ7 - Porta paralela (impressora)
- IRQ8 - Relógio do CMOS
- IRQ9 - Placa de vídeo
- IRQ10 - Livre
- IRQ11 - Controlador USB
- IRQ12 - Porta PS/2
- IRQ13 - Coprocessador aritmético
- **IRQ14 - IDE Primária**
- **IRQ15 - IDE Secundária**

>[!NOTE]
>
>O número do IRQ é uma prioridade, do `0` ao `2`, que é o cascateador, ele pula para o `8` até o `15`, depois continua do `3` ao `7`. Ficando, **1,2,8,9,10,11,12,13,14,15,3,4,5,6,7**

---

#### Endereços I/O (E/S)

Endereços de `I/O (E/S)`, lista de endereços de memória utilizadas para comunicação entre o CPU e os demais dispositivos de hardware. Fica em `/proc/ioports`

Exemplo

```
$sudo cat /proc/ioports
0000-0001f : dma
10020-0021: pic
10040-0043: timer
10050-0053: timer
10060-006f: keyboard
0070-0077: rtc
0080-008f: dma page reg
00a0-00a1: pic
200f0-00ff: fpu
```

---

#### DMA

`DMA`: *Direct Memory Addressing* (um canal que permite que os dispositivos transmitam os dados diretamente à memória, sem utilizar a CPU - há uma melhora de performance)

>[!NOTE]
>
>**Não** é utilizado por todos os dispositivos

Fica em `/proc/dma`

---

### Resumidamente...

Resumidamente, precisamos saber que:

- **IRQ**: `/proc/interrupts`
- **Endereços de I/O (E/S)**: `/proc/ioports` (executar como root o cat)
- **DMA**: `/proc/dma`

**Partições Virtuais**: montado dinamicamente conforme a execução do Sistema Operacional

- `/proc`: informações dos processos ativos e recursos de hardware
- `/sys`: informações sobre dispositivos de hardware (`sysfs`) - similar ao `/proc`
- `/dev`: referências aos dispositivos do sistema, inclusive de armazenamento (`udev`)
- `udev`: Device Manager
- `dbus` ou `hald`: Comunicação entre processos. Informa os processos a situação dos dispositivos de hardware.

---

#### PCI, USB, /dev /sys /proc, sysfs (barramentos)

**Barramentos**: interface de comunicação física entre os dispositivos e a placa mãe:

- `PCI`: *Peripheral Component Interconnect* (`lspci`)
- `USB`: *Universal Serial Bus* (`lsusb`)

---

#### comandos lspci e lsusb


- `lspci`: lista todos os dispositivos PCI
```
$ lspci
00:00.0 Host bridge: Intel Corporation Comet Lake-S 6c Host Bridge/DRAM Controller (rev 03)
00:02.0 VGA compatible controller: Intel Corporation CometLake-S GT2 [UHD Graphics 630] (rev 03)
00:08.0 System peripheral: Intel Corporation Xeon E3-1200 v5/v6 / E3-1500 v5 / 6th/7th/8th Gen Core Processor Gaussian Mixture Model
00:14.0 USB controller: Intel Corporation Comet Lake PCH-V USB Controller
```

- `lspci -s 00:02.0 -v` : lista os detalhes do dispositivo de id `00:02.0`
    - formado do `-s`: `[[[[<domain>]:]<bus>]:][<device>][.[<func>]]`
```
$ lspci -s 00:02.0 -v
00:02.0 VGA compatible controller: Intel Corporation CometLake-S GT2 [UHD Graphics 630] (rev 03) (prog-if 00 [VGA controller])
	DeviceName: Onboard - Video
	Subsystem: Dell CometLake-S GT2 [UHD Graphics 630]
	Flags: bus master, fast devsel, latency 0, IRQ 148, IOMMU group 0
	Memory at d0000000 (64-bit, non-prefetchable) [size=16M]
	Memory at c0000000 (64-bit, prefetchable) [size=256M]
	I/O ports at 4000 [size=64]
	Expansion ROM at 000c0000 [virtual] [disabled] [size=128K]
	Capabilities: <access denied>
	Kernel driver in use: i915
	Kernel modules: i915

```

Com verbose, nos mostra inclusive o `kernel in use`. No entanto se quiser mais detalhes, use a opção `-k`
```
$ lspci -s 01:00.0 -k
01:00.0 VGA compatible controller: NVIDIA Corporation GM107 [GeForce GTX 750 Ti] (rev a2)
    kernel driver in use: nvidia
    kernel modules: nouveau, nvidia_drm, nvidia
```

>[!TIP]
>
>Os comandos diretamente relacionados ao hardware geralmente requerem privilégios de root para serem executados, exibindo apenas informações limitadas quando executados por um usuário normal; portanto, pode ser necessário fazer login como root ou executar o comando com `sudo`.

---

- `lsusb`: lista todos os dispositivos USB. mostra o **Barramento** (Bus 001), o **Dispositivo** (001), o **ID** e o **nome**
```
$ lsusb
Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
Bus 001 Device 002: ID 046d:c52b Logitech, Inc. Unifying Receiver
Bus 001 Device 003: ID 413c:2113 Dell Computer Corp. KB216 Wired Keyboard
Bus 002 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub
```

- `lsusb -s 001:001 -v`: mostra detalhes do dispositivo `001:001`. (**cuidado** que **não** é o `id`, e sim a junção de `Barramento` e `Dispositivo`). O `-s` vem de `[[bus]:][devnum]`
```
$ lsusb -s 001:001 -v

Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
Couldn't open device, some information will be missing
Device Descriptor:
  bLength                18
  bDescriptorType         1
  bcdUSB               2.00
  bDeviceClass            9 Hub
  bDeviceSubClass         0 [unknown]
  bDeviceProtocol         1 Single TT
  bMaxPacketSize0        64
  idVendor           0x1d6b Linux Foundation
  idProduct          0x0002 2.0 root hub
  bcdDevice            6.08
  iManufacturer           3 Linux 6.8.0-51-generic xhci-hcd
  iProduct                2 xHCI Host Controller
  iSerial                 1 0000:00:14.0
  bNumConfigurations      1
#ocultado resultado, muito extenso
```

Nos barramentos USB, podemos ter um ou mais Barramentos com diversos dispositivos dentro dele (no caso, `BUS`). E cada `BUS` (barramento) tem seus `Devices`

Exemplo
```
Bus 001 Device 001
Bus 001 Device 002
Bus 002 Device 001
etc
```

Similar à opção `-s`, pode usar a opção `-d`, seguindo o seguinte padrão: `-d [vendor]:[product]`, que o caso é o `ID` do dispositivo.

>[!NOTE]
>
>Para usar o `id` do USB para busca, usamos o `-d` (`device`): `lsusb -v -d 046d:c52b`
```
$ lsusb -v -d 046d:c52b 

Bus 001 Device 002: ID 046d:c52b Logitech, Inc. Unifying Receiver
Couldn't open device, some information will be missing
Device Descriptor:
  bLength                18
  bDescriptorType         1
  bcdUSB               2.00
  bDeviceClass            0 [unknown]
  bDeviceSubClass         0 [unknown]
  bDeviceProtocol         0 
  bMaxPacketSize0         8
  idVendor           0x046d Logitech, Inc.
  idProduct          0xc52b Unifying Receiver
  bcdDevice           12.11
  iManufacturer           1 Logitech
  iProduct                2 USB Receiver
  iSerial                 0 
  bNumConfigurations      1
  Configuration Descriptor:
    bLength                 9
####ocultado pois saída muito longa
```
>[!TIP]
>
>Com a opção `-t` ou `--tree`, o comando `lsusb` mostra os mapeamentos do dispositivo USB atual na forma de **árvore hierárquica**
```
lsusb -t
/:  Bus 001.Port 001: Dev 001, Class=root_hub, Driver=xhci_hcd/12p, 480M
    |__ Port 007: Dev 002, If 0, Class=Human Interface Device, Driver=usbhid, 12M
    |__ Port 007: Dev 002, If 1, Class=Human Interface Device, Driver=usbhid, 12M
    |__ Port 007: Dev 002, If 2, Class=Human Interface Device, Driver=usbhid, 12M
    |__ Port 009: Dev 003, If 0, Class=Human Interface Device, Driver=usbhid, 1.5M
    |__ Port 009: Dev 003, If 1, Class=Human Interface Device, Driver=usbhid, 1.5M
/:  Bus 002.Port 001: Dev 001, Class=root_hub, Driver=xhci_hcd/8p, 5000M
```

---

#### As Partições Virtuais

Partição dinâmica (não há dados de arquivos e diretórios). É uma partição com informações do sistema, no momento de sua execução (informações de processos, dispositivos conectados, etc).

Partições Virtuais são montadas dinamicamente conforme a execução do SO

- `/proc`: informações dos processos ativos e de recursos de hardware (informações, dados, estatística dos processos que estão em execução no computador)
- `/sys`: informações sobre dispositivos de hardware (`sysfs`)
- `/dev`: referências ao dispositivos do sistema, inclusive de armazenamento (`udev`). Exemplo `/dev/hda`, referencia um HD
    - `udev`: Device Manager (no caso, seria esse processo `/usr/lib/systemd/systemd-udevd`, visto com o comando `ps axu | grep udev`)
    - `dbus` ou `hald` (`hald` está em processo de depreciação): Comunicação entre processos. Informa os processos a situação dos dispositivos de hardware. (do processo `/usr/bin/dbus-daemon`)

- `ColdPlug`: Ex. memória ram (tem que desligar o PC)
- `HotPlug`:  Ex. HD externo via USB

Os arquivos dentro do diretório `/sys` têm funções semelhantes às do `/proc`. No entanto, o diretório `/sys` tem o objetivo específico de armazenar informações do dispositivo e dados do kernel relacionados ao hardware.

Ao passo que `/proc` também contém informações sobre diversas estruturas de dados do kernel, incluindo processos em execução e configurações.

Use o comando `df -a` ou `--all`: trecho do `man df`: include pseudo, duplicate, **inaccessible** file systems

```
$ df -a
df: /run/user/1000/doc: Operation not permitted
Filesystem             1K-blocks     Used Available Use% Mounted on
sysfs                          0        0         0    - /sys
proc                           0        0         0    - /proc
udev                     8018144        0   8018144   0% /dev
```

---

### Complementando o /proc

Em `/proc`, o kernel faz acesso direto às informações listadas. Lembrando que `/proc` é um sistema de arquivos virtual carregada em memória, que não está fisicamente no disco. Se fizermos uma alteração em algum arquivo dentro de `/proc`, essa alteração vai ser repassada diretamente ao kernel.

em `/proc/cmdline`, é onde, no grub, que é repassado os comandos de parâmetros do `bootloader` para o kernel
```
BOOT_IMAGE=/vmlinuz-6.8.0-51-generic root=UUID=ed75f0cb-cf1f-4598-a66a-8f3b39ba3588 ro quiet splash
```

Em `/proc/filesystems`, são os *filesystems* que podem ser usados nas partições que temos disponíveis
```
nodev	sysfs
nodev	tmpfs
nodev	bdev
nodev	proc
nodev	cgroup
nodev	cgroup2
nodev	cpuset
nodev	devtmpfs
nodev	configfs
nodev	debugfs
nodev	tracefs
nodev	securityfs
nodev	sockfs
#ocultado, saída muito extensa
```

Em `/proc/mounts`, são os partições que estão montadas. Que na verdade é um link para `/proc/self/mounts`
```
$ ls -l /proc/mounts 
lrwxrwxrwx 1 root root 11 Jan 10 08:05 /proc/mounts -> self/mounts
```


```
$ cat /proc/mounts 
sysfs /sys sysfs rw,nosuid,nodev,noexec,relatime 0 0
proc /proc proc rw,nosuid,nodev,noexec,relatime 0 0
udev /dev devtmpfs rw,nosuid,relatime,size=8018144k,nr_inodes=2004536,mode=755,inode64 0 0
devpts /dev/pts devpts rw,nosuid,noexec,relatime,gid=5,mode=620,ptmxmode=000 0 0
tmpfs /run tmpfs rw,nosuid,nodev,noexec,relatime,size=1611476k,mode=755,inode64 0 0
efivarfs /sys/firmware/efi/efivars efivarfs rw,nosuid,nodev,noexec,relatime 0 0
/dev/nvme0n1p4 / ext4 rw,relatime,errors=remount-ro 0 0
securityfs /sys/kernel/security securityfs rw,nosuid,nodev,noexec,relatime 0 0
#ocultado, saída muito extensa
```

---

#### Resumo dos demais

- `/proc/interrupts`: Uma lista de números de interrupções por dispositivo de entrada e saída em cada CPU.
- `/proc/ioports`: Lista as regiões de portas de Entrada/Saída registradas atualmente e em uso.
- `/proc/dma`: Lista os canais registrados de DMA (acesso direto à memória) em uso.

---

#### udev

O `udev` é o processo `systemd-udev` (`ps axu | grep udev`) (que é o `udev` acoplado ao `systemd`). Quando liga o computador, é ele que identifica os dispositivos que estão conectados e constroe as ligações a eles, criando um mapeamento dos dispositivos. Além disso o `udev` fica monitorando todo periférico que é adicionado ou retirado do computador (como pen drives ou mouse, por exemplo)

Uma curiosidade é o comando `udevadm monitor` (comum cair na LPIC-2 apenas), que fica monitorando o que  acontece no sistema, de acordo com as regras que estão em `/lib/udev/rules.d/` (repare que há diversos arquivos com um número na frente, que nada mais é que a sequencia que o `udev` deve seguir na execução). Caso seja necessário criar as próprias regras, deve usar `/etc/udev/rules.d/`


Nas distribuições Linux atuais, o `udev` é responsável pela identificação e configuração dos dispositivos já presentes durante a inicialização da máquina (detecção `coldplug`) e dos dispositivos identificados enquanto o sistema está em execução (detecção hotplug). O `udev` utiliza o `SysFS`, o pseudosistema de arquivos montado em `/sys` para informações relacionadas ao hardware

Se executarmos `df -T /dev`, é retornado o *filesystem* do `udev`, que gerencia o diretório `/dev`
```
$ df -T /dev/
Filesystem     Type     1K-blocks  Used Available Use% Mounted on
udev           devtmpfs   8018144     0   8018144   0% /dev
```

Em `/dev`, se dermos um `ls -l`, é mostrado o que o `udev` gerencia, que no caso não são arquivos em si (arquivos em disco).

Se executarmos `df -T --type=tmpfs`, significa que é um tipo de *filesystem* (o `tmpfs`) que grava os arquivos em **memória**, e não em disco (algo temporário, dinâmico).
```
$ df -T --type=tmpfs
Filesystem     Type  1K-blocks   Used Available Use% Mounted on
tmpfs          tmpfs   1611476   2536   1608940   1% /run
tmpfs          tmpfs   8057364 242400   7814964   4% /dev/shm
tmpfs          tmpfs      5120      8      5112   1% /run/lock
tmpfs          tmpfs   8057364      0   8057364   0% /run/qemu
tmpfs          tmpfs   1611472   2660   1608812   1% /run/user/1000
```
Vale muito a pena dar uma lida no `man udev`.

---

#### IDE, PATA, SATA, SCSI


- `(P)ATA`: *Parallel Advanced Technology Attachment*: interface de conexão IDE (que tem **master** e **slave**)
    - O cabo Paralelo tem a opção de conectar um lado na placa mãe, e 2 HDs, seguindo a ordem:

- `/dev/hda` ou `sda` - **master**
- `/dev/hdb` ou `sdb` - **slave**
- `/dev/hdc` ou `sdc` - **master**
- `/dev/hdd` ou `sdd` - **slave**

- `CD/DVD` em IDE, também é referenciado como `hdX`

---

- `SATA`: *Serial Advanced Technology Attachment*
- 1 disco por cabo
- mais rápido que o PATA

Mapeados da seguinte forma:

- `/dev/sda`: primeiro disco
- `/dev/sdb`: segundo disco
- `/dev/sdc`: terceiro disco

---

- `SCSI`: *Small Computer System Interface*
- `Tipos`:
    - `8 bits`: permite 7 dispositivos + 1 controlador
    - `16 bits`: permite 15 dispositivos + 1 controlador

- `SCSI_ID`:
    - `Canal`: identificador de cada adaptador (conjunto de dispositivos, `8` ou `16 bits`)
    - `ID`: Identificador de cada dispositivo
    - `LUN`:Número Lógico da Unidade

- `Mapeados no Linux como`:
    - `/dev/sda`: primeiro disco
    - `/dev/sdb`: segundo disco
    - `/dev/sdc`: terceiro disco

- Informações do disco SCSI podem ser vistas em: `/prov/scsi/scsi`
```
$ cat /proc/scsi/scsi 
Attached devices:
Host: scsi3 Channel: 00 Id: 00 Lun: 00
  Vendor: HL-DT-ST Model: DVD+-RW GU90N    Rev: A1C6
  Type:   CD-ROM            
```

---

#### Outros Dispositivos:

- `/dev/fd0`: disquete / floppy disk
- `/dev/scd0`: SCSI Cd-ROM
- `/dev/sr0`: SCSI DVD
- `/dev/cdrom`: normalmente criado como link para o device do cdrom
- `/dev/dvd`: normalmente criado como link para o device do dvd

Portanto, normalmente o `ls -l /dev/cdrom` aponta para `sr0`, assim como `ls -l /dev/dvd`

```
$ ls /dev/cdrom -l
lrwxrwxrwx 1 root root 3 Jan 10 08:05 /dev/cdrom -> sr0
```

É possível ver os discos que foram adicionados (*attached*) durante o boot do computador com o comando `dmesg | grep "sda\|nvme"`

>[!NOTE]
>
>`md` é o arranjo `RAID`, `md` é de **M**ultiple **D**evice. Lembrando que `RAID` é assunto da LPIC-2 apenas

A exceção a esse padrão ocorre com cartões de memória (cartões SD) e dispositivos `NVMe` (SSD conectados ao barramento PCI Express). Para os cartões SD, os caminhos `/dev/mmcblk0p1`, `/dev/mmcblk0p2` etc. são usados para a primeira e a segunda partições do dispositivo identificado primeiro e `/dev/mmcblk1p1`, `/dev/mmcblk1p2`, etc. identificam a primeira e a segunda partição do dispositivo identificado em segundo lugar. Os dispositivos `NVMe` recebem o prefixo `nvme`, como em `/dev/nvme0n1p1` e `/dev/nvme0n1p2`.

---

####  lsmod, modinfo, modprobe, insmod

Todo hardware para que funcione, precisa de um software para que funcione. Esse software pode estar contido no kernel do linux, dependendo dos casos. É o equivalente aos `drivers` no Windows. No linux são chamados de `módulos`.

Local dos Módulos: `/lib/modules/versao_kernel/kernel` (digita `uname -r` para ver a versão utilizada no momento, ou simplesmente digite <code>ls /lib/modules/\`uname -r\`/kernel</code>)

Para escolher um em específico, navega até a pasta mostrado no comando anterior, escolhe por exemplo, `sound/pci` e manda listar 

Os módulos são os arquivos `.ko` (geralmente não carrega tudo, vai carregando conforme necessidade)

Em `/etc/modules` (um arquivo, dê um `cat` nele para ver o conteúdo), podemos definir quais módulos desejamos carregar, sem a necessidade do linux carregar sozinho.

---

#### lsmod

- `lsmod`: lista os módulos carregados pelo sistema (**nome**, **tamanho em memória**, e **usado por**, que é igual a **dependência**), em inglês:
- `Module`: nome do módulo
- `Size`: quantidade de RAM utilizado pelo módulo, em bytes
- `Used by`: módulos dependentes
```
Module                  Size  Used by
intel_powerclamp       16384    0
snd_pcm               192512  13 snd_ac97_codec,snd_inter8x0
```

No caso acima, `snd_pcm`, é utilizado por mais dois outros módulos: `snd_ac97_codec` e `snd_inter8x0`. 

Quando o módulo está com `Used`=`0`, quer dizer ele está carregado, mas não está em uso no momento

No caso de `1`, o módulo está em uso, por ele mesmo ou por outro processo


>[!NOTE]
>
>o `lsmod` lê/consulta o arquivo `/proc/modules`

- `modinfo nome_do_modulo`: lista informações do módulo, como **filename** (com caminho do módulo), **versão**, **licença**, **descrição**, **autor**, etc

Exemplo: `$ modinfo fjes`
```
filename:       /lib/modules/5.15.0-119-generic/kernel/drivers/net/fjes/fjes.ko
version:        1.2
license:        GPL
description:    FUJITSU Extended Socket Network Device Driver
author:         Taku Izumi <izumi.taku@jp.fujitsu.com>
srcversion:     E3B83668942FFC6AE950574
alias:          acpi*:PNP0C02:*
etc...
```

---

#### Remover módulo:

- `rmmod`: remove um módulo que esteja carregado

Exemplo de uso:

- `lsmod | grep mouse`: retorna o nome do módulo, que no caso é `psmouse`
- `modinfo psmouse`: retorna o endereço do filename: `/lib/modules/kernel_version/drivers/input/mouse/psmouse.ko`
- `rmmod pmouse`: remove o módulo `psmouse.ko`
- `lsmod | grep mouse`: não lista mais nada, e é para o mouse parar de funcionar

>[!NOTE]
>
>O `modprobe` pode ser usado para remover módulos: `modprobe -r bluecard_cs` ou `--remove` (descarrega as dependências também)

---

#### Inserir o módulo:

- `insmod /lib/modules/kernel_version/drivers/input/mouse/psmouse.ko`: carrega o módulo que foi descarregado anteriormente (precisa do caminho completo e **NÃO** carrega as dependências)
- `modprobe modulo`: (insere/carrega/adiciona módulo e mapeia/adiciona outros módulos que sejam necessários)

Exemplo: `modprobe bluecard_cs` (módulo para bluetooth, **JUNTAMENTE** com os módulos necessários, como o `bluetooth` e o `pcmcia`)
```
# lsmod|grep blue
bluecard_cs            16384  0
bluetooth            1028096  1 bluecard_cs
pcmcia                 86016  1 bluecard_cs
```

- `lsmod | grep blue` (vai listar o módulo que acabou de ser carregado pelo `modprobe` e suas dependências)

>[!NOTE]
>
>O `modprobe` pode ser usado para remover módulos: `modprobe -r bluecard_cs` (**descarrega as dependências também**)

>[!NOTE]
>
>Alterações permanentes no módulo devem ser feitas em: `/etc/modprobe.conf` ou em arquivos individuais com a extensão `.conf` no diretório `/etc/modprobe.d/`

>[!NOTE]
>
>A opção `-p` fará com que o comando `modinfo` exiba todos os parâmetros disponíveis e ignore as outras informações.
```
```

---

#### Um pouco mais sobre modprobe

Como já vimos, quando for necessário alterar algum módulo, faremos no diretório `/etc/modprobe.d/` incluindo a modificação `/etc/modprobe.conf` ou criando um próprio `.conf` para o módulo correspondente (o que é mais recomendável para administradores, criar seu próprio arquivo `.conf`).

Dentro de `/etc/modprobe.d` há diversos arquivos de configuração, passam informações aos módulos. Há também arquivos de **blacklist**, para que não carreguem o módulo especificado (pois pode haver mais de um módulo para um dispositivo, em casos de conflitos ou para isolar um módulo para testes)
```
cat blacklist_linux_6.8.0-51-generic.conf 
# Kernel supplied blacklist for linux 6.8.0-51-generic amd64
# modprobe.d/common.conf
# LP:1434842 -- disable OSS drivers by default to allow pulseaudio to emulate
blacklist snd-mixer-oss
blacklist snd-pcm-oss
# Autogenerated watchdog blacklist
blacklist acquirewdt
blacklist advantech_ec_wdt
blacklist advantechwdt
```

Com o comando `modinfo -p nouveau`, por exemplo, listamos as informações do módulo `nouveau`, um módulo do kernel fornecido pelo [nouveau project](https://en.wikipedia.org/wiki/Nouveau_(software)) como alternativa aos drivers proprietários das placas de GPU da NVIDIA.

Caso queiramos alterar a opção `modeset`, por exemplo, que permite controlar se a resolução e a profundidade da tela serão definidas no espaço do kernel em vez do espaço do usuário. Quando adicionamos `options nouveau modeset =0` ao arquivo `/etc/modprobe.d/nouveau.conf`, o recurso `modeset` do kernel é desativado.

Para impedir o carregamento automático do módulo `nouveau`, a linha `blacklist nouveau` deve ser adicionada ao arquivo `/etc/modprobe.d/blacklist.conf`. Essa ação é necessária quando o módulo proprietário nvidia é instalado e o módulo padrão `nouveau` deve ser posto de lado

Em `/lib/modprobe.d` temos arquivos de configurações que mandam opções para os módulos

Reforçando, tem também alguns arquivos de **blacklists**, como `fbdev-blacklist.conf`, que lista alguns módulos que são ignorados. Geralmente são módulos que estão dando problemas, ou quando temos mais de um módulo para um `device`, ou em casos que estão dando conflitos, ou ainda se quiser bloquear o módulo para testes. Lembrando que esse diretório é para o sistema.

Caso queira criar suas próprias regras, é recomendável alterar em `/etc/modprobe.d`

>[!NOTE]
>
>É possível modificar o arquivo `/etc/modprobe.d/blacklist.conf` que já existe no sistema por padrão. Porém, a melhor opção é criar um arquivo de configuração separado, `/etc/modprobe.d/<module_name>.conf`, contendo ajustes específicos àquele módulo do kernel em particular.

 Recomendado leitura de `man modprobe.d`

 ---

#### Exercício interessante da lpi.org

1. Os sistemas operacionais criados em torno do kernel do Linux também estão disponíveis para uma ampla variedade de arquiteturas de computadores além do x86, como os computadores de placa única baseados na arquitetura ARM. Um usuário atento notará a ausência do comando `lspci` nessas máquinas, como o Raspberry Pi. Que diferença em relação às máquinas x86 justifica essa ausência?

**Resposta**: Ao contrário da maioria das máquinas x86, um computador baseado em ARM, como o Raspberry Pi, não possui um barramento PCI; portanto, o comando `lspci` é inútil.

2. Em 2018, a vulnerabilidade de hardware conhecida como **Meltdown** foi descoberta. Ela afeta quase todos os processadores de diferentes arquiteturas. As versões mais recentes do kernel Linux podem informar se o sistema atual está vulnerável. Como obter essas informações?

**Resposta**: O arquivo `/proc/cpuinfo` tem uma linha que mostra os bugs conhecidos para a CPU correspondente, como por exemplo `bugs: cpu_meltdown`.

Exemplo: `Intel(R) Core(TM) i5-4300M CPU @ 2.60GHz`
```
$ grep meltdown /proc/cpuinfo
bugs : cpu_meltdown spectre_v1 spectre_v2 spec_store_bypass l1tf mds swapgs itlb_multihit srbds mmio_unknown
```

---

### 101.2 Inicialização do sistema

Envolve desde o momento que o computador é ligado, até o ponto que chega ao prompt de comandos.

A sequência (fluxo de boot) é: **BIOS** -> **MBR** -> **Bootloader (GRUB/LILO)** -> **Kernel** -> **Init**

Tendo as seguintes atribuições:
- `BIOS`: localiza e executa a MBR
- `MBR`: executa o bootloader
- `bootloader` (`GRUB` é o mais comum): seleciona e executa o `kernel` e o `initrd`
- `Kernel`: executa o `/sbin/ini`
- `Init`: inicia os programas/serviços do `runlevel`/`target` definido

>[!NOTE]
>
>O processo `POST` (*power-on self-test*) é executado para identificar falhas simples de hardware assim que a máquina é ligada.

---

#### MBR

- `Master Boot Recorder` (MBR): localizado no primeiro setor do disco bootável, no caso, nos primeiros `512 bytes`.
    - `/dev/hda` ou `/dev/sda`
- Contém informações sobre o `GRUB`/`LILO`
- `MBR` carrega e executa o `GRUB`/`LILO`

| 512 bytes  |
|---|
| Bootloader 446 bytes  |
| Partition Table 64 bytes  |
| Validation Check 2 bytes  |

---

#### Bootloader (também chamado de bootstrap)

- `Bootloader` é o gerenciador de boot
- tem a função de carregar o sistema operacional na memória (lista de sistemas operacionais para escolha)
- sendo os mais comuns:
    - `GRUB` (versões Legacy e 2): Grand Unified Bootloader
    - `LILO` (era padrão antigamente)
- `initrd`/`initramfs`: também é carregado pelo bootloader para dar suporte ao kernel. `Filesystem root` (`/`) temporário é carregado em memória RAM

No menu do GRUB, é possível escolher qual dos kernels instalados deve ser carregado e passar novos parâmetros para ele. A maioria dos parâmetros do kernel segue o padrão `opção=valor`. Alguns dos parâmetros mais úteis do kernel são:
- `acpi`: Ativa/desativa o suporte a ACPI. `acpi=off` desabilita o suporte a ACPI.
- `init`: Define um iniciador de sistema alternativo. Por exemplo, `init=/bin/bash` define o shell Bash como iniciador. Assim, uma sessão do shell será iniciada logo após o processo de inicialização do kernel.
- `systemd.unit`: Define o destino do systemd a ser ativado. Por exemplo, `systemd.unit=graphical.target`. O systemd também aceita os níveis de execução numéricos definidos para `SysV`. Para ativar o nível de execução `, por exemplo, é necessário apenas incluir o número `1` ou a letra `S` (abreviação de “single”) como parâmetro do kernel.
- `mem`: Define a quantidade de RAM disponivel para o sistema. Este parâmetro é útil para limitar a RAM disponível para cada convidado em uma máquina virtual. Assim, `mem=512M` limita a 512 megabytes a quantidade de RAM disponível para um sistema convidado em particular.
- `maxcpus`: Limita o número de processadores (ou núcleos de processador) visíveis ao sistema em máquinas multiprocessador simétricas. Também é útil para máquinas virtuais. Um valor de `0` desativa o suporte a máquinas multiprocessador e tem o mesmo efeito do parâmetro do kernel `nosmp`. O parâmetro `maxcpus=2` limita a dois o número de processadores disponíveis para o sistema operacional.
- `quiet`: Oculta a maioria das mensagens de inicialização.
- `vga`: Seleciona um modo de vídeo. O parâmetro `vga=ask` mostra uma lista dos modos disponíveis a escolher.
- `root`: Define a partição raiz, diferente da que está configurada no bootloader. Por exemplo, `root=/dev/sda3`.
- `rootflags`: Opções de montagem para o arquivo de sistemas raiz.
- `ro`: Torna somente para leitura a montagem inicial do arquivo de sistemas raiz.
- `rw`: Permite escrever no arquivo de sistemas raiz durante a montagem inicial.

Geralmente não é necessário alterar os parâmetros do kernel, mas isso pode ser útil para detectar e resolver problemas relacionados ao sistema operacional. Os parâmetros do kernel devem ser adicionados ao arquivo `/etc/default/grub` na linha `GRUB_CMDLINE_LINUX` para que persistam após a inicialização. É necessário gerar um novo arquivo de configuração para o carregador de inicialização a cada vez que `/etc/default/grub` é alterado, o que é feito com o comando `grub-mkconfig -o /boot/grub/grub.cfg`. Quando o sistema operacional estiver rodando, os parâmetros do kernel usados para carregar a sessão ficam disponíveis para leitura no arquivo `/proc/cmdline`.

---

#### INIT - Initialization process

- tem a função de iniciar os primeiros processos e serviços do linux
- é o processo de `ID 1` (pai de todos os outros processos)
- possui `RunLevels` ou `Targets` que definem diferentes modos de operação e o grupo de serviços que será iniciado
- principais `INITs` utilizados:
    - `SystemV` (`SysV`) - `init` original (conceito dos `RunLevels`)
    - `systemd` (conceito dos `Targets` - que é uma melhoria do `RunLevel`)
    - `upstart` (também uma é forma de melhoria do `init` original)

>[!NOTE]
>
>Estritamente falando, o sistema operacional é apenas o kernel e seus componentes, que controlam o hardware e gerenciam todos os processos. É comum, no entanto, usar o termo “sistema operacional” de maneira mais vaga, para designar um grupo inteiro de programas distintos que compõem o ambiente de software onde o usuário pode executar as tarefas computacionais básicas.

A inicialização do sistema operacional começa quando o carregador de inicialização carrega o kernel na RAM. Nesse momento, o kernel assume o controle da CPU e começa a detectar e configurar os aspectos fundamentais do sistema operacional, como a configuração básica de hardware e o endereçamento de memória.

O kernel abre então o `initramfs` (initial RAM filesystem). O `initramfs` é um arquivo que contém um sistema de arquivos raiz temporário usado durante o processo de inicialização. O principal objetivo de um arquivo `initramfs` é fornecer os módulos necessários para que o kernel possa acessar o sistema de arquivos raiz “de verdade” do sistema operacional.

Logo que o sistema de arquivos raiz fica disponível, o kernel monta todos os sistemas de arquivos configurados em `/etc/fstab` e, em seguida, executa o primeiro programa, um utilitário chamado `init`. O programa `init` é responsável por executar todos os scripts de inicialização e daemons do sistema. Existem implementações distintas desses iniciadores de sistema além do tradicional `init`, como o `systemd` e o `Upstart`. Depois que o programa `init` é carregado, o `initramfs` é removido da RAM.

- `Padrão SysV`: Um gerenciador de serviços baseado no padrão SysVinit controla quais daemons e recursos estarão disponíveis empregando o conceito de **níveis de execução**. Os níveis de execução são numerados de `0` a `6` e são projetados pelos mantenedores da distribuição para atender a propósitos específicos. As únicas definições de nível de execução compartilhadas entre todas as distribuições são os níveis `0`, `1` e `6`.
- `systemd`: O systemd é um gerenciador de sistemas e serviços moderno, com uma camada de compatibilidade para os comandos e níveis de execução do `SysV`. O `systemd` possui uma estrutura concorrente, emprega sockets e D-Bus para a ativação de serviços, execução de daemon sob demanda, monitoramento de processos com `cgroups`, `snapshot support`, `recuperação da sessão do sistema`, `controle de ponto de montagem` e um `controle de serviços baseado em dependências`. Nos últimos anos, a maioria das grandes distribuições Linux adotou gradualmente o `systemd` como seu gerenciador de sistema padrão.
- `Upstart`: Como o `systemd`, o `Upstart` é um substituto para o `init`. O foco do `Upstart` é acelerar o processo de inicialização, paralelizando o processo de carregamento dos serviços do sistema. O `Upstart` foi usado pelas distribuições baseadas no Ubuntu em versões anteriores, mas hoje deu lugar ao `systemd`.

---

#### dmesg (print or control the kernel ring buffer)

Durante o processo de `boot`, não tem como ir parando a rolagem da tela para ir vendo as informações do `boot`.

Para verificar o log de `boot`, use o comando `dmesg | less`. Lembrando que não haverá somente informações de `boot`, mas sim informações de tudo que for detectado, de forma geral, para o funcionamento/uso do sistema.

>[!NOTE]
>
>O espaço de memória em que o kernel armazena suas mensagens, incluindo as mensagens de inicialização, é chamado de **buffer de anel do kernel** (*kernel ring buffer*)

>[!NOTE]
>
>O buffer de anel do kernel perde todas as mensagens quando o sistema é desligado ou se o comando `dmesg --clear` for executado

No início do log, é informado a versão do `kernel`, que é passado pelo `GRUB`:
```
[    0.000000] Linux version 6.8.0-51-generic (buildd@lcy02-amd64-091) (x86_64-linux-gnu-gcc-13 (Ubuntu 13.3.0-6ubuntu2~24.04) 13.3.0, GNU ld (GNU Binutils for Ubuntu) 2.42) #52-Ubuntu SMP PREEMPT_DYNAMIC Thu Dec  5 13:09:44 UTC 2024 (Ubuntu 6.8.0-51.52-generic 6.8.12)
[    0.000000] Command line: BOOT_IMAGE=/vmlinuz-6.8.0-51-generic root=UUID=ed75f0cb-cf1f-4598-a66a-8f3b39ba3588 ro quiet splash
```

>[!TIP]
>
>O log de inicialização tem centenas de linhas, portanto a saída do comando `dmesg` é frequentemente canalizada para um comando de paginação — como o comando `less` — para facilitar a leitura. Usando o comando `dmesg -H` ou `dmesg --human` faz automaticamente a paginação da saída, eliminando a necessidade de usar explicitamente um comando de paginação

---

#### Boot UEFI

- `UEFI`: abreviação de Unified Extensible Firmware Interface
- Especificação definida por um grupo de empresas
- Firmware que **substitui** a BIOS

A sequência (fluxo de boot) `UEFI` é: **UEFI** -> **Bootloader (GRUB)** -> **Kernel** -> **Init**

Tendo as seguintes atribuições:
- `UEFI`: Lê a partição `ESP` (*EFI System Partition*) e carrega o bootloader específico
- `bootloader` (`GRUB` é o mais comum): seleciona e executa o `kernel` e o `initrd`
- `Kernel`: executa o `/sbin/ini`
- `Init`: inicia os programas/serviços do `runlevel`/`target` definido

>[!WARNING]
>
>Principal diferença com `BIOS` é que `UEFI` **NÃO** tem `MBR`

As características do `UEFI` são:
- Não lê dados da MBR
- Obtêm os bootloaders pelo `ESP` (*EFI System Partition*)
    - montada no diretório `/boot/efi`
    - utiliza um filesystem do tipo geralmente `FAT32`
- utiliza (preferencialmente) partições `GPT` ao invés de `MBR`
- suporta partições além do limite de `2TB`
- implementa o Boot Seguro (boot por meio de um kernel assinado)
- possui modo de compatibilidade com a `BIOS`
- configurado pelo UEFI Boot Manager
    - no Linux por meio do comando `efibootmgr`

>[!NOTE]
>
>O padrão UEFI também suporta um recurso chamado *Inicialização Segura*, que permite apenas a execução de aplicativos EFI assinados, ou seja, aplicativos EFI autorizados pelo fabricante do hardware. Esse recurso aumenta a proteção contra software malicioso, mas pode dificultar a instalação de sistemas operacionais não cobertos pela garantia do fabricante.

---

#### journalctl (Print log entries from the systemd journal)

É uma parte do `systemd`, que é `/lib/systemd/systemd-journald`. Funciona parecido com `dmesg`, onde faz coleta de logs e informações do que está acontecendo no sistema (coleta informações do boot também)

- `journalctl -b` ou `--boot`: mostra informações do current (atual) boot
- `journalctl -k` ou `--dmesg`: mostra mensagens do kernel do current (atual) boot
- `journalctl -f` ou `--follow`: monitora os logs
- `journalctl --list-boots` ou `--follow`: mostra uma lista de números de inicialização relativos à inicialização atual, seu hash de identificação e os registros de data e hora da primeira e última mensagens correspondentes:
```
$ journalctl --list-boots
 -4 9e5b3eb4952845208b841ad4dbefa1a6 Thu 2019-10-03 13:39:23 -03—Thu 2019-10-03 13:40:30 -03
 -3 9e3d79955535430aa43baa17758f40fa Thu 2019-10-03 13:41:15 -03—Thu 2019-10-03 14:56:19 -03
 -2 17672d8851694e6c9bb102df7355452c Thu 2019-10-03 14:56:57 -03—Thu 2019-10-03 19:27:16 -03
 -1 55c0d9439bfb4e85a20a62776d0dbb4d Thu 2019-10-03 19:27:53 -03—Fri 2019-10-04 00:28:47 -03
  0 08fbbebd9f964a74b8a02bb27b200622 Fri 2019-10-04 00:31:01 -03—Fri 2019-10-04 10:17:01 -03
```

Os logs de inicialização anteriores também são preservados nos sistemas baseados no `systemd`, sendo assim possível inspecionar as mensagens de sessões anteriores do sistema operacional. Se as opções `-b 0` ou `--boot=0` forem usadas, aparecem as mensagens da inicialização atual. As opções `-b -1` ou `--boot=-1` exibem as mensagens da inicialização anterior. As opções `-b -2` ou `--boot=-2` exibem as mensagens da inicialização antes da anterior e assim por diante. O trecho a seguir mostra o kernel chamando o gerenciador de serviços do `systemd` para o último processo de inicialização
```
$ journalctl -b 0
oct 04 00:31:01 ubuntu-host kernel: EXT4-fs (sda1): mounted filesystem with ordered data mode. Opts: (null)
oct 04 00:31:01 ubuntu-host kernel: ip_tables: (C) 2000-2006 Netfilter Core Team
oct 04 00:31:01 ubuntu-host systemd[1]: systemd 237 running in system mode.
oct 04 00:31:01 ubuntu-host systemd[1]: Detected architecture x86-64.
oct 04 00:31:01 ubuntu-host systemd[1]: Set hostname to <torre>.
oct 04 00:31:01 ubuntu-host systemd[1]: Reached target User and Group Name Lookups.
```

As mensagens sobre a inicialização e outras emitidas pelo sistema operacional são armazenadas em arquivos dentro do diretório `/var/log/`. Se ocorrer um erro crítico e o sistema operacional for incapaz de continuar o processo de inicialização depois de carregar o `kernel` e o `initramfs`, uma mídia de inicialização alternativa pode ser usada para iniciar o sistema e acessar o arquivo de sistemas correspondente. Depois disso, os arquivos em `/var/log/` podem ser consultados em busca das razões causaram a interrupção do processo de inicialização. As opções `-D` ou `--directory` do comando `journalctl` servem para ler mensagens de log em diretórios diferentes de `/var/log/journal/`, que é a localização padrão para as mensagens de log do `systemd`. Como as mensagens de log do sistema não são armazenadas em texto puro, o comando `journalctl` é necessário para que fiquem legíveis.

Exemplo:

Um disco rígido contendo todo o sistema de arquivos de uma máquina offline foi removido e conectado a uma máquina operacional como drive secundário. Supondo que seu ponto de montagem seja `/mnt/hd`, como o `journalctl` seria usado para inspecionar o conteúdo dos arquivos de diário localizados em `/mnt/hd/var/log/journal/`?

**Resposta**: Com os comandos `journalctl -D /mnt/hd/var/log/journal` ou `journalctl --directory=/mnt/hd/var/log/journal`

---

### 101.3 Alterar níveis de execução/destinos de inicialização e desligar ou reiniciar o sistema

Principais `INITs` utilizados:
- `SystemV` (`SysV`): init original
- `systemd`: gerenciador de sistemas e serviços compatível com o `SysV` (mais utilizado)
- `Upstart`: gerenciador de serviços substituro ao `init`, mas com opções de compatibilidade

---

#### SystemV (SysV) - INIT


- trabalha com `RunLevel` (nível de execução do sistema)
- cada `runlevel` carrega um conjunto de programas, scripts e serviços
- configuração principal fica em: `/etc/inittab`
- Diretórios de scripts: 
    - `/etc/init.d/`
    - `/etc/rc.d/`

São **7** `runleves`:
- `0`: Desligamento
- `1`,`s`,`S`: Single user

- `6`: Reinicialização

>[!NOTE]
>
>Em todas as distros esses `runlevels` são sempre os mesmos!

>[!NOTE]
>
>O gerenciador de serviços é o primeiro programa lançado pelo kernel durante o processo de inicialização, portanto seu `PID` (número de identificação do processo) é **SEMPRE** `1`


| **ID**  | **Descrição**  |
|---|---|
| `0`* | Desligamento  |
| `1`,`s`,`S`* | Single user / Usuário único  |
| `2` | Multiusuário (sem rede) |
| `3` | Multiusuário (com rede) |
| `4` | Multiusuário (definido pelo usuário) |
| `5` | Multiusuário (com rede e gráfico) |
| `6`* | Reinicialização |
*sempre serão o mesmo modo, independente da distribuição

Portanto é importante gravar que os modos `0`, `1` e `6` serão respectivamente modos de `desligamento`, `single user` e `reinicialização`

Já os demais modos, `2` ao `5`, variam de distribuição para distribuição.

Nos sistemas mais novos, é normal **não** vir mais com o `init`. Por padrão, o `init` fica em `/etc/initab`:

Exemplo do arquivo `inittab` (criado manualmente, com o básico):
```
# Default runlevel
id:3:initdefault:

# Configuration script executed during boot
si::sysinit:/etc/init.d/rcS

# Action taken on runlevel S (single user)
~:S:wait:/sbin/sulogin

# Configuration for each execution level
l0:0:wait:/etc/init.d/rc 0
l1:1:wait:/etc/init.d/rc 1
l2:2:wait:/etc/init.d/rc 2
l3:3:wait:/etc/init.d/rc 3
l4:4:wait:/etc/init.d/rc 4
l5:5:wait:/etc/init.d/rc 5
l6:6:wait:/etc/init.d/rc 6

# Action taken upon ctrl+alt+del keystroke
ca::ctrlaltdel:/sbin/shutdown -r now

# Enable consoles for runlevels 2 and 3
1:23:respawn:/sbin/getty tty1 VC linux
2:23:respawn:/sbin/getty tty2 VC linux
3:23:respawn:/sbin/getty tty3 VC linux
4:23:respawn:/sbin/getty tty4 VC linux

# For runlevel 3, also enable serial
# terminals ttyS0 and ttyS1 (modem) consoles
S0:3:respawn:/sbin/getty -L 9600 ttyS0 vt320
S1:3:respawn:/sbin/mgetty -x0 -D ttyS1
```

No exemplo acima, temos que o `initdefault` é o `runlevel` `default`, e no caso é o runlevel `2`.

>[!NOTE]
>
>O comando `telinit q` deve ser executado a cada vez que o arquivo `/etc/inittab` é modificado. O argumento `q` (ou `Q`) pede que o `init` recarregue sua configuração. Essa etapa é importante para evitar uma parada do sistema devido a uma configuração incorreta em `/etc/inittab`

Resumidamente o fomato é: `id:runlevels:action:process`, e separado por dois pontos temos:
- `id`: é um nome genérico de até quatro caracteres usados para identificar a entrada. O item `runlevels` é uma lista de números dos níveis de execução nos quais uma ação especificada deve ser executada. O termo `action` define como `init` executará o processo indicado pelo termo `process`. As ações disponíveis são:
    - `boot`: O processo será executado durante a inicialização do sistema. O campo `runlevels` é ignorado.
    - `bootwait`: O processo será executado durante a inicialização do sistema e o `init` aguardará sua conclusão para continuar. O campo `runlevels` é ignorado.
    - `sysinit`: O processo será executado após a inicialização do sistema, qualquer que seja o nível de execução. O campo `runlevels` é ignorado.
    - `wait`: O processo será executado nos níveis de execução dados e `init` aguardará sua conclusão para continuar.
    - `respawn`: O processo será reiniciado caso seja encerrado.
    - `ctrlaltdel`: O processo será executado quando o processo `init` receber o sinal `SIGINT`, disparado quando o atalho de teclado `Ctrl`+`Alt`+`Del` for pressionado.

Já em `/etc/init.d` é onde ficam os arquivos/scripts dos serviços. Por exemplo, dentro dele tem um arquivo/script do `cron`, que podemos executar: `./cron status`, mostrando o status do `cron`, assim como dar `start` no cron, ou `parar`, sendo respectivamente: `./cron stop` e `./cron start`

Os diretórios dos runleves podem ser vistos com o comando `ls -ld /etc/rc*`
```
ls -ld /etc/rc*
drwxr-xr-x 2 root root 4096 Jan 22 14:51 /etc/rc0.d
drwxr-xr-x 2 root root 4096 Jan 22 14:51 /etc/rc1.d
drwxr-xr-x 2 root root 4096 Jan 23 08:59 /etc/rc2.d
drwxr-xr-x 2 root root 4096 Jan 23 08:59 /etc/rc3.d
drwxr-xr-x 2 root root 4096 Jan 23 08:59 /etc/rc4.d
drwxr-xr-x 2 root root 4096 Jan 23 08:59 /etc/rc5.d
drwxr-xr-x 2 root root 4096 Jan 22 14:51 /etc/rc6.d
drwxr-xr-x 2 root root 4096 Jan 15 08:15 /etc/rcS.d
```

Essa estrutura é mantida a título de compatibilidade (com o `systemd`, por exemplo)

Se pegarmos um diretório, como por exemplo o `/etc/rc5.d`, podemos notar que é composto por uma lista de links, que são serviços que o linux deve iniciar (representado por `S` - *start* - no início do nome arquivo/link) ou finalizar (representado por `K` - *kill* - no início do nome do arquivo/link)

`/etc/rc5.d`
```
ls -l /etc/rc5.d/
total 0
lrwxrwxrwx 1 root root 29 Jan 14 15:59 K01apache-htcacheclean -> ../init.d/apache-htcacheclean
lrwxrwxrwx 1 root root 27 Nov  8 16:17 K01speech-dispatcher -> ../init.d/speech-dispatcher
lrwxrwxrwx 1 root root 19 Jan 22 14:51 K01tftpd-hpa -> ../init.d/tftpd-hpa
lrwxrwxrwx 1 root root 17 Nov  8 16:17 S01anacron -> ../init.d/anacron
lrwxrwxrwx 1 root root 17 Jan 14 15:59 S01apache2 -> ../init.d/apache2
lrwxrwxrwx 1 root root 13 Nov 14 11:53 S01atd -> ../init.d/atd
lrwxrwxrwx 1 root root 14 Jan 14 11:46 S01atop -> ../init.d/atop
lrwxrwxrwx 1 root root 18 Jan 14 11:46 S01atopacct -> ../init.d/atopacct
#lista ocultada
```

`/etc/rc0.d` (desligamento, comum dar `kill`)
```
ls -l /etc/rc0.d/
total 0
lrwxrwxrwx 1 root root 20 Nov  8 16:17 K01alsa-utils -> ../init.d/alsa-utils
lrwxrwxrwx 1 root root 17 Jan 14 15:59 K01apache2 -> ../init.d/apache2
lrwxrwxrwx 1 root root 29 Jan 14 15:59 K01apache-htcacheclean -> ../init.d/apache-htcacheclean
lrwxrwxrwx 1 root root 13 Nov 14 11:53 K01atd -> ../init.d/atd
lrwxrwxrwx 1 root root 14 Jan 14 11:46 K01atop -> ../init.d/atop
lrwxrwxrwx 1 root root 18 Jan 14 11:46 K01atopacct -> ../init.d/atopacct
lrwxrwxrwx 1 root root 19 Nov  8 16:17 K01bluetooth -> ../init.d/bluetooth
#lista ocultada
```

---

#### comandos usados para runlevel

- `runlevel` (comando usado no `SysV` e no `init`): mostra o runlevel **anterior** e o **atual**. O `N` mostra que o nível de execução não mudou desde a última inicialização.
```
$ runlevel
N 5
```

Já se necessitar mudar o runlevel, é necessário usar o comando:

- `init` ou `telinit`: para mudanças de runlevel (ambos 
fazem parte do `SysV`)
- `init 0`: desliga o computador (runlevel `0`)
- `init 1` ou `init s` ou `init S`: entra no runlevel de single `mode/user`
- `telinit 1` ou `telinit s` ou `telinit S`: entra no runlevel de single `mode/user`
- `telinit 2`: entra no runlevel `2`
- `init 6`: entra no runlevel `6` (reinicialização - reinicia o computador)

---

#### mais sobre telinit

Usando `telinit --help` abriamos mais informações sobre o `telinit`:
```
$ telinit --help
telinit [OPTIONS...] COMMAND

Send control commands to the init daemon.

Commands:
  0              Power-off the machine
  6              Reboot the machine
  2, 3, 4, 5     Start runlevelX.target unit
  1, s, S        Enter rescue mode
  q, Q           Reload init daemon configuration
  u, U           Reexecute init daemon

Options:
     --help      Show this help
     --no-wall   Don't send wall message before halt/power-off/reboot

See the telinit(8) man page for details.
```
Uma opção interessante é a `q` ou `Q`, que recarrega o daemon de configuração (`/etc/inittab`). Equivalente a `systemctl daemon-reload`

Há também a opção `u` ou `U` para reexecutar o o daemon. Equivalente a `systemctl daemon-reexec`

---

<a id="systemd"></a>
#### systemd

- `systemd` é uma outra forma de gerenciar os runLevels, mais eficiente que o `SysV` com diversas melhorias (é compatível com `SysV`)
- melhorias como paralelização, uso do `dbus`, entre outros
- conceito de `Units` (não ideia de `runLevel`), e grupos de `units`, que é igual a um `target`
- `unidade` = `Nome.Tipo` (Ex. `httpd.service`, que é igual a uma unidade)

Tendo os tipos:
- `service`: O tipo de unidade mais comum, para recursos ativos do sistema que podem ser iniciados, interrompidos e recarregados.
- `socket`: O tipo de unidade socket pode ser um socket de sistema de arquivos ou um socket de rede. Todas as unidades socket possuem uma unidade de serviço correspondente, carregada quando o socket recebe uma solicitação.
- `device`: Uma unidade de dispositivo está associada a um dispositivo de hardware identificado pelo kernel. Um dispositivo só será considerado como uma unidade `systemd` se existir uma regra `udev` para isso. Uma unidade de dispositivo pode ser usada para resolver dependências de configuração quando determinado hardware é detectado, uma vez que as propriedades da regra `udev` podem ser usadas como parâmetros para a unidade de dispositivo.
- `mount`: Uma unidade de montagem é uma definição de ponto de montagem no sistema de arquivos, semelhante a uma entrada em `/etc/fstab`.
- `automount`: Uma unidade de montagem automática também é uma definição de ponto de montagem no sistema de arquivos, mas nesse caso montada automaticamente. Cada unidade de montagem automática possui uma unidade de montagem correspondente, que é iniciada quando o ponto de montagem automática é acessado.
- `target` que é equivalente a `runlevel` (o `systemd` tem um target default - uma unidade de destino é um agrupamento de outras unidades, gerenciadas como uma única unidade)
- `snapshot`: Uma unidade snapshot é um estado salvo do gerenciador do `systemd` (não disponível em todas as distribuições Linux).

O diretório principal de configuração do `systemd` é `/lib/systemd/system` (onde ficam os arquivos de configuração dos serviços)

- `ls -ld /lib/systemd/system/*.target`: lista os grupos de execução.

Há links para manter a compatibilidade:
```
$ ls -ld /lib/systemd/system/*[0-9].target
lrwxrwxrwx 1 root root 15 Aug  8 11:51 /lib/systemd/system/runlevel0.target -> poweroff.target
lrwxrwxrwx 1 root root 13 Aug  8 11:51 /lib/systemd/system/runlevel1.target -> rescue.target
lrwxrwxrwx 1 root root 17 Aug  8 11:51 /lib/systemd/system/runlevel2.target -> multi-user.target
lrwxrwxrwx 1 root root 17 Aug  8 11:51 /lib/systemd/system/runlevel3.target -> multi-user.target
lrwxrwxrwx 1 root root 17 Aug  8 11:51 /lib/systemd/system/runlevel4.target -> multi-user.target
lrwxrwxrwx 1 root root 16 Aug  8 11:51 /lib/systemd/system/runlevel5.target -> graphical.target
lrwxrwxrwx 1 root root 13 Aug  8 11:51 /lib/systemd/system/runlevel6.target -> reboot.target
```

Assim como o `default.target`:
```
$ ls -ld /lib/systemd/system/default.target
lrwxrwxrwx 1 root root 16 Aug  8 11:51 /lib/systemd/system/default.target -> graphical.target
```

Há também o arquivo de configuração que fica em `/etc/systemd`, que possuir alguns arquivos e diretórios referentes à configuração do `systemd` (o `/lib/systemd/system/` ainda é mais importante)


Bom reforçar que o `init`, que fica em `/sbin/init`, aponta para `/lib/systemd/systemd` (a depender da distribuição, óbvio), por isso tanto `systemd` como `init` funcionam.
```
$ ps axu |grep /sbin/init
root           1  0.0  0.0  23164 11772 ?        Ss   Jan10   0:26 /sbin/init splash
rodrigo   720845  0.0  0.0   9280  2176 pts/0    S+   19:15   0:00 grep --color=auto /sbin/init

$ ls -l /sbin/init 
lrwxrwxrwx 1 root root 22 Aug  8 11:51 /sbin/init -> ../lib/systemd/systemd
```

Quando usa os comandos `init` e `telinit`, na realidade está usando via `systemd`, devido aos links internos. O comando nativo do `systemd` é o `systemctl` (`systemctl --help`)

>[!NOTE]
>
>Se for visto em perguntas, comandos `systemctl`, esse tem a ver com o `systemd` (lembrar disso).

- `systemctl reboot`: reinicia o computador
- `systemctl poweroff`: desliga o computador

Algumas distribuições Linux vinculam `poweroff` e `reboot` a `systemctl` como comandos individuais. Por exemplo:
```
$ sudo which poweroff
/usr/sbin/poweroff

$ sudo ls -l /usr/sbin/poweroff
lrwxrwxrwx 1 root root 14 Aug 20 07:50 /usr/sbin/poweroff -> /bin/systemctl
```

Quando desligar/reiniciar o servidor, é possível enviar mensagem utilizando o comando [wall](#wall).


- `systemctl set-defaul multi-user.target`: muda o target default (na prática atualiza o link que aponta para o `default.target`)
- `systemctl isolate rescue.target`: mudar de target no `systemd`, no caso muda para o equivalente ao `runlevel1` (`rescue.target`), ou poderia ser `systemctl isolate runlevel1.target`(considera o link)
- `systemctl default`: inicia o `default.target`

>[!WARNING]
>
>Como nos sistemas que adotam o `SysV`, o destino padrão **nunca** deve apontar para `shutdown.target`, pois ele corresponde ao nível de execução `0` (encerramento).

- `systemctl start unit.service`: Inicia unit.
- `systemctl stop unit.service`: Interrompe unit.
- `systemctl restart unit.service`: Reinicia unit.
- `systemctl status unit.service`: Mostra o estado de unit, incluindo se está ou não em execução.
- `systemctl is-active unit.service`: Exibe active se unit estiver rodando, ou inactive se não estiver.
- `systemctl enable unit.service`: Habilita unit, ou seja, unit será carregado durante a inicialização do sistema.
- `systemctl disable unit.service`: unit não será iniciado com o sistema.
- `systemctl is-enabled unit.service`: Verifica se `unit` é iniciado com o sistema. A resposta é armazenada na variável `$?`. O valor `0` indica que unit inicia com o sistema e o valor `1` indica que não: `echo $?`

>[!NOTE]
>
>Se não houver outras unidades com o mesmo nome no sistema, o sufixo após o ponto poderá ser descartado. Se, por exemplo, houver apenas uma unidade `httpd` do tipo `service`, somente `httpd` bastará como parâmetro de unidade para `systemctl`.

O comando `systemctl list-unit-files` lista todas as unidades disponíveis e mostra se elas estão habilitadas para iniciar quando o sistema é inicializado. A opção `--type` seleciona apenas as unidades para um tipo determinado, como em `systemctl list-unit-files --type=service` e `systemctl list-unit-files --type=target`

O `systemd` também é responsável por acionar e responder a eventos relacionados ao **consumo de energia**. 

O comando `systemctl suspend` coloca o sistema no modo de baixo consumo de energia, mantendo os dados atuais na memória. 

O comando `systemctl hibernate` copia todos os dados da memória no disco, para que o estado atual do sistema possa ser recuperado após o desligamento. 

As ações associadas a esses eventos são definidas no arquivo `/etc/systemd/logind.conf` ou em arquivos separados dentro do diretório `/etc/systemd/logind.conf.d/`. No entanto, esse recurso do `systemd` pode ser usado apenas quando não houver outro gerenciador de energia em execução no sistema, como o daemon `acpid`. O daemon `acpid` é o principal gerenciador de energia do Linux e permite ajustes mais refinados das ações após eventos relacionados ao consumo de energia, como fechar a tampa do laptop, bateria fraca ou níveis de carga da bateria.

#### Exercício interessante de systemd

1. Como se verifica o destino padrão do sistema em um sistema baseado em `systemd`?

**Resposta**:O link simbólico `/etc/systemd/system/default.target` aponta para o arquivo da unidade definido como destino padrão. Também é possível usar o comando `systemctl get-default`.

2. Identifique se a sua instalação Linux está utilizando `SysV`, `systemd` ou `upstart`

**Resposta**: por meio dos comandos:
```
$ ps -p 1
    PID TTY          TIME CMD
      1 ?        00:00:30 systemd
```
ou
```
$ sudo stat /proc/1/exe       
  File: /proc/1/exe -> /usr/lib/systemd/systemd
  Size: 0         	Blocks: 0          IO Block: 1024   symbolic link
Device: 0,24	Inode: 7309287     Links: 1
Access: (0777/lrwxrwxrwx)  Uid: (    0/    root)   Gid: (    0/    root)
Access: 2025-01-28 21:01:43.802204580 -0300
Modify: 2025-01-17 19:33:43.810326627 -0300
Change: 2025-01-17 19:33:43.810326627 -0300
 Birth: -
```

3.  Identifique o `runlevel` ou `target` padrão em seu sistema de inicialização `SysV` ou `systemd`

**Resposta**: com os comandos:
```
$ ls -lh /lib/systemd/system/default.target 
lrwxrwxrwx 1 root root 16 Aug  8 11:51 /lib/systemd/system/default.target -> graphical.target
```
ou
```
$ systemctl get-default 
graphical.target
```

---

#### upstart

- `upstart` veio para substituir o `init` (`sysV`)
- mantém compatibilidade
- configuração fica em `/etc/init/`


Principais comandos:
- `initctl list`: lista os serviços do sistema
- `start serviço`: iniciar serviço
- `stop serviço`: para serviço
- `status serviço`: mostra status do serviço

Cada uma das ações do `Upstart` tem seu próprio comando independente. Por exemplo, o comando start pode ser usado para iniciar um sexto terminal virtual:
```
# start tty6
```
O estado atual de um recurso pode ser verificado com o comando `status`:
```
# status tty6
tty6 start/running, process 3282
```
E a interrupção de um serviço é feita com o comando `stop`:
```
# stop tty6
```
O Upstart **não** usa o arquivo `/etc/inittab` para definir os níveis de execução, mas os comandos legados `runlevel` e `telinit` ainda podem ser usados para verificar e alternar entre níveis de execução.

>[!TIP]
>
>Ao ver o `initctl` em alguma perguntar, **ASSOCIAR** ao `upstart`.

Lembrar:

- `systemctl` -> `systemd`
- `initctl` -> `upstart`

>[!NOTE]
>
>O Upstart foi desenvolvido para a distribuição Ubuntu Linux para facilitar a inicialização paralela dos processos. O Ubuntu parou de usar o `Upstart` em 2015, quando migrou do `Upstart` para o `systemd`

---

#### shutdown, reboot, poweroff, halt

Em vez de usar `init0` ou `telinit0` para desligar o computador, o ideal é usar o `shutdown`, pois esse, por exemplo, emite um aviso para os usuário conectados que o computador será desligado/reiniciado. O `shutdown` ainda **impede** novos logins. 

>[!NOTE]
>
>`shutdown` também serve para reiniciar! `shutdown -r` ou `reboot`

O `shutdown` emite **dois** sinais para os processos, primeiro o `SIGTERM`, que seria um "matar" de forma soft (`ID 15`), e depois recebe um sinal de `kill` (`SIGKILL` ou `ID 9`) mesmo, para matar definitivamente, encerrando ou mudando seu nível de execução (veja mais sobre `kill` e `SIG` [aqui](#kill)). Por padrão, quando as opções `-h` ou `-r` não são usadas, o sistema alterna para o nível de execução `1`, ou seja, o modo de `usuário único` (`single user`).

---

#### Principais comandos shutdown:

- `shutdown` (somente shutdown): desliga o computador em **1** minuto
- `shutdown -c`: cancela o comando de desligar
    - **sempre** informando aos outros usuários conectados!
- `shutdown -r` ou `--reboot`: reinicia o sistema 
- `shutdown -H` ou `--halt`: desliga o sistema Linux (mantem fonte ligada).
- `shutdown -P` ou `--poweroff`:desliga o sistema e a fonte de energia (depende do hardware que está usando).
- `shutdown -h`: mesmo que `--poweroff`, mas não sobrescreve a ação tomada se for `halt`
- `shutdown -p: (`--poweroff`): desliga o computador.
`--no-wall` (não envia mensagem antes de reiniciar)
- `shutdown -r +10`: agenda o restart daqui 10 minutos.
- `shutdown 18:00`: programa o desligamento às 18 horas

O formato do shutdown para desligamento programado é `shutdown [option] time [message]`

Somente o parâmetro `time` é obrigatório. Esse parâmetro define quando a ação solicitada será executada, aceitando os seguintes formatos:
- `hh:mm`: Este formato especifica o tempo de execução em horas e minutos.
- `+m`: Este formato especifica quantos minutos esperar antes da execução.
- `now` ou `+0`: Este formato determina a execução imediata.

O parâmetro `message` é o texto de aviso enviado a todas as sessões de terminal dos usuários logados.

A implementação do `SysV` permite limitar os usuários que poderão reiniciar a máquina pressionando `Ctrl`+`Alt`+`Del`. Para isso, incluímos a opção `-a` no comando `shutdown` presente na linha referente a `ctrlaltdel` no arquivo `/etc/inittab`. Ao fazer isso, somente usuários cujos nomes de usuário constem do arquivo `/etc/shutdown.allow` poderão reiniciar o sistema com o atalho de teclado `Ctrl`+`Alt`+`Del`.

Como já visto em [systemd](#systemd), o comando `systemctl` também pode ser usado para desligar ou reiniciar a máquina em sistemas que empregam o `systemd`.
- `systemctl reboot`: reiniciar o sistema
- `systemctl poweroff`: desligar o sistema (ambos os comandos requerem privilégios de root para serem executados, pois usuários comuns não podem realizar esses procedimentos)

>[!NOTE]
>
>Algumas distribuições Linux vinculam `poweroff` e `reboot` a `systemctl` como comandos individuais. Por exemplo:
```
$ sudo which poweroff
/usr/sbin/poweroff
$ sudo ls -l /usr/sbin/poweroff
lrwxrwxrwx 1 root root 14 Aug 20 07:50 /usr/sbin/poweroff -> /bin/systemctl
```

>[!TIP]
>
>Nem todas as atividades de manutenção exigem que o sistema seja desligado ou reiniciado. No entanto, quando é necessário alterar o estado do sistema para o modo de usuário único, é importante avisar os usuários conectados para que não sejam prejudicados pelo encerramento abrupto de suas atividades.

>[!TIP]
>
>Como no caso do comando `shutdown` ao desligar ou reiniciar o sistema, o comando `wall` pode enviar uma mensagem para as sessões de terminal de todos os usuários logados. Para isso, o administrador do sistema só precisa fornecer um arquivo ou escrever diretamente a mensagem como um parâmetro para o comando `wall`.

---

#### Outros comandos similares ao shutdown:

- `reboot`: reiniciar
- `halt`: desliga o linux (mantendo a fonte)
- `poweroff`: desliga o linux e a máquina

<a id="wall"></a>
#### comando wall:

Manda mensagem para todos os users do sistema: 
```
`wall "Vamos tomar uma café"`
```
Dispara a mensagem para todos os usuários do sistema.

---

#### acpid

`ACPI` - *Advanced Configuration and Power Interface*: é uma especificação do mercado de hardware, para tratar de itens referentes à energia do computador ou hardwares, como baterias, voltagem/tensão, rotação do cooler, temperatura, tudo voltado à energia do hardware. (`acpid` é o daemon, mas o serviço chama-se `acpid`)

Quem comando isso no Linux é o processo `acpid`. Veja ele em `ps axu | grep acpi` (`/usr/sbin/acpid`)

- `acpi`: mostra o básico
```
$ acpi
Battery 0: Discharging, 0%, rate information unavailable
```
- `acpi -V`: mostra todas as informações
```
$ acpi -V
Battery 0: Discharging, 0%, rate information unavailable
Thermal 0: ok, 27.8 degrees C
Thermal 0: trip point 0 switches to mode critical at temperature 119.0 degrees C
Thermal 0: trip point 1 switches to mode active at temperature 71.0 degrees C
Thermal 0: trip point 2 switches to mode active at temperature 55.0 degrees C
Thermal 0: trip point 3 switches to mode active at temperature 50.0 degrees C
Thermal 0: trip point 4 switches to mode active at temperature 45.0 degrees C
Cooling 0: Fan 0 of 1
Cooling 1: Processor 0 of 3
Cooling 2: Processor 0 of 3
Cooling 3: dell-smm-fan1 3 of 2
Cooling 4: Processor 0 of 3
Cooling 5: TCC Offset 0 of 63
Cooling 6: Processor 0 of 3
Cooling 7: Processor 0 of 3
Cooling 8: Fan 0 of 1
Cooling 9: x86_pkg_temp no state information available
Cooling 10: Processor 0 of 3
Cooling 11: Fan 0 of 1
Cooling 12: Processor 0 of 3
Cooling 13: Fan 0 of 1
Cooling 14: Processor 0 of 3
Cooling 15: Processor 0 of 3
Cooling 16: intel_powerclamp 0 of 100
Cooling 17: Processor 0 of 3
Cooling 18: Processor 0 of 3
Cooling 19: Fan 0 of 1
Cooling 20: Processor 0 of 3
```

- `whatis acpi`: Advanced Configuration and Power Interface event daemon: monitora o gerenciamento de energia do computador. Se a temperatura subir absurdamente, ele pode dar um `shutdown` no computador, por exemplo.

---

## Tópico 102: 102 Instalação do Linux e gerenciamento de pacotes

<a id="102.1"></a>

### 102.1 Definir o esquema de partições do disco rígido

---

#### Conceitos: Partição, Ponto de Montagem, FS MBR

`sda1`, `sda2`, etc são as **PARTIÇÕES** de um disco (disco `sda`, por exemplo). 

`/var`, `/home` são **PONTOS DE MONTAGEM** de uma determinada partição. Logo, o correto é dizer que a partição `sda1` está **associada** ao ponto de montagem `/`, por exemplo. Ou a partição `sda2` está associada ao ponto de montagem `/var`, e assim por diante.

- `sda1`: partição
- `/boot`: ponto de montagem de alguma partição (poderia ser de `sda1`, por exemplo). É comum dizer partição `/boot`, mas o correto é dizer ponto de montagem

- Vantagens:
- **GERENCIAMENTO DO ESPAÇO EM DISCO**:
    - Uma das vantagens do uso de partições é evitar que, por exemplo, um usuário ocupe todo o tamanho do disco com um arquivo, fazendo assim com que as aplicações, ou outros usuários, não consigam mais trabalhar no sistema. Ou como um arquivo de log ocupar todo espaço. Separando o disco em partições, se um usuário esgotar a capacidade de sua partição, ou um log que cresceu demais, acabar também esgotando todo o espaço, isso não influenciará nas demais aplicações (devido à separação do disco em partições).
- **DIFERENTES TIPOS DE FILESYSTEM PARA CADA PARTIÇÃO**:
    - Há filesystems que são mais otimizados ou tem maior performance para trabalhar com arquivos maiores, ou uma quantidade grande de arquivos menores e etc. Dependendo do uso da partição, podemos associar um tipo específico de filesystem.
- **PROTEÇÃO CONTRA ERROS DO DISCO**:
    - Caso um disco venha apresentar falha física (em um setor/cilindro, por exemplo), e estiver com uma partição apenas, isso vai acabar comprometendo o funcionamento de todo o disco. Se tivermos um problema em uma partição, apenas ela poderá ser impactada (dependendo do erro de disco).
- **DIFERENTES NÍVEIS DE SEGURANÇA**:
    - Podemos, por exemplo, deixar a partição `sda3` que está associada ao ponto de montagem `/usr` como somente leitura (`ro`)
- **BACKUP FACILITADO**:
    - Imagine o `/home` associado a uma partição. Isso facilita muito aos programas de backup, pois teríamos que apenas apontar para aquele ponto de montagem, que está em uma partição.

>[!TIP]
>
>Há também razões de desempenho para manter determinados diretórios em partições separadas. Você pode querer manter o sistema de arquivos raiz (`/`) em uma unidade SSD rápida, e diretórios maiores como `/home` e `/var` em discos rígidos mais lentos, que oferecem muito mais espaço por um preço bem menor.


Na maioria das distribuições Linux e ambientes de desktop modernos, os dispositivos removíveis são montados automaticamente em `/media/USER/LABEL` quando conectados ao sistema, sendo `USER` o nome de usuário e `LABEL` o nome do dispositivo. Por exemplo, um drive flash USB com o nome `FlashDrive` conectado pelo usuário `john` seria montado em `/media/john/FlashDrive/`. A maneira como isso é feito varia de acordo com o ambiente de desktop.


---

#### Sistemas de Particionamento (MBR e GPT)

São modelos e formas de fazer o particionamento do disco

- `MBR`: *Master Boot Record*: padrão, mas é limitado a **2TB** por partição.

- `GPT`: *GUID Partition Table*:  utilizado quando são necessárias partições **maiores de 2TB** (maioria dos sistemas com `EFI` utilizam `GPT`)

>[!NOTE]
>
>Para a LPI, o que mais cai é `MBR`

---

#### PARTIÇÕES MBR

Originalmente era limitada a `4` partições **PRIMÁRIAS**, ou seja, `1` disco poderia ter no **máximo** `4` partições. 

Para superar esse limite podemos criar uma partição **ESTENDIDA** (*extended partition*) no lugar de uma **PRIMÁRIA**, e ir adicionando partições **LÓGICAS** dentro da partição **ESTENDIDA**, quantas forem necessárias.

Portanto podemos ter:

- `4` **partições PRIMÁRIAS** ou
- `3` **partições PRIMÁRIAS** e `1` **partição LÓGICA**.

>[!WARNING]
>
>**NÃO** faz sentido criar mais do que **UMA** partição **ESTENDIDA**!

---

#### GPT

Os discos particionados em GPT podem ser usados em computadores com a BIOS tradicional do PC ou com o firmware UEFI. Em máquinas com BIOS, a segunda parte do GRUB é armazenada em uma partição especial de inicialização da BIOS

Em sistemas com firmware UEFI, o GRUB é carregado pelo firmware a partir dos arquivos `grubia32.efi` (para sistemas de 32 bits) ou `grubx64.efi` (para sistemas de 64 bits) em uma partição chamada `ESP` (*EFI System Partition*)

#### NUMERAÇÃO DAS PARTIÇÕES

- `Primárias`: vão de `1` a `4`. Exemplo: `sda1`, `sda2`, `sda4` (podemos ter uma lacuna, do `2` vai para o `4`)

- `Lógicas`: vão a partir de `5`. Exemplo: `sda5`, `sda6`, `sda7` (**não** podemos ter lacunas, **tem que ser sequencial**)

---

#### Partições no Linux

- `/`: é a primeira partição montada pelo kernel
- ao menos `2` partições devem ser criadas: `/` e `swap` (como o sistema nunca pode ficar sem espaço na memória RAM - volátil - para evitar o travamento do sistema, uma alternativa é o uso da área de `swap`, um espaço no HD caso a RAM fiquem sem espaço, operando como se fosse a RAM)

#### swap

A partição de troca (ou `swap`) é usada para passar as páginas de memória da RAM para o disco conforme necessário. Esta partição precisa ser de um tipo específico e configurada com um utilitário apropriado chamado `mkswap` antes de poder ser usada.

A partição de troca não pode ser montada como as outras, o que significa que não é possível acessá-la como um diretório normal e visualizar seu conteúdo.

>[!TIP]
>
>Um sistema pode ter diversas partições de troca (embora isso seja incomum), e o Linux também suporta o uso de **arquivos de troca** em vez de partições, o que pode ser útil para aumentar rapidamente o espaço de troca quando necessário.

O tamanho da partição de troca é um tema controverso. A regra antiga dos primeiros dias do Linux (“duas vezes a quantidade de RAM”) nem sempre se aplica, dependendo de como o sistema está sendo usado e da quantidade de RAM física instalada.

Na documentação do Red Hat Enterprise Linux 7, a Red Hat recomenda o seguinte:

| **Quantidade de RAM** | **Tamanho de troca recomendado** | **Tamanho de troca recomendado com hibernação**  |
|---|---|---|
| < 2 GB de RAM | 2x a quantidade de RAM | 3x a quantidade de RAM |
| 2-8 GB de RAM | Igual à quantidade de RAM | 2x a quantidade de RAM |
| 8-64 GB de RAM | No mínimo 4 GB | 1.5x a quantidade de RAM |
| > 64 GB de RAM | No mínimo 4 GB | Não recomendado |

Obviamente, a quantidade de troca pode depender da carga de trabalho. Se a máquina estiver executando um serviço crítico, como um banco de dados, servidor Web ou SAP, é aconselhável verificar o valor recomendado na documentação desses serviços (ou consultar o fornecedor do software).

---

#### Código dos tipos de partição:

- `0x83` = Linux FileSystem
- `0x82` = Linux swap

---

#### Principais partições no Linux (recomendado instalar em partições distintas)

- `/home`: dados pessoais e preferências dos usuário, para que os dados não impactem no funcionamento do sistema (outra grande vantagem de separar `/home` é que quando precisar reinstalar outro sistema para testes, não vai perder os dados que estão nessa partição)
- `/var` (dados variáveis): diretórios temporários de fila, que tendem a crescer e ocupar muito espaço em disco. Dentre eles estão os logs do sistema (em `/var/log`), os arquivos temporários (`/var/tmp`) e os dados de aplicativos em cache (em `/var/cache`). `/var/www/html` também é o diretório padrão para os arquivos de dados do Apache Web Server e `/var/lib/mysql` é o local padrão para os arquivos de banco de dados do servidor MySQL. Porém, ambos podem ser alterados. Uma boa razão para colocar `/var` em uma partição separada é a estabilidade. Muitos aplicativos e processos escrevem em `/var` e seus subdiretórios, como `/var/log` ou `/var/tmp`. Um processo defeituoso poderia escrever dados até que não restasse nenhum espaço livre no sistema de arquivos. Se `/var` estiver em `/`, isso poderia disparar um pânico do kernel e corromper o sistema de arquivos, causando uma situação muito difícil de reverter. Mas se `/var` for mantido em uma partição separada, o sistema de arquivos raiz não será afetado.
- `/tmp`: semelhante ao `/var` (arquivos de `lock` e temporários)
- `/boot`: arquivos do `kernel`, `initrd`, carregados pelo GRUB (antigamente havia uma limitação com o LILO que esses arquivos deveriam estar no limite do cilindro `1024`, por isso era comum criar o `/boot`, o GRUB (`/boot/grub`) hoje em dia já consegue acessar os dados mesmo que estejam após o limite de `1024`). Isso ocorre porque a IBM PC BIOS original endereçava os discos usando cilindros, cabeças e setores (`CHS`), com um máximo de `1024` cilindros, `256` cabeças e `63` setores, resultando em um tamanho máximo de disco de `528` MB (`504` MB no MS-DOS). Isso significa que qualquer coisa além dessa marca não estaria acessível em sistemas legados, a menos que um esquema de endereçamento de disco diferente (como o Endereçamento de bloco lógico, `LBA`) fosse usado.
- `/usr`: muitos arquivos de aplicação, que são instalados. Evita que erros em outras partições impliquem no funcionamento dos aplicativos instalados.

>[!WARNING]
>
>Para garantir uma compatibilidade máxima, a partição `/boot` geralmente está localizada no início do disco e termina antes do cilindro `1024` (`528 MB`), garantindo que a máquina sempre possa carregar o kernel. O tamanho recomendado para essa partição em uma máquina atual é de `300 MB`

>[!WARNING]
>
>Outras razões para uma partição `/boot` separada são a criptografia e a compactação, já que alguns métodos ainda não são suportados pelo GRUB 2, ou ainda se a partição raiz do sistema (`/`) precisar ser formatada usando um sistema de arquivos não suportado.

---
<a id="dir-nao-podem-ficar-fora-de-barra"></a>

#### Diretórios que NÃO podem estar montados fora do `/`

- `/etc`: arquivos de configurações e dados que precisam para montar outras partições (exemplo, `/etc/fstab` - se estiver em outra partição, não vai ter acesso às outras partições)
- `/bin`: comandos, scripts, programas utilizados no linux
- `/sbin`: comandos, scripts, programas utilizados no linux
- `/dev`: diretório dinâmico
- `/proc`: diretório dinâmico
- `/sys`: diretório dinâmico

---

#### Conceito LVM, Demonstração Prática


`LVM` - *Logical Volume Management* ou Gerenciamento de Volumes Lógicos, é uma forma de virtualização do armazenamento que oferece aos administradores de sistema um método mais flexível do que o particionamento tradicional para gerenciar o espaço em disco. O objetivo do `LVM` é facilitar a gestão das necessidades de armazenamento de seus usuários finais.

A unidade básica é o **Volume Físico** (`PV`, de *Physical Volume*), que é um dispositivo de bloco no sistema, como uma partição de disco ou uma matriz `RAID`.

Os `PV`s são agrupados em Grupos de Volumes (`VG`), que abstraem os dispositivos subjacentes e são vistos como um único dispositivo lógico, com a capacidade de armazenamento combinada dos `PV`s do componente.

Cada volume em um Grupo de Volumes é subdividido em partes de tamanho fixo chamadas extensões. As extensões em um PV são chamadas Extensões Físicas (`PE`), enquanto as do volume lógico são Extensões Lógicas (`LE`). De maneira geral, cada extensão lógica é mapeada para uma extensão física, mas isso pode mudar se forem usados recursos como o espelhamento de disco.

Os Grupos de Volumes podem ser subdivididos em Volumes Lógicos (`LV`s), com funcionalidade semelhante à das partições, mas com mais flexibilidade.

O tamanho de um Volume Lógico, conforme especificado durante a sua criação, é na verdade definido pelo tamanho das extensões físicas (por padrão, `4 MB`) multiplicado pelo número de extensões no volume. Com isso, é fácil entender que para aumentar um Volume Lógico, por exemplo, basta adicionar mais extensões do pool disponível no Grupo de Volumes. Da mesma forma, as extensões podem ser removidas para reduzir o `LV`.

Após sua criação, um Volume Lógico é visto pelo sistema operacional como um dispositivo de bloco normal. Um dispositivo será criado em `/dev`, com o nome `/dev/VGNAME/LVNAME`, em que `VGNAME` é o nome do Grupo de Volumes e `LVNAME` o nome do Volume Lógico.

Esses dispositivos podem ser formatados com o sistema de arquivos desejado usando utilitários padrão (como o `mkfs.ext4`, por exemplo) e montados com os métodos usuais, seja manualmente, com o comando mount, ou automaticamente, adicionando-os ao arquivo `/etc/fstab`.
```
/dev/meu_vg/meu_lv  /mnt/meu_lvm  ext4  defaults  0  2
```

Elementos:


- `PV` (Physical Volume): Discos físicos ou partições usadas no LVM
- `VG` (Volume Group): Agrupamento de um ou mais `PV`s, formando um "pool" de armazenamento.
- `LV` (Logical Volume): Partições lógicas dentro de um `VG`, onde os sistemas de arquivos são criados.
- `PE` (Physical Extent): Blocos de armazenamento dentro dos `PV`s, usados para alocação de espaço.
- `LE` (Logical Extent): São as unidades de armazenamento dentro de um Logical Volume (`LV`). Cada `LE` mapeia exatamente para um `PE` correspondente. Quando você cria um `LV`, ele aloca um certo número de `LE`s, que apontam para os PEs nos discos físicos.

>[!NOTE]
>
>`PE`s estão no nível físico (`PV`), enquanto `LE`s estão no nível lógico (`LV`), mas ambos têm o mesmo tamanho e se correspondem diretamente

---

#### listando os discos/partições/pontos de montagem

- `df -h`: lista as partições e pontos de montagens criados
```
$ df -h
Filesystem              Size  Used Avail Use% Mounted on
tmpfs                   1,6G  2,3M  1,6G   1% /run
efivarfs                384K  114K  266K  30% /sys/firmware/efi/efivars
/dev/nvme0n1p4          181G   13G  159G   8% /
tmpfs                   7,7G  252M  7,5G   4% /dev/shm
tmpfs                   5,0M  8,0K  5,0M   1% /run/lock
tmpfs                   7,7G     0  7,7G   0% /run/qemu
/dev/nvme0n1p2          441M  380M   27M  94% /boot
/dev/nvme0n1p3          272G   74G  185G  29% /home
/dev/nvme0n1p1          487M  6,2M  480M   2% /boot/efi
tmpfs                   1,6G  2,6M  1,6G   1% /run/user/1000
/home/rodrigo/.Private  272G   74G  185G  29% /home/rodrigo
```
>[!NOTE]
>
> repare que não mostra a partição de swap, use `cat /proc/swaps` para vê-la
```
$ cat /proc/swaps 
Filename				Type		Size		Used		Priority
/dev/nvme0n1p5                          partition	15999996	4473856		-2         
```

- `fdisk -l`: lista as partições (`fdisk` precisa ser executado como `root`)

>[!NOTE]
>
>`fdisk` é muito utilizado para criar/alterar/excluir partições no sistema. Mais detalhes [aqui](#fdisk)

---

#### UEFI e ESP

Em sistemas com hardware mais modernos, que utilizam `UEFI` (*Unified Extensible Firmware Interface*), podemos ver com o comando `df -T` ou `--print-type` que temos um ponto de montagem chamado `/boot/efi`

Essa partição é formatada em um sistema de arquivos baseado em `FAT`. Em um disco particionado com uma tabela de partição `GUID`, ela possui o identificador global único `C12A7328-F81F-11D2-BA4B-00A0C93EC93B`. Se o disco tiver sido formatado no esquema de particionamento do `MBR`, o ID da partição será `0xEF`.

Em máquinas com Microsoft Windows, essa partição geralmente é a primeira no disco, embora isso não seja obrigatório. O `ESP` é criado (ou preenchido) pelo sistema operacional após a instalação e, em um sistema Linux, é montado em `/boot/efi`.

Acessando esse diretório, notamos que se trata do gerenciamento do `EFI`, e se tiver um `dualboot` instalado, ele irá aparecer aqui os sistemas instalados em `dualboot`.
```
# ls -l /boot/efi/EFI
total 3
drwx------ 2 root root 1024 Jan 1 2024 Boot
drwx------ 4 root root 1024 Jan 1 2024 Microsoft
drwx------ 2 root root 1024 Jan 1 2024 ubuntu
```

Com o comando `efibootmgr`, é listado as configurações atuais do `EFI`, assim como o boot padrão (`BootCurrent`), e também a ordem de boot (`BootOrder`). O comando `efibootmge -v` traz ainda mais detalhes.
```
# efibootmgr
BootCurrent: 0000
Timeout: 0 seconds
BootOrder: 0000,0001
Boot0000* ubuntu
Boot0001* Windows Boot Manager
```

```
# efibootmgr  -v
BootCurrent: 0000
Timeout: 0 seconds
BootOrder: 0000,0001
Boot0000* ubuntu HD(1,GPT,e0e24ace-2852-45f3-a0b7-e7a3669978f9,0x800,0x32000)/File(\EFI\ubuntu\shimx64.efi)
Boot0001* Windows Boot Manager HD(1,GPT,e0e24ace-2852-45f3-a0b7-e7a3669978f9,0x800,0x32000)/File(\EFI\Microsoft\Boot\bootmgfw.efi)WINDOWS.........x...B.C.D.O.B.J.E.C.T.=.{.9.d.e.a.8.6.2.c.-.5.c.d.d.-.4.e.7.0.-.a.c.c.1.-.f.3.2.b.3.4.4.d.4.7.9.5.}...0................
```

Ainda com o `fdisk -l` ou `--list` (como `root`), é mostrado o `Disklabel type`, que pode ser `dos` (`mbr`) ou `gpt`

---

### 102.2 Instalar um gerenciador de inicialização (Grub Legacy e Grub 2)

`GRUB` - Grand Unified Boot Loader

Temos o `Grub Legacy` e o `Grub 2`


|   | **GRUB LEGACY** | **GRUB 2** |
|---|---|---|
| **Arquivos de configuração** | `/boot/grub/menu.lst` (principal)<br>`/boot/grub/grub.conf/cfg` | `/boot/grub/grub.cfg`<br>`/etc/default/grub` (opções gerais)<br>`/etc/grub.d/` (opções separadas) |
| **Referência ao disco** | `hda1`=`hd0,0`<br>`hda5`=`hd0,4`<br>`hdb3`=`hd1,2`  | `hda1`=`hd0,1` ou `hd0`,`msdos1`<br>`hda5`=`hd0,5`<br>`hdb3`=`hd1,3` |
| **Comandos** | `# grub-install /dev/sda`<br><code># grub-install '(hd0)'</code> | `# grub-install <device>`<br>`# update-grub`<br>`# grub-mkconfig -o /boot/grub/grub.cfg`<br> |
| **Principais parâmetros** | <code>title "Ubuntu"<br>&nbsp;&nbsp;root (hd0,0)<br>&nbsp;&nbsp;kernel /boot/vmlinuz-4-8.0-generic ro root=/dev/sda5 mem=4096<br>&nbsp;&nbsp;initrd /boot/initrd-4-8.0-generic<br><br>defaul=0<br>Timeout=15<code> | <code>menuentry "Ubuntu" {<br>&nbsp;&nbsp;set root=(hd0,1)<br>&nbsp;&nbsp;linux /boot/vmlinuz-4-8.0-generic ro root=/dev/sda5 mem=4096<br>&nbsp;&nbsp;initrd /boot/initrd-4-8.0-generic<br>}<br><br>GRUB_DEFAULT=0<br>GRUB_TIMEOUT=15</code>  |

Resumidamente, temos que, arquivos de configuração
- `GRUB LEGACY`:
  1. `/boot/grub/menu.lst` (principal, alterações são feitas aqui) e
  2. `/boot/grub/grub.conf/cfg`

- `GRUB 2`:
  1. `/boot/grub/grub.cfg`
  2. `/etc/default/grub`: configurações gerais do `GRUB 2` (voltado para usuários administradores)
  3. `/etc/grub.d/`: configurações mais específicas do `GRUB 2` (voltado para usuários administradores)

>[!IMPORTANT]
>
>No `GRUB 2`, o que for mudado no arquivo `/etc/default/grub` ou em `/etc/grub.d`, vai ser gerado/modificado o `grub.cfg` (`/boot/grub/grub.cfg`), que é o que o bootloader irá usar efetivamente. (lembrar **SEMPRE** que para efetivar as alterações, precisa rodar o comando `# update-grub`)

---

#### Referencia ao disco

Usado muito para indicar ao bootloader onde é a partição `/boot`

---

#### `GRUB LEGACY`

  - `hda1` = `hd0,0` (no linux é mapeado como `hda`, no `GRUB LEGACY`, é `hd0`, seguido da partição, no caso, primeira partição)
  - `hda5` = `hd0,4` (disco 1, partição 5 - no linux começa em 1), (no grup como começa em 0 as partições, será sempre a do linux menos 1)
  - `hdb3` = `hd1,2` (disco 2, pois é `hdb`, e no `GRUB LEGACY` aparece o disco 2 como sendo 1, pois começa no 0)
  
---

#### `GRUB 2`

- `hda1` = `hd0,1` (aqui é semelhante, mas no `GRUB 2`, as partições começam no 1, **só as partições**, pois os discos começam em **0**)

>[!NOTE]
>
>Podemos ter também o padrão: `hda1` = `hd0`,`msdos1` (que indica disco 1, partição 1 do tipo `MBR`, que poderia ser `gpt1`). `MBR` faz referência a `msdos`.

Mais exemplos:

- `hda5` = `hd0,5` (disco 1, partição 5)
- `hdb3` = `hd1,3` (disco 2, partição 3)

---

#### Comandos

#### GRUB LEGACY:

- `grub-install /dev/sda`: instala o bootloader na MBR (nos primeiros 512 bytes do disco)
- `grub-install '(hd0)'`: faz igual ao `grub-install /dev/sda`

>[!NOTE]
>
>Se alterarmos `/boot/grub/menu.lst`, não precisa fazer um `grub-install`, o grub irá fazer a leitura ao arquivo normalmente.

---

#### GRUB 2

- `grub-install <device>`: faz o mesmo que o grub-install do GRUB LEGACY
- `update-grub`: pega o que foi configurado em `/etc/default/grub` e `/etc/grub.d/` e gera o `/boot/grub/grub.cfg`, para que o `grub-install` possa pegar o que foi configurado
- `grub-mkconfig -o`: faz igual ao `update-grub`

>[!TIP]
>
>O GRUB 2 pode ser instalado usando o utilitário `grub-install`. Se seu sistema se recusa a inicializar, você precisará inicializá-lo usando um Live CD ou um disco de recuperação, descobrir qual é a partição de inicialização do seu sistema, montá-la e executar o utilitário (como super usuário).

---

#### Principais parâmetros

#### GRUB LEGACY:
```
title "Ubuntu"
  root(hd0,0)
  kernel /boot/vmlinuz-4-8.0-46-generic ro root=/dev/sda5 mem=4096M
  initrd /boot/initrd-4-8.0-46-generic
  default=0
  Timeout=15
```
 
 ---

#### GRUB 2:
```
menuentry "Ubuntu" {
  set root=(hd0,0)
  linux /boot/vmlinuz-4-8.0-46-generic ro root=/dev/sda5 mem=4096M
  initrd /boot/initrd-4-8.0-46-generic
}

  GRUB_DEFAULT=0
  GRUB_TIMEOUT=15
```

** timeout de **0**, não exibe o menu

**timeout de **-1**, o sistema aguardará o tempo que for necessário.

---

#### Conteúdo da partição de inicialização

O conteúdo da partição `/boot` pode variar de acordo com a arquitetura do sistema ou o gerenciador de inicialização usado, mas em um sistema baseado em x86 geralmente encontramos os arquivos abaixo. A maioria deles recebe o sufixo `-versão`, onde `-versão` é a versão correspondente do kernel do Linux. Assim, por exemplo, o arquivo de configuração para a versão do kernel do Linux `4.15.0-65-generic` seria chamado de `config-4.15.0-65-generic`.

- `Arquivo de configuração`: este arquivo, geralmente chamado `config-VERSION` (veja o exemplo acima), armazena parâmetros de configuração para o kernel do Linux. Este arquivo é gerado automaticamente quando um novo kernel é compilado ou instalado e não deve ser diretamente modificado pelo usuário.
- `Mapa do sistema`: este arquivo é uma tabela de consulta que articula nomes de símbolos (como variáveis ou funções) com sua posição correspondente na memória. Isso é útil ao se corrigir um tipo de falha do sistema conhecida como kernel panic (pânico do kernel), pois permite ao usuário saber qual variável ou função estava sendo chamada quando ocorreu a falha. Como no caso do arquivo de configuração, o nome geralmente é `System.map-VERSION` (por exemplo, `System.map-4.15.0-65-generic`).
- `Kernel do Linux`: este é o kernel do sistema operacional propriamente dito. Seu nome é geralmente `vmlinux-VERSION` (por exemplo, `vmlinux-4.15.0-65-generic`). Também se pode encontrar o nome vmlinuz em vez de `vmlinux` - o `z` no final indica que o arquivo foi **compactado**.
- `Disco RAM inicial`: geralmente se chama `initrd.img-VERSION` e contém um sistema de arquivos raiz mínimo carregado em um disco RAM, contendo os utilitários e módulos de kernel necessários para que o kernel possa montar o sistema de arquivos raiz real.
- `Arquivos relacionados ao gerenciador de inicialização`: em sistemas com o GRUB instalado, eles costumam estar localizados em `/boot/grub` e incluem o arquivo de configuração (`/boot/grub/grub.cfg` para o GRUB 2 ou `/boot/grub/menu.lst` no caso do GRUB Legacy), módulos (em `/boot/grub/i386-pc`), arquivos de tradução (em `/boot/grub/locale`) e fontes (em `/boot/grub/fonts`) do GRUB.

---

#### Instalando o GRUB 2

O GRUB 2 pode ser instalado usando o utilitário `grub-install`. Se seu sistema se recusa a inicializar, você precisará inicializá-lo usando um Live CD ou um disco de recuperação, descobrir qual é a partição de inicialização do seu sistema, montá-la e executar o utilitário.

>[!NOTE]
>
>Para usar os comandos abaixo, é preciso estar logado como root. Se não for o caso, execute primeiro `sudo su -` para executar como `root`. No final, digite `exit` para se deslogar e voltar a ser um usuário comum.

O primeiro disco de um sistema é geralmente o dispositivo de inicialização . Pode ser necessário saber se existe uma partição de inicialização no disco. Para isso existe o utilitário `fdisk`. Para listar todas as partições no primeiro disco da sua máquina, use:
```
# fdisk -l /dev/sda
Disk /dev/sda: 111,8 GiB, 120034123776 bytes, 234441648 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x97f8fef5

Device     Boot    Start       End   Sectors   Size Id Type
/dev/sda1  *        2048   2000895   1998848   976M 83 Linux
/dev/sda2        2002942 234440703 232437762 110,9G  5 Extended
/dev/sda5        2002944  18008063  16005120   7,6G 82 Linux swap / Solaris
/dev/sda6       18010112 234440703 216430592 103,2G 83 Linux
```
A partição de inicialização é identificada com o `*` na coluna boot. No exemplo acima, ela é `/dev/sda1`

A seguir, crie um diretório temporário em `/mnt` e monte a partição nele:
```
# mkdir /mnt/tmp
# mount /dev/sda1 /mnt/tmp
```

Depois execute `grub-install`, apontando-o para o dispositivo de inicialização (não a partição) e o diretório em que a partição de inicialização está montada. Se o sistema possuir uma partição de inicialização dedicada, o comando será:
```
# grub-install --boot-directory=/mnt/tmp /dev/sda
```

Caso esteja instalando em um sistema que não possui uma partição de inicialização, mas apenas um diretório `/boot` no sistema de arquivos raiz, aponte-o em `grub-install`. Nesse caso, o comando é:
```
# grub-install --boot-directory=/boot /dev/sda
```

---

#### Configurando o GRUB 2

O arquivo de configuração padrão do GRUB 2 é `/boot/grub/grub.cfg`. Esse arquivo é gerado automaticamente e não se recomenda editá-lo diretamente. Para fazer alterações na configuração do GRUB, é preciso editar o arquivo `/etc/default/grub` e depois executar o utilitário `update-grub` para gerar um arquivo compatível.

>[!NOTE]
>
>`update-grub` normalmente é um atalho para `grub-mkconfig -o /boot/grub/grub.cfg`, de modo que eles produzem os mesmos resultados.

Existem algumas opções no arquivo `/etc/default/grub` para controlar o comportamento do GRUB 2, como o kernel padrão de inicialização, tempo limite, parâmetros extras da linha de comando, etc. Os mais importantes são:
- `GRUB_DEFAULT=`: A entrada de menu padrão para a inicialização. Pode ser um valor numérico (como `0`, `1`, etc.), o nome de um item de menu (como `debian`) ou `saved`, que é usado em conjunto com `GRUB_SAVEDEFAULT=`, explicado abaixo. Lembre-se de que as entradas de menu começam com zero, de forma que a primeira é `0`, a segunda é `1` e assim por diante.
- `GRUB_SAVEDEFAULT=` Se esta opção estiver definida como `true` e `GRUB_DEFAULT=` como `saved`, a opção padrão de inicialização sempre será a última selecionada no menu de inicialização (opção que muito usual em dual boot)
- `GRUB_TIMEOUT=` O tempo limite, em segundos, para que a entrada do menu padrão seja selecionada. Se definido como `0`, o sistema inicializará a entrada padrão sem exibir um menu. Se definido como `-1`, o sistema aguardará até que o usuário selecione uma opção, não importa quanto tempo leve.
- `GRUB_CMDLINE_LINUX=` Lista as opções de linha de comando que serão adicionadas às entradas do kernel do Linux.
- `GRUB_CMDLINE_LINUX_DEFAULT=` Por padrão, duas entradas de menu são geradas para cada kernel do Linux, uma com as opções padrão e uma entrada para recuperação. Com esta opção, você pode incluir parâmetros extras que serão adicionados apenas à entrada padrão.
- `GRUB_ENABLE_CRYPTODISK=` Se definido como `y`, comandos como `grub-mkconfig`, `update-grub` e `grub-install` procuram por discos criptografados e adicionam os comandos necessários para acessá-los durante a inicialização. Assim, a inicialização automática é desabilitada (`GRUB_TIMEOUT=` com valor diferente de `-1`) porque uma senha será exigida para descriptografar os discos antes que possam ser acessados.

---

#### Administrando as entradas de menu

Quando rodamos o `update-grub`, o GRUB 2 busca por kernels e sistemas operacionais na máquina e gera as entradas de menu correspondentes no arquivo `/boot/grub/grub.cfg`. É possível adicionar novas entradas manualmente aos arquivos de script dentro do diretório `/etc/grub.d`.

Esses arquivos devem ser **executáveis** e são processados em ordem numérica pelo `update-grub`. Portanto, `05_debian_theme` é processado antes de `10_linux` e assim por diante. As entradas de menu personalizadas são geralmente adicionadas ao `arquivo 40_custom`.

A sintaxe básica de uma entrada de menu é mostrada abaixo:
```
menuentry "Default OS" {
    set root=(hd0,1)
    linux /vmlinuz root=/dev/sda1 ro quiet splash
    initrd /initrd.img
}
```

A primeira linha sempre começa com `menuentry` e termina com `{`. O texto entre aspas será mostrado como o rótulo da entrada no menu de inicialização do GRUB 2.

O parâmetro `set root` define o disco e a partição em que o sistema de arquivos raiz do sistema operacional está localizado. Note que no GRUB 2 os discos são numerados a partir de **zero**, então `hd0` é o primeiro disco (sda no Linux), `hd1` o segundo e assim por diante. As partições, por sua vez, são numeradas a partir de um. No exemplo acima, o sistema de arquivos raiz está localizado no primeiro disco (`hd0`), primeira partição (`,1`) ou `sda1`.

Em vez de especificar diretamente o dispositivo e a partição, também podemos pedir que o GRUB 2 busque por um sistema de arquivos com um rótulo ou `UUID` (*Universally Unique Identifier*) específico. Para isso, use o parâmetro `search --set=root` seguido por `--label` e o rótulo do sistema de arquivos a buscar, ou `--fs-uuid` seguido pelo `UUID` do sistema de arquivos.

Use o comando abaixo para encontrar o `UUID` de um sistema de arquivos:
```
$ ls -l /dev/disk/by-uuid/
total 0
lrwxrwxrwx 1 root root 10 nov  4 08:40 3e0b34e2-949c-43f2-90b0-25454ac1595d -> ../../sda5
lrwxrwxrwx 1 root root 10 nov  4 08:40 428e35ee-5ad5-4dcb-adca-539aba6c2d84 -> ../../sda6
lrwxrwxrwx 1 root root 10 nov  5 19:10 56C11DCC5D2E1334 -> ../../sdb1
lrwxrwxrwx 1 root root 10 nov  4 08:40 ae71b214-0aec-48e8-80b2-090b6986b625 -> ../../sda1
```

No exemplo acima, o `UUID` de `/dev/sda1` é `ae71b214-0aec-48e8-80b2-090b6986b625`. Se quisermos defini-lo como dispositivo raiz do GRUB 2, o comando seria `search --set=root --fs-uuid ae71b214-0aec-48e8-80b2-090b6986b625`.

Ao usar o comando `search`, é comum adicionar o parâmetro `--no-floppy` para que o GRUB não perca tempo buscando em disquetes

A linha `linux` indica onde está localizado o kernel do sistema operacional (neste caso, o arquivo `vmlinuz` na raiz do sistema de arquivos). Depois disso, podemos passar parâmetros na linha de comando para o kernel.

No exemplo acima, especificamos a partição root (`root=/dev/sda1`) e passamos três parâmetros do kernel: a partição root deve ser montada com acesso apenas de leitura (`ro`), a maioria das mensagens de log deve ser desabilitada (`quiet`) e uma tela de boas-vindas deve ser exibida (`splash`).

A linha `initrd` indica onde está localizado o disco de RAM inicial. No exemplo acima, o arquivo é `initrd.img`, localizado na raiz do sistema de arquivos.

>[!NOTE]
>
>A maioria das distribuições Linux não coloca de fato o `kernel` e o `initrd` no diretório raiz do sistema de arquivos raiz. Em vez disso, esses são links para os arquivos reais dentro do diretório ou partição `/boot`.

A última linha de uma entrada do menu deve conter apenas o caractere `}`.

---

#### interagindo com o GRUB 2

Ao inicializar um sistema com o GRUB 2 aparece um menu de opções. Use as setas do teclado para selecionar uma opção e `Enter` para confirmar e inicializar a entrada selecionada.

>[!TIP]
>
>Se você vir apenas uma contagem regressiva, mas não um menu, pressione `Shift` para exibir o menu.

Para editar uma opção, selecione-a com as setas e pressione `E`. Será exibida uma janela de editor com o conteúdo da `menuentry` associada àquela opção, conforme definido em `/boot/grub/grub.cfg`.

```
linux /boot/vmlinuz-4-8.0-46-generic root=UUID=f4490b0-b595-9315-d23137bc384 ro quiet splash
```
Podemos remover `quiet` e `splash` para iniciar o sistema vendo as mensagens (o que pode ser obtido com o comando `dmesg`)

Podemos ainda começar em um `runlevel` diferente. Supõe que queremos iniciar no `runlevel 1` (`single user` - manutenção), adicionamos `single` depois do `splash`, ou colocar `init=/bin/bash`, que indica o mesmo que `single`.
```
...d23137bc384 ro quiet splash single
...d23137bc384 ro quiet splash init=/bin/bash
```

Depois de editar uma opção, digite `Ctrl+X` ou `F10` para inicializar, ou ainda `Esc` para retornar ao menu.

Para entrar no shell do GRUB 2, pressione `C` na tela do menu (ou `Ctrl+C`) na janela de edição. Aparecerá um prompt de comando como este: `grub >`

Digite `help` para ver uma lista de todos os comandos disponíveis ou pressione `Esc` para sair do shell e retornar à tela do menu.

>[!NOTE]
>
>Lembre-se de que esse menu não aparecerá se `GRUB_TIMEOUT` estiver definido com `0` em `/etc/default/grub`.

#### Inicialização a partir do shell do GRUB 2

Podemos usar o shell do GRUB 2 para inicializar o sistema caso uma configuração incorreta em uma entrada de menu cause uma falha de inicialização.

A primeira coisa que você deve fazer é descobrir onde está a partição de inicialização. Use para isso o comando `ls`, que mostra uma lista das partições e discos encontrados pelo GRUB 2.
```
grub> ls
(proc) (hd0) (hd0,msdos1)
```

No exemplo acima, tudo é simples. Existe apenas um disco (`hd0`), com apenas uma partição: (`hd0,msdos1`).

Os discos e partições listados serão diferentes no seu sistema. Em nosso exemplo, a primeira partição do `hd0` é chamada `msdos1` porque o disco foi particionado usando o esquema de particionamento `MBR`. Se ele fosse particionado usando `GPT`, o nome seria `gpt1`.

Para inicializar o Linux, precisamos de um kernel e de um disco RAM inicial (`initrd`). Vamos verificar o conteúdo de (`hd0,msdos1`):
```
grub> ls (hd0,msdos1)/
lost+found/ swapfile etc/ media/ bin/ boot/ dev/ home/ lib/ lib64/ mnt/ opt/ proc/ root/ run/ sbin/ srv/ sys/ tmp/ usr/ var/ initrd.img initrd.img.old vmlinuz cdrom/
```

Podemos adicionar o parâmetro `-l` a `ls` para obter uma lista longa, como faríamos em um terminal Linux. Use `Tab` para completar automaticamente os nomes de discos, partições e arquivos.

Note que temos as imagens do kernel (`vmlinuz`) e `initrd` (`initrd.img`) bem no diretório raiz. Se não, poderíamos conferir o conteúdo de `/boot` com `list (hd0,msdos1)/boot/`.

Agora, defina a partição de inicialização:
```
grub> set root=(hd0,msdos1)
```
Carregue o kernel do Linux com o comando linux, seguido pelo caminho para o kernel e pela opção `root=` para informar ao kernel onde está localizado o sistema de arquivos raiz do sistema operacional.
```
grub> linux /vmlinuz root=/dev/sda1
```

Carregue o disco RAM inicial com initrd, seguido pelo caminho completo para o arquivo initrd.img:
```
grub> initrd /initrd.img
```

Agora, inicialize o sistema com `boot`.

---

#### Inicializando com o shell de resgate

No caso de uma falha na inicialização, o GRUB 2 pode carregar um shell de resgate, uma versão simplificada do shell que mencionamos anteriormente. Você o reconhecerá pelo prompt de comando, que é exibido como `grub rescue>`.

O processo para inicializar um sistema a partir deste shell é quase idêntico ao mostrado anteriormente. No entanto, será preciso carregar alguns módulos do GRUB 2 para fazer as coisas funcionarem.

Depois de descobrir qual é a partição de inicialização (com `ls`, como mostrado anteriormente), use o comando `set prefix=`, seguido pelo caminho completo para o diretório que contém os arquivos do GRUB 2 - geralmente `/boot/grub`. No nosso exemplo:
```
grub rescue> set prefix=(hd0,msdos1)/boot/grub
```

Em seguida, carregue os módulos `normal` e `linux` com o comando insmod:
```
grub rescue> insmod normal
grub rescue> insmod linux
```

A seguir, defina a partição de inicialização com `set root=` como ensinado anteriormente, carregue o kernel do linux (com `linux`), o disco RAM inicial (`initrd`) e tente inicializar com `boot`.

---

#### GRUB Legacy

#### Instalando o GRUB Legacy a partir de um sistema em execução

Para instalar o GRUB Legacy em um disco a partir de um sistema em execução, empregaremos o utilitário `grub-install`. O comando básico é `grub-install DEVICE`, onde `DEVICE` é o disco no qual você deseja instalar o GRUB Legacy. Um exemplo seria `/dev/sda`.
```
# grub-install /dev/sda
```

>[!IMPORTANT]
>
>Note que é preciso especificar o **dispositivo** no qual o GRUB Legacy será instalado, como `/dev/sda/`, não a partição como em `/dev/sda1`.

Por padrão, o GRUB copia os arquivos necessários para o diretório `/boot` no dispositivo especificado. Se você deseja copiá-los para outro diretório, use o parâmetro `--boot-directory=` seguido pelo caminho completo para o local onde os arquivos devem ser copiados.

#### Instalando o GRUB Legacy a partir de um shell do GRUB

Se você não conseguir inicializar o sistema por algum motivo e precisar reinstalar o GRUB Legacy, poderá fazê-lo no shell do GRUB em um disco de inicialização do GRUB Legacy.

No shell do GRUB (digite `c` no menu de inicialização para acessar o prompt `grub>`), o primeiro passo é configurar o dispositivo de inicialização, que contém o diretório `/boot`. Por exemplo, se esse diretório estiver na primeira partição do primeiro disco, o comando seria:
```
grub> root (hd0,0)
```

Se você não souber qual dispositivo contém o diretório `/boot`, peça ao GRUB para procurá-lo com o comando `find`, como abaixo:
```
grub> find /boot/grub/stage1
 (hd0,0)
```

Em seguida, defina a partição de inicialização conforme as instruções acima e use o comando setup para instalar o GRUB Legacy no MBR e copiar os arquivos necessários no disco:
```
grub> setup (hd0)
```

Ao final, reinicie o sistema e ele deverá inicializar normalmente.

---

### Definindo entradas e configurações do menu do GRUB Legacy

As entradas de menu e configurações do GRUB Legacy são armazenadas no arquivo `/boot/grub/menu.lst`. Trata-se de uma lista de comandos e parâmetros em um arquivo de texto simples, que pode ser editado diretamente em seu editor de texto predileto.

As linhas que começam com `#` são consideradas comentários e as linhas em branco são ignoradas.

Uma entrada de menu possui ao menos três comandos. O primeiro, `title`, define o título do sistema operacional na tela do menu. O segundo, `root`, informa ao GRUB Legacy qual o dispositivo ou partição de inicialização.

A terceira entrada, `kernel`, especifica o caminho completo para a imagem do kernel que deve ser carregada quando a entrada correspondente for selecionada. Observe que esse caminho é relativo ao dispositivo especificado no parâmetro `root`.

Veja um exemplo simples a seguir:
```
# This line is a comment
title My Linux Distribution
root (hd0,0)
kernel /vmlinuz root=/dev/hda1
```

Ao contrário do GRUB 2, no GRUB Legacy tanto as partições quanto os discos são numerados a partir de `zero`. Portanto, o comando `root (hd0,0)` define a partição de inicialização como a primeira partição (`0`) do primeiro disco (`hd0`).

Podemos omitir a instrução root se especificarmos o dispositivo de inicialização antes do caminho no comando kernel. A sintaxe é a mesma, portanto:
```
kernel (hd0,0)/vmlinuz root=dev/hda1
```

equivale a:
```
root (hd0,0)
kernel /vmlinuz root=/dev/hda1
```

Ambos carregam o arquivo vmlinuz a partir do diretório root (`/`) da primeira partição do primeiro disco (`hd0,0`).

O parâmetro `root=/dev/hda1` após o comando kernel informa ao kernel do Linux qual partição deve ser usada como sistema de arquivos raiz. Este é um parâmetro do kernel do Linux, não um comando do GRUB Legacy.

>[!NOTE]
>
>Para saber mais sobre os parâmetros do kernel, visite [https://www.kernel.org/doc/html/v4.14/admin-guide/kernel-parameters.html](https://www.kernel.org/doc/html/v4.14/admin-guide/kernel-parameters.html).

Pode ser necessário especificar o local da imagem inicial do disco RAM para o sistema operacional com o parâmetro `initrd`. O caminho completo para o arquivo pode ser especificado como no parâmetro `kernel`, mas também é possível especificar um dispositivo ou partição antes do caminho, como por exemplo:
```
# This line is a comment
title My Linux Distribution
root (hd0,0)
kernel /vmlinuz root=/dev/hda1
initrd /initrd.img
```

O GRUB Legacy tem um design modular, no qual módulos (geralmente armazenados como arquivos `.mod` em `/boot/grub/i386-pc`) podem ser carregados para adicionar recursos extras, como suporte a hardware incomum, sistemas de arquivos ou novos algoritmos de compactação.

Os módulos são carregados usando o comando `module`, seguido pelo caminho completo para o arquivo `.mod` correspondente. Lembre-se de que, como no caso dos kernels e imagens initrd, esse caminho é relativo ao dispositivo especificado no comando `root`.

O exemplo abaixo carrega o módulo `915resolution`, necessário para definir corretamente a resolução da memória de imagens (frame buffer) em sistemas com chipsets de vídeo das séries Intel 800 ou 900.
```
module /boot/grub/i386-pc/915resolution.mod
```

---

#### Carregamento em cadeia de outros sistemas operacionais

O GRUB Legacy pode ser usado para carregar sistemas operacionais não suportados, como o Windows, usando um processo chamado de **carregamento em cadeia** (*chainloading*). O GRUB Legacy é carregado primeiro e, quando a opção correspondente é selecionada, o gerenciador de inicialização do sistema desejado é carregado.

Uma entrada típica para o carregamento em cadeia do Windows seria semelhante a esta:
```
# Load Windows
title Windows XP
root (hd0,1)
makeactive
chainload +1
boot
```

Vamos esclarecer cada parâmetro. Como anteriormente, `root (hd0,1)` especifica o dispositivo e a partição em que o gerenciador de inicialização do sistema operacional que queremos carregar está localizado. Neste exemplo, a segunda partição do primeiro disco.
- `makeactive`: define um sinalizador indicando que esta é uma partição ativa. Funciona apenas em partições primárias do DOS.
- `chainload +1`: diz ao GRUB para carregar o primeiro setor da partição de inicialização. É nela que costumam ficar os gerenciadores de inicialização.
- `boot`: executa o gerenciador de inicialização e carrega o sistema operacional correspondente.

#### Exercícios interessantes no site lpi.org

1. Qual é o local padrão do arquivo de configuração do GRUB 2?
```
/boot/grub/grub.cfg
```

2. Quais são as etapas necessárias para alterar as configurações do GRUB 2?

Efetuar as alterações no arquivo `/etc/default/grub`, depois atualizar a configuração com `update-grub`.

3. Em qual arquivo devem ser adicionadas as entradas de menu personalizadas do GRUB 2?
```
/etc/grub.d/40_custom
```

4. Onde são armazenadas as entradas de menu do GRUB Legacy?
```
/boot/grub/menu.lst
```

5. Imagine um usuário configurando o GRUB Legacy para inicializar a partir da segunda partição do primeiro disco. Ele escreve a seguinte entrada de menu personalizada:
```
title My Linux Distro
root (hd0,2)
kernel /vmlinuz root=/dev/hda1
initrd /initrd.img
```

No entanto, o sistema não inicializa. O que está errado?

**Resposta**: A partição de inicialização está incorreta. Lembre-se de que, ao contrário do GRUB 2, o GRUB Legacy conta as partições a partir de zero. Portanto, o comando correto para a segunda partição do primeiro disco seria `root (hd0,1)`.

6. Qual o comando para descobrir o UUID de uma partição?
```
ls -la /dev/disk/by-uuid/
```

7. Considere a seguinte entrada para o GRUB 2
```
menuentry "Default OS" {
    set root=(hd0,1)
    linux /vmlinuz root=/dev/sda1 ro quiet splash
    initrd /initrd.img
}
```

Altere-a para que o sistema inicialize a partir de um disco com o `UUID` `5dda0af3-c995-481a-a6f3-46dcd3b6998d`

**Resposta**: Será preciso alterar a declaração `set root`. Em vez de especificar um disco e uma partição, diga ao GRUB para buscar pela partição com o UUID desejado.
```
menuentry "Default OS" {
    search --set=root --fs-uuid 5dda0af3-c995-481a-a6f3-46dcd3b6998d
    linux /vmlinuz root=/dev/sda1 ro quiet splash
    initrd /initrd.img
}
```

8. Em um shell do GRUB Legacy, quais são os comandos para instalar o GRUB na primeira partição do segundo disco?
```
grub> root (hd1,0)
grub> setup (hd1)
```

---

### 102.3 Gerenciar bibliotecas compartilhadas

#### Biblioteca ESTÁTICA

A biblioteca utilizada na aplicação é incorporado/mesclada ao código da aplicação, ficando um programa maior e mais pesado. Se outra aplicação for desenvolvida da mesma forma, será mais um código incorporado junto ao programa. Se houver mudanças na biblioteca, é necessário recompilar a aplicação.<br>**Vantagem**: não precisamos nos preocupar em garantir que as bibliotecas usadas estejam sempre disponíveis.<br>**Desvantagem**: programa vinculados estaticamente são mais pesados.

---

#### Biblioteca DINÂMICA (Compartilhada ou objetos compartilhados)

Várias aplicações utilizam uma mesma biblioteca, a qual não está estaticamente incorporada à aplicação. A aplicação fica menor e mais leve. Se houver mudanças na biblioteca, não é necessário recompilar. Performance costuma ser melhor. Apenas uma cópia da biblioteca é carregada na memória, mesmo quando ela é usada por vários programas

---

#### Comando ldd (print shared object dependencies)

`ldd` mostra quais bibliotecas são utilizadas por determinada aplicação

Vamos pegar como exemplo o `vi`:

Digitamos `whereis vi`, para achar onde está o programa `vi`
```
$ whereis vi
vi: /usr/bin/vi /usr/share/man/man1/vi.1.gz
```

- `ldd /usr/bin/vi`: imprime todas as dependências (bibliotecas compartilhadas, geralmente tudo que tem o `.so` - vem de `shared object`) que o `vi` utiliza, imprime também o endereço de memória hexadecimal que ele é carregado
```
$ ldd /usr/bin/vi
	linux-vdso.so.1 (0x00007ffeef1d4000)
	libm.so.6 => /lib/x86_64-linux-gnu/libm.so.6 (0x00007c648986a000)
	libtinfo.so.6 => /lib/x86_64-linux-gnu/libtinfo.so.6 (0x00007c6489836000)
	libselinux.so.1 => /lib/x86_64-linux-gnu/libselinux.so.1 (0x00007c6489809000)
	libsodium.so.23 => /lib/x86_64-linux-gnu/libsodium.so.23 (0x00007c64893a9000)
	libacl.so.1 => /lib/x86_64-linux-gnu/libacl.so.1 (0x00007c64897ff000)
	libgpm.so.2 => /lib/x86_64-linux-gnu/libgpm.so.2 (0x00007c648939f000)
	libpython3.12.so.1.0 => /lib/x86_64-linux-gnu/libpython3.12.so.1.0 (0x00007c6488a00000)
	libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007c6488600000)
	/lib64/ld-linux-x86-64.so.2 (0x00007c6489968000)
	libpcre2-8.so.0 => /lib/x86_64-linux-gnu/libpcre2-8.so.0 (0x00007c6489305000)
	libz.so.1 => /lib/x86_64-linux-gnu/libz.so.1 (0x00007c64892e9000)
	libexpat.so.1 => /lib/x86_64-linux-gnu/libexpat.so.1 (0x00007c64892bc000)
```

- `ldd -v /usr/bin/vi`: uso com `-v` ou `--verbose` traz mais informações

Essa informação impressa geralmente são mapeamentos do que o programa precisa e caminho no sistema.

Ex. `libm.so.6` está mapeado em `/lib/x86_64-linux-gnu/libm.so.6`

Logo, o `vi` informa que precisa de `libm.so.6` (apenas por nome) e o sistema manda para `/lib/x86_64-linux-gnu/libm.so.6` (que é uma aplicação interna do linux)

O programa que faz esse vínculo é o `ld.so` ( ou `ld-linux.so`), que busca em **2** diretórios: `/lib` e `/usr/lib`. No entanto é possível configurar o `ld.so` para que encontre `lib` em outros locais.

Esse mapeamento fica no arquivo `/etc/ld.so.cache`. Executando `ls -ld /etc/ld.so*`, mostramos três arquivos relacionados a esse mapeamento:
```
$ ls -ld /etc/ld.so*
-rw-r--r-- 1 root root 75791 Nov 22 22:56 /etc/ld.so.cache
-rw-r--r-- 1 root root    34 Aug  2  2022 /etc/ld.so.conf
drwxr-xr-x 2 root root  4096 Nov  8 16:39 /etc/ld.so.conf.d
```

É por meio do arquivo `/etc/ld.so.conf`, ou criando links;arquivos separados no diretório `/etc/ld.so.conf.d` (mais indicado) que é possível indicar outros locais fora o padrão.
```
ls -ltr /etc/ld.so.conf.d
total 8
-rw-r--r-- 1 root root 44 Jan 27 2020 libc.conf
-rw-r--r-- 1 root root 44 Abr 26 2020 x86_64-linux-gnu.conf
lrwxrwxrwx 1 root 42 Mar 27 16:25 x86_64-linux-gnu_GL.conf -> /etc/alternatives/x86_64-linux-gnu_gl_conf
lrwxrwxrwx 1 root 43 Mar 27 16:25 x86_64-linux-gnu_EGL.conf -> /etc/alternatives/x86_64-linux-gnu_egl_conf
```

Se olharmos `libc.conf`, ele indica o local da `lib`
```
$ cat libc.conf
#libc default configuration
/usr/local/lib
```

Podendo ser mais de uma biblioteca:
```
$ cat x86_64-linux-gnu.conf
#Multiarch support
/lib/x86_64-linux-gnu
/usr/lib/x86_64-linux-gnu
```

A `glibc` (biblioteca GNU C) é um bom exemplo de biblioteca compartilhada. Em um sistema Debian GNU/Linux 9.9, seu arquivo se chama `libc.so.6`. Esses nomes de arquivo mais gerais normalmente são links simbólicos apontando para o arquivo real que contém uma biblioteca, cujo nome contém o número exato da versão. No caso da `glibc`, esse link simbólico é assim:
```
$ ls -l /lib/x86_64-linux-gnu/libc.so.6
lrwxrwxrwx 1 root root 12 feb  6 22:17 /lib/x86_64-linux-gnu/libc.so.6 -> libc-2.24.so
```

Essa maneira de usar nomes de arquivos mais gerais para fazer referência a arquivos de bibliotecas compartilhadas nomeados por uma versão específica é uma prática comum.

Outros exemplos de bibliotecas compartilhadas incluem `libreadline` (que permite aos usuários editar linhas de comando à medida que são digitadas e inclui suporte para os modos de edição `Emacs` e `vi`)

`libcrypt` (que contém funções relacionadas à criptografia, hash e codificação), ou `libcurl` (que é uma biblioteca multiprotocolo de transferência de arquivos). Estes são os locais comuns para bibliotecas compartilhadas em um sistema Linux:
```
/lib
/lib32
/lib64
/usr/lib
/usr/local/lib
```

>[!NOTE]
>
>O conceito de bibliotecas compartilhadas não é exclusivo do Linux. No Windows, por exemplo, elas são chamadas de `DLL`, que significa bibliotecas de vínculo dinâmico


- `ldconfig`: lê as mudanças em `/etc/ld.so.conf` e dos arquivos/links dentro de `/etc/ld.so.conf.d` e recompila (regera) o arquivo `/etc/ld.so.cache`
- `ldconfig -p` ou `--print-cache`: lista todas as bibliotecas ativas no momento
```
1165 libs found in cache `/etc/ld.so.cache'
        libzvbi.so.0 (libc6,x86-64) => /lib/x86_64-linux-gnu/libzvbi.so.0
        libzvbi-chains.so.0 (libc6,x86-64) => /lib/x86_64-linux-gnu/libzvbi-chains.so.0
        libzstd.so.1 (libc6,x86-64) => /lib/x86_64-linux-gnu/libzstd.so.1
        libzpool.so.5 (libc6,x86-64) => /lib/x86_64-linux-gnu/libzpool.so.5
        libzmq.so.5 (libc6,x86-64) => /lib/x86_64-linux-gnu/libzmq.so.5
#saída ocultada devido ao tamanho
```

Da mesma forma, usamos `ldd` para procurar as dependências de um objeto compartilhado:
```
$ ldd /lib/x86_64-linux-gnu/libc.so.6
	/lib64/ld-linux-x86-64.so.2 (0x00007fbfed578000)
	linux-vdso.so.1 (0x00007fffb7bf5000)
```

Com a opção `-u` (ou `--unused`), o `ldd` imprime as dependências diretas não utilizadas (se existirem):
```
$ ldd -u /usr/bin/git
Unused direct dependencies:
	/lib/x86_64-linux-gnu/libz.so.1
	/lib/x86_64-linux-gnu/libpthread.so.0
	/lib/x86_64-linux-gnu/librt.so.1
```

A razão para haver dependências não utilizadas está relacionada às opções usadas pelo vinculador ao criar o binário. Embora o programa não precise de uma biblioteca não utilizada, ela ainda estava vinculada e rotulada como `NEEDED` (necessária) nas informações sobre o arquivo-objeto. Para investigar isso, podemos usar comandos como `readelf` ou `objdump`.


- `objdump`: é um utilitário de linha de comando que exibe informações sobre arquivos objeto (confira se ele está instalado em seu sistema com `which objdump`)
- Use `objdump` com `-p` (ou `--private-headers`) e `grep` para: exibir as dependências de `glibc`
- `objdump -p /lib/x86_64-linux-gnu/libc.so.6 | grep NEEDED`: exibir as dependências de glibc
- `objdump -p /lib/x86_64-linux-gnu/libc.so.6 | grep SONAME`: exibir o soname de `glibc`
- `objdump -p /bin/bash | grep NEEDED`: exibir as dependências do Bash

O nome de uma biblioteca compartilhada, também chamado de `soname`, segue um padrão composto por **3** elementos:
- Nome da biblioteca (normalmente com o prefixo `lib`)
- `so` (que significa “`shared object`”, ou objeto compartilhado)
- Número de versão da biblioteca

Exemplos:
```
libunique-1.0.so.0
libacl.so.1
libgpm.so.2
libpthread.so.0
```

*Em comparação, os nomes das **bibliotecas estáticas** terminam em `.a`, por exemplo `libpthread.a`

#### Adicionar uma nova lib

Supõe que temos uma `lib` dentro de `/tmp/lib/libunique-1.0.so.0`

Podemos confirmar que essa `lib` **não** está carregada com o comando: `ldconfig -p | grep "/tmp/lib"`

Agora vamos editar o arquivo `/etc/ld.so.conf` e adicionar a seguinte linha:
```
/tmp/lib/
```

Para habilitar, digitamos `ldconfig`

Para confirmar a inclusão, repetimos o comando: `ldconfig -p | grep "/tmp/lib"`

Retorno deverá ser:
```
libunique-1.0.so.0 (libc6,x86-64) => /tmp/lib/libunique-1.0.so.0
```

Verifique com `ls -l /etc/ld.so.cache` que ele foi atualizado recentemente, confirmando a inclusão da biblioteca.
```
ls -l /etc/ld.so.cache 
-rw-r--r-- 1 root root 75791 Nov 22 22:56 /etc/ld.so.cache
```

>[!NOTE]
>
>Poderíamos também realizar a inclusão da `lib` criando um arquivo `.conf` em `/etc/ld.conf.d` e listando os diretório que queremos dentro desse arquivo.

#### bibliotecas como usuário comum

As formas vistas até agora para adicionar bibliotecas são por meio do usuário `root`.

O usuário comum, durante sua sessão de login, pode incluir as bibliotecas necessárias para seu uso por meio da manipulação da variável de ambiente `LD_LIBRARY_PATH`

>[!IMPORTANT]
>
>Lembrando que isso é algo **temporário** (até o logout de sua sessão), usado quando o usuário não tem acesso ao ro`ot.

**Modo de uso**: (considerando que a `lib` está em `/tmp/lib`)

- `export LD_LIBRARY_PATH=/tmp/lib`: (adicionar `/tmp/lib` ao caminho da biblioteca na sessão atual do shell e exportá-lo para todos os processos secundários originados desse shell)

Podemos confirmar com o comando: `env|grep LIBRARY`

Para remover a variável de ambiente `LD_LIBRARY_PATH`, basta digitar:
```
$ unset LD_LIBRARY_PATH
```

Se quiser tornar as alterações permanentes, escrevemos a linha abaixo Eem um dos scripts de inicialização do Bash, como `/etc/bash.bashrc` ou `~/.bashrc`:
```
export LD_LIBRARY_PATH=/tmp/lib
```

>[!NOTE]
>
>`LD_LIBRARY_PATH` está para as bibliotecas compartilhadas como `PATH` está para os executáveis. Assim, cada biblioteca deve ser separada por `:` (como em `PATH`)

>[!TIP]
>
>A inclusão do caminho até a biblioteca deve ser feito usando caminho absoluto

---

### 102.4 Como usar o gerenciamento de pacotes do Debian

|  | **Padrão Debian** | **Padrão RPM/RedHat** |
|--|--|--|
| Arquivos | .deb | .rpm |
| Gerenciador de Pacotes | # dpkg | # rpm |
| Gerenciador +<br>Repositório | # apt-get | # yum |
| Outros comandos | # dpkg-reconfigure<br># apt-cache<br># dselect<br># aptitude<br># alien | # yumdownloader<br># rpm2cpio |
| Nome do arquvo | name_version.revision-debiancodename_architecture.deb<br>**samba_3.6.6-6+deb7u12_i386.deb** | name-version-release.arch.rpm<br>**samba-4.1.12-2.1.x86_64.rpm** |

Resumidamente temos que:

- `.deb`: padrão Debian
- `.rpm`: (RPM Package Manager): padrão RedHat
- `dpkg`: gerenciador de pacotes Debian
- `rpm`: gerenciador de pacotes RedHat
- `apt-get`: gerenciador de pacotes Debian + resolução de dependências
- `yum` (YellowDog Updater Modified): gerenciador de pacotes RedHat + resolução de dependências

---

#### Comandos acessórios:

**Debian**:

- `dpkg-reconfigure`
- `apt-cache`
- `dselect`
- `aptitude`
- `alien`

**RedHat**:

- `yumdownloader`
- `rpm2cpio`

---

#### Padrão nomes arquivos

**Debian**:

name_version.revision-debiancodename_architecture.deb

Ex. samba_3.6.6-6+deb7u12_i386.deb

**RedHat**:

name-version-release.arch.rpm

Ex. samba-4.1.12-2.1.x86_64.rpm

>[!IMPORTANT]
>
>É muito importante utilizar apenas um gerenciador de pacotes por sistemas, pois os gerenciadores de pacotes mantém uma base dados relacionado aos pacotes, arquivos e dependências (pois é possível instalar tanto o `apt-get` como `yum`, mas não é recomendado).

A instalação utilizando um gerenciador de pacotes (como `apt-get` e `yum`) resolvem as dependências que o programa necessite, no entanto o `dpkg` ou o `rpm` precisa resolver manualmente (`dpkg` e `rpm` apenas se preocupam em instalar o pacote que está sendo especificado).

Um pacote é um conjunto de arquivos relacionados a uma aplicação: executáveis, cfgs, bibliotecas, manuais, etc, além de informações sobre dependências (O arquivo `.deb` nada mais é que uma compactação. Dentro do pacote temos também um **checksum**, para verificar a integridade do pacote.)

---

#### comandos

- `DPKG`: instala a partir do .deb
- `dpkg -l` ou `--list`: lista pacotes instalados
- `dpkg --get-selections`: mesmo que o comando anterior
- `dpkg -l bash`: mostra informações do pacote `bash` (buscado Banco de Dados do gerenciador de pacotes)
```
$ dpkg -l bash
Desired=Unknown/Install/Remove/Purge/Hold
| Status=Not/Inst/Conf-files/Unpacked/halF-conf/Half-inst/trig-aWait/Trig-pend
|/ Err?=(none)/Reinst-required (Status,Err: uppercase=bad)
||/ Name           Version         Architecture Description
+++-==============-===============-============-=================================
ii  bash           5.2.21-2ubuntu4 amd64        GNU Bourne Again SHell
```

- `dpkg -i pacote.deb` ou `--install`: instalar pacotes (depois de instalado pode usar `dpkg -l nome_pacote` para ver que instalou) - confirmar instalação com `dpkg -l pacote` (aqui pode ser sem o `.deb`)

>[!NOTE]
>
>As atualizações de pacotes são tratadas da mesma maneira. Antes de instalar um pacote, o `dpkg` verifica se já existe uma versão anterior no sistema. Nesse caso, o pacote será atualizado para a nova versão. Caso contrário, uma nova cópia será instalada.

>[!IMPORTANT]
>
>O `dpkg` verifica as dependências se estão instaladas em seu sistema; se não estiverem, ele não conseguirá instalar o pacote. Nesse caso, o `dpkg` lista os pacotes faltantes. No entanto, ele não pode resolver dependências sozinho. Cabe ao usuário encontrar os pacotes `.deb` com as dependências correspondentes e instalá-los.

>[!NOTE]
>
>Podemos forçar o `dpkg` a instalar ou remover um pacote, mesmo que as dependências não sejam atendidas, adicionando o parâmetro `--force` como em `dpkg -i --force PACKAGENAME`. No entanto, isso provavelmente deixará o pacote, ou mesmo o sistema, em um estado de falha. Não use `--force`, a menos que tenha certeza absoluta do que está fazendo.

- `dpkg -L bash` ou `--listfiles`: lista de arquivos que o pacote `bash` instalou e que está associado ao programa.
- `dpkg -s bash` ou `--status`: mostra o status/descrição/dependências do pacote
- `dpkg -I pacote.deb` ou `--info`: mostra informações sobre o pacote `.deb` (tamanho, versão, md5, cód. de identificação, descrição, dependências, conflitos, mantenedor, etc)
- `dpkg -c pacote.deb` ou `--contents`: lista os arquivos dentro que há dentro do pacote `.deb`
- `dpkg -S /usr/share/menu/ksh` ou `--search`: informa de qual pacote origina (por meio do source) o arquivo `ksh` informado no comando
- `dpkg -s /usr/share/menu/ksh` ou `--status`: mostra o status do pacote `ksh`
- `dpkg -r ksh` ou `--remove`: remove o pacote `ksh` (mas mantém na BD e `config-files`)
    - se rodar `dpkg -l ksh` vai mostrar o pacote na base ainda
    - inclusive se rodar `dpkg --get-selections |grep ksh`, vai mostrar na base, mas como `deinstall`

>[!NOTE]
>
>A operação de remoção também executa uma verificação de dependências. Um pacote não pode ser removido, a menos que todos os outros pacotes que dependem dele também o sejam. Se você tentar fazer isso, receberá uma mensagem de erro como a abaixo:
```
# dpkg -r p7zip
dpkg: dependency problems prevent removal of p7zip:
 winetricks depends on p7zip; however:
  Package p7zip is to be removed.
 p7zip-full depends on p7zip (= 16.02+dfsg-6).

dpkg: error processing package p7zip (--remove):
 dependency problems - not removing
Errors were encountered while processing:
 p7zip
 ```
- `dpkg -P` ou `--purge`: remove o pacote e todas as referências (não mostra mais no banco de dados e remove arquivos de configurações)
- `dpkg-query`: usado para descobrir qual pacote possui um arquivo específico no sistema:
    - `dpkg-query -S /usr/bin/unrar-nonfree`, retorna:
```
# dpkg-query -S /usr/bin/unrar-nonfree
unrar: /usr/bin/unrar-nonfree
```

**Observação**: Em `dpkg -s pacote`:

Deve-se observar o "Depends" e o "Pre-Depends" como dependências, a única diferença é que os pacotes do pre-depends são instalados e configurados pelo `apt`/`dpkg`, antes mesmo de se descompactar o pacote principal.

#### apt-cache e apt-get

O `apt-get` faz parte do pacote `APT`: *Advanced Packaging Tool*

- `apt-cache`: usado para mostrar as informações que há na base de dados do `apt`
- `apt-cache pkgnames`: lista os pacotes instalados no computador
- `apt-cache show vim`: mostra informações sobre o pacote `vim`
- `apt-cache depends vim`: mostra as dependências do pkg `vim`. Todas as dependências que o `vim` usa para funcionar.
- `apt-file`: usado para buscar arquivos dentro de pacotes
- `apt-file list unrar`: listar o conteúdo de um pacote (no caso do `unrar`)
```
# apt-file list unrar
unrar: /usr/bin/unrar-nonfree
unrar: /usr/share/doc/unrar/changelog.Debian.gz
unrar: /usr/share/doc/unrar/copyright
unrar: /usr/share/man/man1/unrar-nonfree.1.gz
```

No `apt-file list`, precisa instalar (`apt-get install apt-file`) e atualizar (`apt-file update`)

>[!NOTE]
>
>Também pode usar `apt list`

Você pode procurar um arquivo em todos os pacotes usando o parâmetro `search`, seguido pelo nome do arquivo. Por exemplo, se quisermos saber qual pacote fornece um arquivo chamado `libSDL2.so`, usaremos:
```
# apt-file search libSDL2.so
libsdl2-dev: /usr/lib/x86_64-linux-gnu/libSDL2.so
```

A resposta é o pacote `libsdl2-dev`, que fornece o arquivo `/usr/lib/x86_64-linux-gnu/libSDL2.so`.

A diferença entre `apt-file search` e `dpkg-query` é que `apt-file search` também busca por pacotes **não instalados**, ao passo que `dpkg-query` mostra somente os arquivos pertencentes a um **pacote instalado**.

- `apt-get`: consulta origem de fonte de pacotes e realiza a instalação:
    - `/etc/apt/sources.list`: contém todas as origens dos arquivos para download dos programas. Há também a opção de criar arquivos separadados `.list` dentro de `/etc/apt/sources.list.d`
- `apt-get update`: vai em cada `url` dentro de `/etc/apt/sources.list` e atualiza os pacotes adicionados, alterados, removidos, etc (**não faz download**)
- `apt-get upgrade`: verifica o que está instalado e busca por atualizações (**faz download**)
- `apt-get dist-upgrade`: faz o que o `upgrade` faz, mas verifica se há conflitos com as novas versões.
- `apt-get install zsh`: instala o pacote `zsh` e suas depedências necessárias (nesse caso é o `zsh-common`)
- `apt-get purge zsh zsh-common`: remove o `zsh` e sua dependência (`zsh-common`)
    - pode usar só `apt-get remove zsh`, mas cai na mesma situação do `dpkg -r`, que apenas remove o pacote, mas não altera na base de dados, e não exclui os arquivos de configuração.
- `apt-get remove --purge zsh`: mesmo efeito do comando anterior
- `apt-get check`: verifica se está tudo certo com o gerenciador de pacotes (checa a base de dados)
- `apt-get clean`: faz uma limpeza no gerenciador de pacotes (*housekeeping*)
- `apt-get -d install zsh` ou `--download-only`: faz download do pacote sem instalar do `.deb`, inclusive das dependências (download fica em `/var/cache/apt/archives`

---

#### Corrigindo dependências quebradas

É possível ter “dependências quebradas” em um sistema. O termo significa que um ou mais dos pacotes instalados dependem de outros pacotes que não foram instalados ou não estão mais presentes. Isso pode ocorrer devido a um erro do `APT` ou a um pacote instalado manualmente.

Para resolver o problema, use o comando `apt-get install -f` ou `--fix-broken`. Ele procura “consertar” os pacotes quebrados instalando as dependências ausentes, garantindo que todos os pacotes voltem a ficar consistentes.

>[!NOTE]
>
>Também pode usar `apt install -f`

---

#### A cache local

Quando instalamos ou atualizamos um pacote, o arquivo `.deb` correspondente é baixado em um diretório de cache local antes do pacote ser instalado. Por padrão, esse diretório é `/var/cache/apt/archives`. 

Os arquivos parcialmente baixados são copiados para `/var/cache/apt/archives/partial/`.

Conforme instalamos e atualizamos diferentes pacotes, o diretório da cache pode ficar bastante volumoso. Para recuperar espaço, podemos esvaziar a cache usando o comando `apt-get clean`. Ele remove o conteúdo dos diretórios /var/cache/apt/archives e `/var/cache/apt/archives/partial/`.

>[!NOTE]
>
>Pode usar `apt clean` (mesmo efeito que `apt-get clean`)

---

#### A lista de fontes

O APT usa uma lista de fontes para saber de onde obter pacotes. Esta lista é armazenada no arquivo `sources.list`, localizada dentro do diretório `/etc/apt`. Esse arquivo pode ser editado diretamente com um editor de texto, como `vi`, `pico` ou `nano`, ou com utilitários gráficos como `aptitude` ou `synaptic`.

Uma linha típica dentro de `sources.list` é assim:
```
deb http://us.archive.ubuntu.com/ubuntu/ disco main restricted universe multiverse
```
A sintaxe é tipo de `arquivo`, `URL`, `distribuição` e `um ou mais componentes`, onde:

- `Tipo de arquivo`: Um repositório pode conter pacotes com software pronto para execução (pacotes binários, do tipo `deb`) ou com o código fonte desse software (pacotes de origem, do tipo `deb-src`). O exemplo acima fornece pacotes binários.
- `URL`: A URL do repositório.
- `Distribuição`: O nome (ou codinome) da distribuição para a qual os pacotes são fornecidos. **Um repositório pode hospedar pacotes para várias distribuições**. No exemplo acima, `disco` é o codinome do `Ubuntu 19.04`, `Disco Dingo`.
- `Componentes`: Cada componente representa um conjunto de pacotes. Esses componentes podem ser diferentes nas diversas distribuições Linux. Por exemplo, no Ubuntu e derivados, eles são:
    - `main`: contém pacotes de código aberto oficialmente suportados.
    - `restricted`: contém software de código fechado oficialmente suportado, como drivers de dispositivo para placas gráficas, por exemplo.
    - `universe`: contém software de código aberto mantido pela comunidade.
    - `multiverse`: contém software não suportado, de código fechado ou protegido por patente.

No Debian, os principais componentes são:
    - `main`: consiste em pacotes compatíveis com as *Debian Free Software Guidelines* (DFSG), que não dependem de software externos a essa área para operar. Os pacotes incluídos aqui são considerados parte da distribuição Debian.
    - `contrib`: contém pacotes compatíveis com DFSG, mas que dependem de outros pacotes que não estão no `main`.
    - `non-free`: contém pacotes que não são compatíveis com o DFSG.
    - `security`: contém atualizações de segurança.
    - `backports`: contém versões mais recentes dos pacotes que estão em `main`. O ciclo de desenvolvimento das versões estáveis do Debian é bastante longo (cerca de dois anos), garantindo que os usuários possam obter os pacotes mais atualizados sem precisar modificar o repositório principal `main`.

>[!NOTE]
>
>Para saber mais sobre as Debian Free Software Guidelines, visite: [https://www.debian.org/social_contract#guidelines](https://www.debian.org/social_contract#guidelines)

Para adicionar um novo repositório do qual obter pacotes, você pode simplesmente acrescentar a linha correspondente (geralmente fornecida pelo mantenedor do repositório) ao final de `sources.list`, salvar o arquivo e recarregar o índice do pacote com `apt-get update`. Depois disso, os pacotes do novo repositório estarão disponíveis para instalação usando `apt-get install`.

Lembre-se de que as linhas que começam com o caractere # são consideradas comentários e ignoradas. O diretório `/etc/apt/sources.list.d`

Dentro do diretório `/etc/apt/sources.list.d`, podemos adicionar arquivos com repositórios adicionais a serem usados pelo APT, sem a necessidade de modificar o arquivo principal `/etc/apt/sources.list`. Trata-se de arquivos de texto simples, com a mesma sintaxe descrita acima e a extensão de arquivo `.list`.

Abaixo, vemos o conteúdo de um arquivo chamado `/etc/apt/sources.list.d/buster-backports.list`:
```
deb http://deb.debian.org/debian buster-backports main contrib non-free
deb-src http://deb.debian.org/debian buster-backports main contrib non-free
```

---

#### dpkg-reconfigure

Quando um pacote é instalado, existe uma etapa de configuração chamada pós-instalação, na qual um script é executado para definir tudo o que é necessário para a execução do software, como permissões, local dos arquivos de configuração etc. Ele também pode fazer algumas perguntas ao usuário sobre as preferências para a execução do software.

Às vezes, devido a um arquivo de configuração corrompido ou malformado, pode ser necessário restaurar as configurações de um pacote para o estado “novo”, ou você pode querer alterar as respostas que deu às questões da configuração inicial. Para isso, execute o utilitário `dpkg-reconfigure`, seguido pelo nome do pacote.

Este programa faz um backup dos arquivos de configuração antigos, descompacta os novos nos diretórios corretos e executa o script de pós-instalação fornecido pelo pacote, como se o pacote tivesse sido instalado pela primeira vez.

- `dpkg-reconfigure`: usado para pacotes que exigem interação com o usuário (configuração de teclado, timezones). Reinvoca as configurações desses tipos de pacotes

- `dpkg-reconfigure tzdata`: reconfigura o timezone (se mudou de país, por exemplo)
    - `tzdata` vem do pacote `tzdata` (`dpkg -l | grep tzdata`)
```
$ dpkg -l |grep tzdata
ii  tzdata                                         2024b-0ubuntu0.24.04                       all          time zone and daylight-saving time data
```
- `dpkg-reconfigure keyboard-configuration`: reconfigura o layout de teclado
```
$ dpkg -l |grep keyboard-configuration
ii  keyboard-configuration                         1.226ubuntu1                               all          system-wide keyboard preferences
```

---

#### dselect

- `dselect`: seria como uma `GUI` do `apt`. É uma interface de menus, onde selecionamos o pacote inicialmente, e depois escolhemos se instalamos, atualizamos, etc. (*Debian package management frontend*)

Provavelmente será necessário instalar: `apt-get install dselect -y`

```
# dselect

Debian 'dselect' package handling frontend version 1.22.6 (amd64).

 * 0. [A]ccess    Choose the access method to use.                                                 
   1. [U]pdate    Update list of available packages, if possible.
   2. [S]elect    Request which packages you want on your system.
   3. [I]nstall   Install and upgrade wanted packages.
   4. [C]onfig    Configure any packages that are unconfigured.
   5. [R]emove    Remove unwanted software.
   6. [Q]uit      Quit dselect.

Move around with ^P and ^N, cursor keys, initial letters, or digits;
Press <enter> to confirm selection.   ^L redraws screen.

Copyright (C) 1994-1996 Ian Jackson.
Copyright (C) 2000,2001 Wichert Akkerman.
This is free software; see the GNU General Public License version 2 or
later for copying conditions. There is NO warranty.
```

---

#### alien

`alien`: (Convert or install an alien binary package): manipular arquivos que não são `.deb` (converte um `.rpm` em `.deb`, ou vice-versa)

>[!NOTE]
>
>Se estiver no Debian, ao instalar o alien, uma das diversas dependências que são instaladas, é o `rpm`

#### Transformar um `.deb` em `.rpm`:

- `$ alien -r pacote.deb` ou `--to-rpm`: vai gerar um pacote `.rpm`
- `$ alien pacote.rpm`: transforma o pacote `.rpm` em pacote `.deb` (comportamento padrão, sem argumentos)
- `$ alien -i pacote.rpm` ou `--install`: instala o `pacote.rpm` (utilizando o Debian): internamente, isso converte de `.rpm` para `.deb` e usa o `dpkg` para instalar o pacote gerado.
```
# alien -i zsh-5.9-7.x86_64.rpm 
	dpkg --no-force-overwrite -i zsh_5.9-8_amd64.deb
```

>[!NOTE]
>
>O `alien` trabalha com outros pacotes também, como `slp`, `lsb`, `tgz` (Slackware).

---

#### apt (apenas)

- `apt` (sim, apenas `apt`) reúne os recursos mais utilizados do `apt-get` e `apt-cache` e a interface gráfica é mais aprimorada, como a inserção de uma barra de progresso.

- `APT`: significa Advanced Packaging Tool (conjunto de ferramentas `apt-get` e `apt-cache`)
- `apt list zsh`: mostra os pacotes que podem ser instalados relacionados ao `zsh` (baseado no `nome`)
- `apt search zsh`: mostra os pacotes que podem ser instalados relacionados ao `zsh` (baseado na `descrição`/`features`)
- `apt show zsh`: mostra informações de pacotes (mesmo não instalados). Geralmente pacotes listados no comando anterior (`apt search`)
```
# apt-cache search p7zip
liblzma-dev - XZ-format compression library - development files
liblzma5 - XZ-format compression library
forensics-extra - Forensics Environment - extra console components (metapackage)
p7zip - 7zr file archiver with high compression ratio
p7zip-full - 7z and 7za file archivers with high compression ratio
p7zip-rar - non-free rar module for p7zip
```

```
# apt-cache show liblzma5
Package: liblzma5
Architecture: amd64
Version: 5.2.4-1
Multi-Arch: same
Priority: required
Section: libs
Source: xz-utils
Origin: Ubuntu
Maintainer: Ubuntu Developers <ubuntu-devel-discuss@lists.ubuntu.com>
Original-Maintainer: Jonathan Nieder <jrnieder@gmail.com>
Bugs: https://bugs.launchpad.net/ubuntu/+filebug
Installed-Size: 259
Depends: libc6 (>= 2.17)
Breaks: liblzma2 (<< 5.1.1alpha+20110809-3~)
Filename: pool/main/x/xz-utils/liblzma5_5.2.4-1_amd64.deb
Size: 92352
MD5sum: 223533a347dc76a8cc9445cfc6146ec3
SHA1: 8ed14092fb1caecfebc556fda0745e1e74ba5a67
SHA256: 01020b5a0515dbc9a7c00b464a65450f788b0258c3fbb733ecad0438f5124800
Homepage: https://tukaani.org/xz/
Description-en: XZ-format compression library
 XZ is the successor to the Lempel-Ziv/Markov-chain Algorithm
 compression format, which provides memory-hungry but powerful
 compression (often better than bzip2) and fast, easy decompression.
 .
 The native format of liblzma is XZ; it also supports raw (headerless)
 streams and the older LZMA format used by lzma. (For 7-Zip's related
 format, use the p7zip package instead.)
```

- `apt remove zsh`: remove o pacote mantendo informações no banco de dados do gerenciador de pacotes e mantendo arquivos de configuração
- `apt purge zsh`: remove tudo (inclusive do banco de dados do gerenciador de pacotes e remove os arquivos de configuração)

---

#### Exercícios interessantes tirados da lpi.org

1. É possível remover um pacote chamado `unzip` do sistema usando `dpkg -r unzip` se o pacote `file-roller` depender dele? Se não, qual seria o jeito correto de fazer isso?

**Resposta**: Não. O `dpkg` **não** resolve dependências e **não** permite remover um pacote se outro pacote instalado depender dele. Neste exemplo, podemos primeiro remover `file-roller` (pressupondo que nada depende dele) e em seguida remover `unzip`, ou remover os dois ao mesmo tempo com
```
# dpkg -r unzip file-roller
```

2. Ao compilar um programa, aparece uma mensagem de erro reclamando que o arquivo de cabeçalho `zzip-io.h` não está presente no seu sistema. Como você pode descobrir qual pacote fornece esse arquivo?

**Resposta**: Use `apt-file search` para descobrir qual pacote contém um arquivo que não está presente no sistema:
```
# apt-file search zzip-io.h
```

---

### 102.5 Uso e gerenciamento de pacotes com RPM e YUM

#### Comando rpm

Trabalha em três modos: **modo de cosulta**, **modo de instalação** e **modo de remoção**. Em teoria teria o quarto **modo de verificação**, mas é pouco usado.

---

1. **Modo consulta RPM**:

- `rpm` (**redhat packet manager**) é equivalente ao `dpkg` (Debian): ambos **não** resolvem dependências!
- `rpm -q` (`query`): consulta
- `rpm -qa` (`query all`): mostra **todos** os pacotes instalados no computador
- `rpm -qa bash` (ou `rpm -qa | grep bash`): retorna só informação sobre o `bash`
- `rpm -qi bash` (`query info`): retorna informações sobre a instalação do `bash` (nome, versão, release, install date, size, etc)
- `rpm -ql bash` (`query list`): retorna a lista dos arquivos que pertencem à instalação do `bash`
- `rpm -qc bash`: retorna a lista dos arquivos de configuração do `bash`
- `rpm -qd bash`: retorna a lista dos arquivos de documentação do `bash` (`man`)
- `rpm -qlp pacote.rpm` ou `--package`: lista os arquivos que contém no pacote
- `rpm -qip`: lista informações sobre o pacote
- `rpm -qf /etc/skel/.bashrc` (`--file` | `query file`): usado para descobrir qual pacote instalado possui um arquivo (`query package owning FILE`)

---

2. **Modo Instalação RPM**:

- `rpm -i`: `-i` instala o pacote `.rpm`. 
- `rpm -U pacote.rpm`: o `-U` ou `--upgrade` faz update (caso pacote já instalado, se não tiver, o `-U` instala uma nova cópia. Para só atualizar, usar a opção `-F`)

>[!NOTE]
>
>É comum instalar com `rpm -ivh pacote.rpm`: o `v`=`verbose` e `h`=`hash` (cerquilhas # que formam uma barra de progresso)

>[!TIP]
>
>Aceita lista na instalação: `rpm -ivh pacote1.rpm pacote2.rpm`

Instalação que exige dependências:

Ex. `rpm -ivh pacote.rpm`: se exigir dependência, vai dar erro, e avisa quais são e finaliza, sem instalar.

O `rpm` verifica se essas dependências estão instaladas em seu sistema; se não estiverem, ele não conseguirá instalar o pacote. Nesse caso, o rpm lista os pacotes faltantes. No entanto, ele não pode resolver dependências sozinho.

No exemplo abaixo, o usuário tentou instalar o pacote do editor de imagens `GIMP`, mas algumas dependências estavam ausentes:
```
# rpm -i gimp-2.8.22-1.el7.x86_64.rpm
error: Failed dependencies:
	babl(x86-64) >= 0.1.10 is needed by gimp-2:2.8.22-1.el7.x86_64
	gegl(x86-64) >= 0.2.0 is needed by gimp-2:2.8.22-1.el7.x86_64
	gimp-libs(x86-64) = 2:2.8.22-1.el7 is needed by gimp-2:2.8.22-1.el7.x86_64
	libbabl-0.1.so.0()(64bit) is needed by gimp-2:2.8.22-1.el7.x86_64
	libgegl-0.2.so.0()(64bit) is needed by gimp-2:2.8.22-1.el7.x86_64
	libgimp-2.0.so.0()(64bit) is needed by gimp-2:2.8.22-1.el7.x86_64
	libgimpbase-2.0.so.0()(64bit) is needed by gimp-2:2.8.22-1.el7.x86_64
	libgimpcolor-2.0.so.0()(64bit) is needed by gimp-2:2.8.22-1.el7.x86_64
	libgimpconfig-2.0.so.0()(64bit) is needed by gimp-2:2.8.22-1.el7.x86_64
	libgimpmath-2.0.so.0()(64bit) is needed by gimp-2:2.8.22-1.el7.x86_64
	libgimpmodule-2.0.so.0()(64bit) is needed by gimp-2:2.8.22-1.el7.x86_64
	libgimpthumb-2.0.so.0()(64bit) is needed by gimp-2:2.8.22-1.el7.x86_64
	libgimpui-2.0.so.0()(64bit) is needed by gimp-2:2.8.22-1.el7.x86_64
	libgimpwidgets-2.0.so.0()(64bit) is needed by gimp-2:2.8.22-1.el7.x86_64
	libmng.so.1()(64bit) is needed by gimp-2:2.8.22-1.el7.x86_64
	libwmf-0.2.so.7()(64bit) is needed by gimp-2:2.8.22-1.el7.x86_64
	libwmflite-0.2.so.7()(64bit) is needed by gimp-2:2.8.22-1.el7.x86_64
```

Cabe ao usuário encontrar os pacotes `.rpm` com as dependências correspondentes e instalá-los. Os gerenciadores de pacotes como o `yum`, `zypper` e `dnf` têm ferramentas que informam qual pacote fornece um arquivo específico. Falaremos deles mais adiante nesta lição.

- `rpm -ivh --nodeps pacote.rpm`: "forçar" instalar ignorando as dependências.

- `rpm -ivh --force pacote.rpm`: sobrescreve qualquer outro arquivo que já exista na instalação (se instalar sem `--force` e já existir arquivo, vai dar erro, avisando que já tem arquivo da instalação, o `--force` faz sobrescrever esses arquivos que já existam)
- `rpm -ivh --test pacote.rpm`: testa o pacote, sem instalar.

>[!NOTE]
>
>Opções com `-i` também funcionam com `-U`

---

3. **Modo de Desinstalação RPM**:

- `rpm -e` ou `--erase ksh`: desinstala o `ksh`
- `rpm -evh zsh`: desinstala com verbose e barra de progresso (# cerquilha - `--hash`)
- `rpm -evh --test zsh`: testa a desinstalação (mas não desinstala propriamente dito)
- `rpm -evh --nodeps zsh`: por padrão, se remover um pacote que outro programa usa/depende, não será possível remover. A opção `--nodeps` remove sem se importar com dependências
```
# rpm -e unzip
error: Failed dependencies:
	/usr/bin/unzip is needed by (installed) file-roller-3.28.1-2.el7.x86_64
```

Para concluir a operação, primeiro é necessário remover os pacotes que dependem daquele que se deseja remover (no exemplo acima, `file-roller`). Podemos passar vários nomes de pacotes para o rpm -e para remover vários pacotes de uma só vez.

- `rpm -V bash` ou `--verify`: verifica se está tudo certo com a instalação. Caso não retorne nada, significa que está tudo certo. Ter em mente que o `--verify` checa o que mudou desde que instalou o pacote, do pacote original.

---

#### opções rpm

Ainda sobre rpm `--verify` (ou `-V`)

Se rodarmos `rpm --verify rsyslog`: se houver alteração, é mostrado na saída desse comando: 
- `S`= diferença no **S**ize/Tamanho (file **S**ize differs)
- `M`: **M**ode differs (permissão e tipos de arquivos)
- `5`: diferença no MD**5** digest
- `D`: **D**evice major/minor number mismatch
- `L`: read**L**ink(2) path mismatch
- `U`: diferença do **U**ser ownership
- `G`: diferença do **G**roup ownership
- `T`: diferença no m**T**ime
- `P`: diferença de ca**P**abilities

A ideia principal de `--verify` é verificar se houveram mudanças no pacote desde a sua instalação inicial.

Exemplo:

```
# rpm --verify rsyslog
S.5....T.
```

No comando e saída acima, mostra que foi mudado `S` de size (no caso mudou de tamanho), `5` que é referente ao MD5 (que também alterou) e `T` de Time (no caso mudou o horário de modificação do arquivo)

- `rpm --verify -all`: verifica alterações em todo o sistema (saída pode ser enorme)

>[!NOTE]
>
>Podemos usar `rpm --checksig pacote.rpm` para também checar se o pacote está da mesma forma que foi gerado.

No `rpm` é possível chegar a assinatura `checksum` `md5` do pacote `.rpm`, usando `rpm --checksig pacote.rpm`
```
# rpm --checksig tcsh-6.18.01-13.e17_3.1.x86_64.rpm
tcsh-6.18.01-13.e17_3.1.x86_64.rpm: rsa sha1 (md5) pgp md5 OK
```

---

#### Verificar os pacotes necessário (dependências)

- `rpm -qR bash`ou `--requires`: mostra as dependências requiridas para o `bash`
- `rpm -qpR pacote.rpm` ou `--requires` e `--package`: mostra as dependências requiridas algum pacote `.rpm` (o `-p` ou `--packate` é devido ser um pacote `.rpm` que ainda não está instalado - útil para sabermos o que precisa antes de instalar)

>[!NOTE]
>
>Lembrando que `rpm` não resolve dependência (assim como o `dpkg` para Debian)

>[!TIP]
>
>Ver a *release* do Sistema Operacional baseado em RedHat, use `cat /etc/redhat-release`

---

#### yum

O `yum` foi originalmente desenvolvido como *Yellow Dog Updater* (`YUP`), uma ferramenta para gerenciamento de pacotes na distribuição **Linux Yellow Dog**. Com o tempo, evoluiu para gerenciar pacotes em outros sistemas baseados em RPM, como Fedora, CentOS, Red Hat Enterprise Linux e Oracle Linux.

Em termos de funcionalidade, ele é semelhante ao utilitário `apt` dos sistemas baseados em Debian, sendo capaz de buscar, instalar, atualizar e remover pacotes, além de gerir automaticamente as dependências. O `yum` pode ser usado para instalar um único pacote ou para atualizar um sistema inteiro de uma vez só.

- `yum` (equivalente ao `apt-get` no Debian): ou seja, faz o download e instalação do(s) pacote(s), resolvendo dependências.
- `/etc/yum.conf`: principal arquivo de configuração do `yum` (informações como `cachedir`, `logfile`, `nível de log`, etc)
- `/etc/yum.repos.d/`: onde ficam os arquivos que apontam para os repositórios (cada repositório é representado por um arquivo `.repo`, como `CentOS-Base.repo`, por exemplo)

>[!NOTE]
>
>Repositórios adicionais podem ser incluídos pelo usuário acrescentando um arquivo `.repo` no diretório mencionado acima, ou no final de `/etc/yum.conf`. No entanto, a maneira recomendada de adicionar ou gerenciar repositórios é usar a ferramenta `yum-config-manager`

Para adicionar um repositório, use o parâmetro `--add-repo`, seguido da URL para um arquivo `.repo`:
```
# yum-config-manager --add-repo https://rpms.remirepo.net/enterprise/remi.repo
```

- `yum repolist all`: lista de todos os repositórios disponíveis
```
# yum repolist all
Loaded plugins: fastestmirror, langpacks
Loading mirror speeds from cached hostfile
 * base: mirror.ufscar.br
 * epel: mirror.globo.com
 * extras: mirror.ufscar.br
 * updates: mirror.ufscar.br
repo id                       repo name                    status
updates/7/x86_64              CentOS-7 - Updates           enabled:  2,500
updates-source/7              CentOS-7 - Updates Sources   disabled
```

Os repositórios `disabled` (desabilitados) serão ignorados ao instalar ou atualizar o software. Para habilitar ou desabilitar um repositório, use o utilitário `yum-config-manager`, seguido pelo ID do repositório.

Na saída acima, a identidade do repositório é mostrada na primeira coluna (`repo id`) de cada linha. Usamos apenas a parte anterior ao primeiro `/`, de forma que o id do repositório CentOS-7 - Updates é `updates`, e não `updates/7/x86_64`.
```
# yum-config-manager --disable updates
```

O comando acima desabilita o repositório updates. Para reativá-lo, use:
```
# yum-config-manager --enable updates
```

>[!NOTE]
>
>O Yum armazena os pacotes baixados e os metadados associados em um diretório de cache (geralmente `/var/cache/yum`). À medida que o sistema é atualizado e novos pacotes são instalados, essa cache pode ficar bem grande. Para limpar a cache e recuperar o espaço em disco, podemos usar o comando `yum clean`, seguido pelo que deve ser removido. Os parâmetros mais úteis são `packages` (`yum clean packages`) para excluir pacotes baixados e metadata (`yum clean metadata`) para excluir os metadados associados. Consulte a página de manual do `yum` (digite `man yum`) para obter mais informações.

---

#### Instalação de pacotes

- `yum install gcc`: instala o `gcc` resolvendo as dependências (instala e atualiza as dependências se for necessário)
- `yum update`: atualiza todos os pacotes no sistema para os quais exista uma atualização disponível. (com `--obsoletes` remove as fontes obsoletas)
- `yum update wget`: atualiza especificamente o `wget`

>[!NOTE]
>
>`yum update PACKAGENAME`: atualiza as fontes e se houver versão mais nova, atualiza também.

- `yum upgrade`: atualiza os pacotes novos e remove os pacotes que fora marcados como obsoletos
- `yum check-update PACKAGENAME`: verifica se há uma atualização disponível para um pacote específico, ou se omitir o nome do pacote, o `yum` procurará atualizações para todos os pacotes instalados no sistema

#### listar pacotes

- `yum list`: lista todos os pacotes instalados no computador (cuidado, não aceita `Ctrl+C`, e pode ser que demore demais)
- `yum search samba`: buscar todos os pacotes na base de dados relacionados ao Samba (busca por pacotes)
- `yum info firefox`: lista informações sobre o pacote do firefox, como versão, arquitetura, descrição, tamanho e mais.

Em um exemplo anterior, mostramos uma tentativa de instalar o editor de imagens `gimp`, que falhou devido a dependências não atendidas. No entanto, o `rpm` mostra quais arquivos estão faltando, mas não lista o nome dos pacotes que os fornecem.

Por exemplo, uma das dependências ausentes era `libgimpui-2.0.so.0`. Para ver qual pacote o fornece, usamos `yum whatprovides`, seguido pelo nome do arquivo que estamos procurando:
```
# yum whatprovides libgimpui-2.0.so.0
Loaded plugins: fastestmirror, langpacks
Loading mirror speeds from cached hostfile
 * base: mirror.ufscar.br
 * epel: mirror.globo.com
 * extras: mirror.ufscar.br
 * updates: mirror.ufscar.br
2:gimp-libs-2.8.22-1.el7.i686 : GIMP libraries
Repo        : base
Matched from:
Provides    : libgimpui-2.0.so.0
```

A resposta é `gimp-libs-2.8.22-1.el7.i686`. Em seguida podemos instalar o pacote com o comando `yum install gimp-libs`.

Isso também funciona para arquivos já existentes no seu sistema. Por exemplo, para saber de onde o arquivo `/etc/hosts` veio, você pode usar:
```
# yum whatprovides /etc/hosts
Loaded plugins: fastestmirror, langpacks
Loading mirror speeds from cached hostfile
 * base: mirror.ufscar.br
 * epel: mirror.globo.com
 * extras: mirror.ufscar.br
 * updates: mirror.ufscar.br
setup-2.8.71-10.el7.noarch : A set of system configuration and setup files
Repo        : base
Matched from:
Filename    : /etc/hosts
```

A resposta é `setup-2.8.71-10.el7.noarch`

---

#### desinstalação de pacotes

- `yum erase` ou `remove gcc`: remove o gcc

#### download de pacotes (sem instalação)

- `yum install --downloadonly samba`: faz o download do pacote samba e suas dependências (grava em um diretório temporário do `yum`)
- `yum install --downloadonly --downloaddir=/tmp/samba samba`: faz o download do pacote samba e suas dependências no diretório `/tmp/samba`

#### extração de .rpm

- `rpm2cpio pacote.rpm > pacote.cpio`: transforma um arquivo `.rpm` em um arquivo `.cpio` ([cpio](#cpio) é um arquivo de agrupamento de arquivos)
- `cpio -i --make-directories < pacote.cpio`: extrai o arquivo .cpio

---

#### DNF

`dnf` (**Dandified YUM**) substituiu o `yum` no Fedora mais novo, é praticamente os mesmos comandos do `yum`. (`dnf` é um *fork* do `yum`)

Inclusive se digitar `yum --help`, irá ser mostrado na primeira linha algo do tipo: `usage: dnf`

`dnf` veio para melhorar o desempenho, consumo de memória e resolver problemas de dependências.

Se usarmos `which yum`, o retorno será `/usr/bin/yum`, e se dermos um `ls -l /usr/bin/yum`, mostrará que o `/usr/bin/yum` é um link para o `dnf-3`
```
# ls -l /usr/bin/yum
lrwxrwxrwx. 1 root root 5 Oct  1 11:26 /usr/bin/yum -> dnf-3
```

>[!TIP]
>
>comando [which](#which) mostra o caminho absoluto dos comandos shell

- `dnf search PATTERN`: `PATTERN` é aquilo que você está buscando. Por exemplo, `dnf search unzip` mostra todos os pacotes que contêm a palavra `unzip` no nome ou descrição.
- `dnf info PACKAGENAME`: obtem informações sobre um `PACKAGENAME`
- `dnf provides /usr/bin/hostname`: descobre qual pacote fornece um arquivo específico, nesse caso a pesquisa foi pelo arquivo `hostname`
- `dnf list --installed`: obter uma lista de todos os pacotes instalados no sistema
- `dnf repoquery -l PACKAGENAME`: listar o conteúdo de um pacote
- `dnf install PACKAGENAME`, onde `PACKAGENAME` é o nome do pacote que s deseja instalar (para encontrar o pacote, faça uma busca)
- `dnf remove PACKAGENAME`: remove/desinstala o pacote descrito em `PACKAGENAME`
- `dnf upgrade PACKAGENAME`: atualiza um só pacote. Omita o nome do pacote para atualizar todos os pacotes do sistema

>[!NOTE]
>
>O `dnf` tem um sistema de ajuda embutido que mostra mais informações (como parâmetros extras) para cada comando. Para usá-lo, digite `dnf help` seguido pelo comando, como `dnf help install`


>[!NOTE]
>
>Como no caso do `yum` e do `zypper`, o `dnf` trabalha com repositórios de software (repos). Cada distribuição tem uma lista de repositórios padrão e os administradores podem adicionar ou remover repositórios conforme necessário.

Para obter uma lista de todos os repositórios disponíveis, use `dnf repolist`. Para listar apenas os repositórios ativados, adicione a opção `--enabled` e, para listar apenas os repositórios desativados, adicione a opção `--disabled`.
```
# dnf repolist
Last metadata expiration check: 0:20:09 ago on Sat 21 Sep 2019 02:39:43 PM -03.
repo id                    repo name                                      status
*fedora                    Fedora 30 - x86_64                             56,582
*fedora-modular            Fedora Modular 30 - x86_64                        135
*updates                   Fedora 30 - x86_64 - Updates                   12,774
*updates-modular           Fedora Modular 30 - x86_64 - Updates              145
```

Para adicionar um repositório, use `dnf config-manager --add_repo URL`, onde `URL` é a `URL` completa do repositório. Para habilitar um repositório, use `dnf config-manager --set-enabled REPO_ID`.

Da mesma forma, para desativar um repositório, `use dnf config-manager --set-disabled REPO_ID`. Nos dois casos, `REPO_ID` é o `ID` exclusivo do repositório, que pode ser obtido com dnf repolist. Os repositórios adicionados são ativados por padrão. Os repositórios são armazenados em arquivos `.repo` no diretório `/etc/yum.repos.d/`, com exatamente a mesma sintaxe usada para o `yum`.

---

#### zypper (SUSE e OpenSUSE)

O `zypper` é a ferramenta de gerenciamento de pacotes usada no SUSE Linux e OpenSUSE. Em termos de recursos, é semelhante ao `apt` e ao `yum`, sendo capaz de instalar, atualizar e remover pacotes de um sistema, com resolução automática de dependências.


- `SUSE`: versão entreprise (assim como RedHat Enterprise)
- `OpenSUSE`: versão (versão aberta, assim como CentOS e Fedora)

OpenSuse também usa pacote `rpm`, mas não trabalha com `yum`, e sim o `zypper` (`zypper` é equivalente ao `yum`)

>[!NOTE]
>
>`rpm` e `zypper` são similares

- `zypper repos`: mostra os repositórios atualmente configurados
```
# zypper repos
Repository priorities are without effect. All enabled repositories share the same priority.

#  | Alias                     | Name                               | Enabled | GPG Check | Refresh
---+---------------------------+------------------------------------+---------+-----------+--------
 1 | openSUSE-Leap-15.1-1      | openSUSE-Leap-15.1-1               | No      | ----      | ----
 2 | repo-debug                | Debug Repository                   | No      | ----      | ----
 3 | repo-debug-non-oss        | Debug Repository (Non-OSS)         | No      | ----      | ----
 4 | repo-debug-update         | Update Repository (Debug)          | No      | ----      | ----
 5 | repo-debug-update-non-oss | Update Repository (Debug, Non-OSS) | No      | ----      | ----
 6 | repo-non-oss              | Non-OSS Repository                 | Yes     | (r ) Yes  | Yes
 7 | repo-oss                  | Main Repository                    | Yes     | (r ) Yes  | Yes
 8 | repo-source               | Source Repository                  | No      | ----      | ----
 9 | repo-source-non-oss       | Source Repository (Non-OSS)        | No      | ----      | ----
10 | repo-update               | Main Update Repository             | Yes     | (r ) Yes  | Yes
11 | repo-update-non-oss       | Update Repository (Non-Oss)        | Yes     | (r ) Yes  | Yes
```

Na coluna `Enabled` vemos que alguns repositórios estão ativados e outros não. Para mudar isso, use o operador `modifyrepo`, seguido pelo parâmetro `-e` (`enable`) ou `-d` (`disable`) e pelo alias do repositório (a segunda coluna na saída acima).
```
# zypper modifyrepo -d repo-non-oss
Repository 'repo-non-oss' has been successfully disabled.
```
```
# zypper modifyrepo -e repo-non-oss
Repository 'repo-non-oss' has been successfully enabled.
```

- `zypper ls`: lista os repositórios (similar ao comando anterior)
- `zypper info gimp`: mostra os metadados associados a um pacote. São exibidos informações sobre nome do pacote, versão, arquitetura, fornecedor, tamanho instalado, se está instalado ou não, status (se está atualizado), o pacote de origem e uma descrição.

>[!NOTE]
>
>os repositórios ficam em `/etc/zypp/repos.d`

Dentro de `/etc/zypp/repos.d`, temos, por exemplo, o arquivo `repo-update.repo`, que mostra de onde baixar as atualizações para o sistema:
```
# cat /etc/zypp/repos.d/repo-update.repo
[repo-update]
name=openSUSE-Leap-15.0-Update
enabled=1
autorefresh=1
baseurl=http://download.opensuse.org/update/leap/15.0/oss/
path=/
type=rpm-md
keeppackages=0
```

- `zypper refresh`: atualiza a base de dados. Faz a atualização dos metadados (que precisam ser atualizados periodicamente) para que o utilitário fique a par dos pacotes mais recentes.
- `zypper update`: atualiza os pacotes instalados com uma nova versão
- `zypper list-updates` ou `lu`: lista as atualizações disponíveis


o `zypper` possui um recurso de atualização automática que pode ser ativado caso a caso nos repositórios. Quando ativado, esse sinalizador faz com que o `zypper` execute uma operação de atualização (como se executássemos `zypper refresh`) antes de trabalhar com o repositório especificado. O processo pode ser controlado com os parâmetros `-f` e `-F` do operador `modifyrepo`:
```
# zypper modifyrepo -F repo-non-oss
Autorefresh has been disabled for repository 'repo-non-oss'.
```

```
# zypper modifyrepo -f repo-non-oss
Autorefresh has been enabled for repository 'repo-non-oss'.
```

Para adicionar um novo repositório de software para o `zypper`, use o operador `addrepo` seguido da `URL` e do nome do repositório, como abaixo:
```
# zypper addrepo http://packman.inode.at/suse/openSUSE_Leap_15.1/ packman
Adding repository 'packman' ........................................[done]
Repository 'packman' successfully added

URI         : http://packman.inode.at/suse/openSUSE_Leap_15.1/
Enabled     : Yes
GPG Check   : Yes
Autorefresh : No
Priority    : 99 (default priority)

Repository priorities are without effect. All enabled repositories share the same priority.
```

Para remover um repositório, use o operador `removerepo` seguido pelo nome do repositório (Alias). Para remover o repositório adicionado no exemplo acima, o comando seria:
```
# zypper removerepo packman
Removing repository 'packman' ......................................[done]
Repository 'packman' has been removed.
```

#### Exercício interessante na lpi.org

1. Usando o `zypper`, como desabilitaríamos um repositório chamado repo-extras?

**Resposta**: Use a operação `modifyrepo` para alterar os parâmetros de um repositório, e o parâmetro `-d` para desabilitá-lo: `zypper modifyrepo -d repo-extras`.

- `zypper search calculator` ou `se`: busca no repositório algum programa que atenda ao termo pesquisado "calculadora"
- `zypper se -i`: obter uma lista de todos os pacotes instalados no sistema
    - pode procurar um pacote específico: `zypper se -i firefox`
    - se quiser descobrir quais pacotes contêm um arquivo específico, use o operador de pesquisa seguido pelo parâmetro `--provides`
```
# zypper se --provides /usr/lib64/libgimpmodule-2.0.so.0
Loading repository data...
Reading installed packages...

S | Name          | Summary                                      | Type
--+---------------+----------------------------------------------+--------
i | libgimp-2_0-0 | The GNU Image Manipulation Program - Libra-> | package
```
- `zypper info pacoteEscolhido`: traz informação sobre o pacote de escolha, para uma consulta prévia sobre o pacote. Mostra se o pacote está instalado ou não

O zypper também pode ser usado para instalar um pacote `RPM` no disco enquanto tenta atender às dependências usando pacotes dos repositórios. Para isso, basta fornecer o caminho completo para o pacote em vez de apenas um nome de pacote, como em `zypper in /home/john/newpackage.rpm`.

Para atualizar os pacotes instalados no sistema, use `zypper update`. Como no caso do processo de instalação, aparece uma lista de pacotes a serem instalados/atualizados e o gerenciador pergunta se você deseja continuar.

Se quiser listar apenas as atualizações disponíveis, sem instalar nada, use `zypper list-updates`.

---

#### instalação via zypper

- `zypper install zsh` ou `in`: instala o `zsh`

---

#### remoção de pacotes

- `zypper remove zsh` ou `rm`: remove o `zsh`

>[!WARNING]
>
>Lembre-se de que a remoção de um pacote também remove outros pacotes que dependem dele. Por exemplo:
```
# zypper rm libgimp-2_0-0
Loading repository data...
Warning: No repositories defined. Operating only with the installed resolvables. Nothing can be installed.
Reading installed packages...
Resolving package dependencies...

The following 6 packages are going to be REMOVED:
  gimp gimp-help gimp-lang gimp-plugins-python libgimp-2_0-0
  libgimpui-2_0-0

6 packages to remove.
After the operation, 98.0 MiB will be freed.
Continue? [y/n/v/...? shows all options] (y):
```

---

### 102.6 O Linux como máquina virtual

Um dos maiores pontos fortes do Linux é sua versatilidade. Um aspecto dessa versatilidade é a possibilidade de usar o Linux como meio de hospedar outros sistemas operacionais, ou aplicativos individuais, em um ambiente completamente isolado e seguro

- Virtualização (HVM)
    - A VM utiliza uma réplica do hardware virtualizado (A VM não sabe que ela é uma VM, ela acha que é uma máquina real)
    - não é necessário modificar o S.O. do Guest
    - Requer suporte da CPU
- Paravirtualização (PV)
    - Requer modificação do S.O. do Guest (o S.O. sabe que está em uma VM)
    - O S.O. Guest interage diretamente com o Hypervisor
    - Não requer suporte da CPU
    - uso de paravirtual drivers. Exemplo: VirtIO (KVM), Xen

A virtualização é uma tecnologia que permite que uma plataforma de software, chamada de *hipervisor*, execute processos que contêm um sistema inteiramente emulado (virtual). O *hipervisor* é responsável por gerenciar os recursos do hardware físico que podem ser usados por máquinas virtuais individuais. Essas máquinas virtuais são chamadas de *guests* (convidados) do hypervisor. Muitos dos aspectos de um computador físico são emulados por software na máquina virtual, como a BIOS do sistema e os controladores de disco rígido. Uma máquina virtual geralmente usa imagens de disco rígido que são armazenadas como arquivos individuais e tem acesso à RAM e à CPU da máquina hospedeira por meio do software *hipervisor*. O *hipervisor* divide o acesso aos recursos de hardware do sistema hospedeiro entre os convidados, permitindo assim que vários sistemas operacionais sejam executados em um único sistema hospedeiro.

Dentre os hipervisores mais comumente usados no Linux, podemos citar:
- `Xen`: é um hipervisor de código aberto de **Tipo 1**, o que significa que ele não depende de um sistema operacional subjacente para funcionar. Um hipervisor desse tipo é conhecido como *hipervisor bare-metal*, pois o computador pode inicializar diretamente no hipervisor.
- `KVM`: o Kernel Virtual Machine é um módulo de virtualização do kernel do Linux. O KVM é um hipervisor de **Tipo 1** e também de **Tipo 2** porque, embora precise de um sistema operacional Linux genérico para funcionar, é capaz de agir perfeitamente bem como hipervisor integrando-se a uma instalação Linux em execução. As máquinas virtuais implementadas com o KVM usam o daemon `libvirt` e utilitários de software associados para serem criadas e gerenciadas.
- `VirtualBox`: um aplicativo desktop popular que facilita a criação e o gerenciamento de máquinas virtuais. O Oracle VM VirtualBox é multiplataforma e funciona em Linux, macOS e Microsoft Windows. Como o VirtualBox requer um sistema operacional subjacente para ser executado, ele é um hipervisor de **Tipo 2**.

Alguns hipervisores permitem a realocação dinâmica de uma máquina virtual. O processo de mover uma máquina virtual de uma instalação do hipervisor para outra é chamado de migração e as técnicas envolvidas são diferentes conforme as implementações do hipervisor. Algumas migrações só podem ser realizadas quando o sistema convidado está completamente desligado e outras podem ser feitas com o convidado em execução (é o que chamamos migração ao vivo). Essas técnicas podem ser úteis durante a manutenção dos hipervisores, ou ainda para garantir a resiliência do sistema quando um hipervisor para de funcionar, sendo possível mover o convidado para outro.

---

#### tipos de discos KVM

- `COW`: *Copy-on-write* ou cópia na gravação (também conhecida como thin-provisioning ou sparse images) é um método em que um arquivo de disco é criado com um limite máximo de tamanho predefinido. O tamanho da imagem do disco só aumenta quando novos dados são gravados no disco. Por exemplo, o sistema operacional convidado vê o limite de disco predefinido de 23,3 GB, mas gravou apenas 5,5 GB de dados no arquivo de disco. O formato de imagem de disco usado para a máquina virtual de exemplo é `qcow2`, um formato de arquivo QEMU COW.
- `RAW`: Um tipo de disco raw ou full é um arquivo que tem todo o seu espaço pré-alocado. Por exemplo, um arquivo de imagem de disco raw de 10 GB consome 10 GB de espaço em disco real no hipervisor. Esse estilo de disco permite um **ganho de desempenho**, pois todo o espaço em disco necessário já existe, de modo que o hipervisor subjacente pode simplesmente gravar dados no disco sem o impacto no desempenho que seria causado pela necessidade de monitorar a imagem do disco para garantir que ele não atingiu seu limite e de estender o tamanho do arquivo à medida que novos dados são gravados nele.

---

#### D-BUS MACHINE ID

Usada para identificar o container ou a máquina virtual de maneira única (é um identificador único). Cada container ou VM terá um idenficador.

Fica armazedo em: `/etc/machine-id`
```
# cat /etc/machine-id 
86596e59d03749f1aba3caf14565678c
```

E é gerado por: `systemd-machine-id-setup --print` (usa informações do computador/hardware para gerar)

- `dbus-uuidgen --get`: busca pelo `machine-id`

>[!NOTE]
>
>A sequência de caracteres exibida é o número de ID atual. Dois sistemas Linux em execução em um hipervisor não devem ter o mesmo D-Bus machine ID.

- `dbus-uuidgen --ensure`: validar se existe um D-Bus machine ID para o sistema em execução. Se nenhuma mensagem de erro for exibida, é porque já existe um ID para o sistema.

O D-Bus machine ID fica em `/var/lib/dbus/machine-id` e está simbolicamente ligado a `/etc/machine-id`. Não é recomendável alterar esse número de ID em um sistema em execução, pois isso pode acarretar instabilidades e travamentos do sistema.

Se duas máquinas virtuais tiverem o mesmo D-Bus machine ID, siga o procedimento abaixo para gerar um novo:
```
$ sudo rm -f /etc/machine-id
$ sudo dbus-uuidgen --ensure=/etc/machine-id
```

Se por acaso `/var/lib/dbus/machine-id` não for um link simbólico que remete a `/etc/machine-id`, `/var/lib/dbus/machine-id` terá de ser removido.

---

#### Formas de verificar se está em uma máquina real ou virtual

- `grep hypervisor /proc/cpuinfo`: se não retornar nada, é uma máquina real, se retornar, é virtual (retorna as flags informando o `hypervisor`)

Máquina Real
```
$ cat /proc/cpuinfo |grep hypervisor

```

Máquina Virtual
```
$ grep hypervisor /proc/cpuinfo 
flags		: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon rep_good nopl xtopology cpuid tsc_known_freq pni pclmulqdq vmx ssse3 fma cx16 pdcm pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor lahf_lm abm 3dnowprefetch cpuid_fault ssbd ibrs ibpb stibp ibrs_enhanced tpr_shadow flexpriority ept vpid ept_ad fsgsbase tsc_adjust bmi1 avx2 smep bmi2 erms invpcid mpx rdseed adx smap clflushopt xsaveopt xsavec xgetbv1 xsaves arat vnmi umip md_clear flush_l1d arch_capabilities
flags		: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon rep_good nopl xtopology cpuid tsc_known_freq pni pclmulqdq vmx ssse3 fma cx16 pdcm pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor lahf_lm abm 3dnowprefetch cpuid_fault ssbd ibrs ibpb stibp ibrs_enhanced tpr_shadow flexpriority ept vpid ept_ad fsgsbase tsc_adjust bmi1 avx2 smep bmi2 erms invpcid mpx rdseed adx smap clflushopt xsaveopt xsavec xgetbv1 xsaves arat vnmi umip md_clear flush_l1d arch_capabilities

```

---

- `dmesg | grep hypervisor -i`: faz o mesmo do comando anterior

- `sudo virt-what`: também tem o mesmo retorno dos comandos ainteriores (é preciso instalar o pacote, `apt install virt-what`)
    - `man virt-what`: detect if we are running in a virtual machine)

Máquina real
```
# virt-what
```

Máquina virtual
```
# virt-what
kvm
```

---

- `sudo dmidecode -t system` ou `--type`: mostra pelo `manufacturer`, `Product Name` e `Family`

Máquina real
```
# dmidecode -t system
# dmidecode 3.5
Getting SMBIOS data from sysfs.
SMBIOS 3.2.0 present.

Handle 0x0001, DMI type 1, 27 bytes
System Information
	Manufacturer: Dell Inc.
	Product Name: 3579
	Version: Not Specified
	Serial Number: #######
	UUID: 4c4c4544-005a-3110-804e-b4c04f485133
	Wake-up Type: Power Switch
	SKU Number: ####
	Family: G3
```

Máquina virtual
```
# dmidecode -t system 
# dmidecode 3.6
Getting SMBIOS data from sysfs.
SMBIOS 3.0.0 present.

Handle 0x0100, DMI type 1, 27 bytes
System Information
	Manufacturer: innotek GmbH
	Product Name: VirtualBox
	Version: pc-q35-8.2
	Serial Number: Not Specified
	UUID: c5c3c063-c1f6-42c1-8f3e-3204f7788e90
	Wake-up Type: Power Switch
	SKU Number: Not Specified
	Family: Virtual Machine
```

---

- `sudo lshw -class system`: parecido com comando anterior, é um comando para listar características de hardware.

Máquina real
```
# lshw -class system
optiplex-3080               
    description: Laptop Computer
    product: G3 3579
    vendor: Dell Inc.
    serial: ########
    width: 64 bits
    capabilities: smbios-3.2.0 dmi-3.2.0 smp vsyscall32
    configuration: boot=normal chassis=laptop family=G3 sku=#### uuid=4c4c4544-005a-3110-804e-b4c04f485133
```

Máquina virtual
```
# lshw -class systemlshw -class system
localhost.localdomain       
    description: Computer
    product: VirtualBox
    vendor: innotek GmbH
    version: pc-q35-8.2
    width: 64 bits
    capabilities: smbios-3.0.0 dmi-3.0.0 smp vsyscall32
    configuration: boot=normal uuid=c5c3c063-c1f6-42c1-8f3e-3204f7788e90
```

---

- `hostnamectl status`: parecido com o comando anterior

Máquina real
```
# hostnamectl status 
 Static hostname: G3 3579
       Icon name: computer-laptop
         Chassis: laptop 🖥️
      Machine ID: 86596e59d03749f1aba3caf15585678c
         Boot ID: 9dca111f27be4c4898475d759d4017ce
Operating System: Linux Mint 22                   
          Kernel: Linux 6.8.0-51-generic
    Architecture: x86-64
 Hardware Vendor: Dell Inc.
  Hardware Model: G3 3579
Firmware Version: 2.20.0
   Firmware Date: Thu 2023-08-17
    Firmware Age: 1y 5month 3w 5d
```

Máquina virtual
```
# hostnamectl status 
   Static hostname: (unset)                         
Transient hostname: localhost
         Icon name: computer-vm
           Chassis: vm 🖴
        Machine ID: d3f09010a4b04fe09a9c5303e5137713
           Boot ID: 7fffe35132e048d0a189fef0fa95371f
    Virtualization: kvm
  Operating System: CentOS Stream 9                 
       CPE OS Name: cpe:/o:centos:centos:9
            Kernel: Linux 5.14.0-514.el9.x86_64
      Architecture: x86-64
   Hardware Vendor: QEMU
    Hardware Model: Standard PC _Q35 + ICH9, 2009_
  Firmware Version: 1.16.3-debian-1.16.3-2
```

---

- `systemd-detect-virt`: retorna se é ou não virtual

Máquina real
```
# systemd-detect-virt 
none
```

Máquina virtual
```
# systemd-detect-virt 
kvm
```

---

#### container docker

Algo interessante de se atentar com container (`docker` por exemplo), é que o `kernel` é **compartilhado** com a instância do container, evitando assim o uso de um `hypervisor`.

se rodarmos um container debian com o comando `docker run -it centos`, e executarmos `cat /etc/redhat-release`, trará a versão do CentOS. 

E se executarmos `uname -r`, tanto no **container** como no computador "**host**", o `kernel` será o mesmo (mesmo que o host seja Debian, e a imagem CentOS).

PC Host com o Debian
```
$ cat /etc/debian_version 
trixie/sid
$ uname -r
6.8.0-51-generic
```

Container CentOS
```
# docker run -it centos
[root@6a96b1a2177c /]# cat /etc/redhat-release 
CentOS Linux release 8.4.2105
# uname -r
6.8.0-51-generic
```

>[!NOTE]
>
>Para sair do container, use `Ctrl`+`D` ou digite `exit`

>[!NOTE]
>
>Existem várias tecnologias de contêiner disponíveis para Linux, como Docker, Kubernetes, LXD / LXC, systemd-nspawn, OpenShift e outros. A implementação exata de um pacote de software contêiner está além do escopo do exame LPIC-1.

Os contêineres usam o mecanismo de grupos de controle (mais conhecido como `cgroups`) no kernel do Linux. O `cgroup` é uma forma de particionar os recursos do sistema, como memória, tempo do processador, bem como disco e largura de banda da rede, para um aplicativo individual. Um administrador pode usar `cgroups` diretamente para definir os limites de recursos do sistema em um aplicativo ou um grupo de aplicativos existentes em um único `cgroup`. Em essência, é isso o que o software de contêiner faz para o administrador, além de fornecer ferramentas que facilitam o gerenciamento e a implementação de `cgroups`.

>[!NOTE]
>
>Atualmente, o conhecimento de `cgroups` não é necessário para prestar o exame LPIC-1. O conceito de `cgroup` é mencionado aqui para que o candidato tenha pelo menos algum conhecimento prévio de como um aplicativo é segregado para fins de utilização dos recursos do sistema.

---

#### Acessando convidados na nuvem com segurança

O método mais comum para acessar uma máquina virtual remota em uma plataforma de nuvem é por meio do software `OpenSSH`. Um sistema Linux residente na nuvem teria o servidor `OpenSSH` em execução, enquanto um administrador usaria um cliente `OpenSSH` com chaves pré-compartilhadas para acesso remoto.

Um administrador executaria o seguinte comando:
```
$ ssh-keygen
```

seguindo as instruções para criar um par de chaves SSH públicas e privadas. A chave privada permanece no sistema local do administrador (armazenada em `~/.ssh/`) e a chave pública é copiada para o sistema de nuvem remoto, exatamente o mesmo método que se usaria ao trabalhar com máquinas em rede em uma LAN corporativa.

O administrador então executaria o seguinte comando:
```
$ ssh-copy-id -i <public_key> user@cloud_server
```

Ele copia a chave SSH pública do par que acaba de ser gerado para o servidor de nuvem remoto. A chave pública é gravada no arquivo `~/.ssh/authorized_keys` do servidor na nuvem e define as permissões apropriadas no arquivo.

>[!NOTE]
>
>Se houver apenas um arquivo de chave pública no diretório `~/.ssh/`, então a opção `-i` pode ser omitida, pois o comando `ssh-copy-id` será o padrão para o arquivo de chave pública no diretório (normalmente o arquivo que termina com a extensão `.pub`).

Alguns provedores de nuvem geram automaticamente um par de chaves quando um novo sistema Linux é provisionado. O administrador precisa então baixar a chave privada para o novo sistema do provedor de nuvem e armazená-la em seu sistema local. Observe que as permissões para chaves SSH devem ser `0600` (`rw-------`) para uma chave privada e `0644` (`rw-r--r--`) para uma chave pública.

---

#### Exercícios interessantes da lpi.org

1. Quais extensões de CPU são necessárias em uma plataforma de hardware baseada em x86 para rodar convidados totalmente virtualizados?

**Resposta**: VT-x para as CPUs Intel ou AMD-V para CPUs AMD

2. Uma instalação de servidor de missão crítica, que exige um desempenho mais rápido, provavelmente usará que tipo de virtualização?

**Resposta**: Um sistema operacional que faz uso de paravirtualização, como o Xen, pois o sistema operacional convidado poderá fazer melhor uso dos recursos de hardware disponíveis com drivers de software projetados para funcionar com o hipervisor.

3. Duas máquinas virtuais que foram clonadas a partir do mesmo modelo e que utilizam o D-Bus apresentam desempenho irregular. Ambas têm nomes de host e definições de configuração de rede separadas. Qual comando seria usado para determinar se cada uma das máquinas virtuais tem diferentes D-Bus Machine IDs?

**Resposta**: `dbus-uuidgen --get`

4. Se o seu processador suporta virtualizações, procure a documentação da sua distribuição para executar um hipervisor KVM.

- Instale os pacotes necessários para executar um hipervisor KVM. O método vai variar de acordo com a distribuição, mas aqui estão alguns pontos de partida:
    - Ubuntu — https://help.ubuntu.com/lts/serverguide/libvirt.html
    - Fedora — https://docs.fedoraproject.org/en-US/quick-docs/getting-started-with-virtualization/
    - Arch Linux — https://wiki.archlinux.org/index.php/KVM

- Se estiver usando um ambiente de desktop gráfico, é recomendado instalar também o aplicativo `virt-manager`, um front-end gráfico que pode ser usado em uma instalação KVM. Isso ajudará na instalação e gerenciamento da máquina virtual.

Mais uma vez, o método vai depender da distribuição. Eis um exemplo usando o Ubuntu:
```
$ sudo apt install virt-manager
```

- Baixe a imagem ISO de uma distribuição Linux à sua escolha e, seguindo a documentação da distribuição, crie uma nova máquina virtual usando essa ISO.

O pacote `virt-manager` facilita muito essa tarefa. No entanto, uma máquina virtual pode ser criada a partir da linha de comando usando o comando `virt-install`. Experimente os dois métodos para entender como as máquinas virtuais são implementadas.

---

## Tópico 103: Comandos GNU e UNIX
### 103.1 Trabalhar na linha de comando

---

#### shell, bash, echo, type, PATH

Shell é a interface entre o usuário e o Linux. Shell também é um ambiente de programação (scripts)

Há diversos tipos de shell, como bash (o que é coberto no exame). Tem também o `csh`, `ksh` e etc (tem muitas diferencias na hora de programar scripts, para uso comum não muda muito, é bem sutil).

- `type`: mostra se é um comando interno ou não (comando significa que pode ser interno, pelo shell, ou externo, ao instalar um programa)
- `type echo`: vai retornar que é um programa **shell builtin** (comando interno do shell)
- `type clear` (**usando o comando pela segunda vez**): se já tiver usado o comando `clear`, vai informar que é um programa que está no cache interno (**hashed**), no caso em `/usr/bin/clear` (basicamente um programa externo, assim como `/bin/tar`, por exemplo. Mas é bom diferenciar o **hashed**, que no caso está em cache - em cache para aumentar a eficiência do sistema, o comando foi adicionado a uma tabela de hash para ficar mais acessível na próxima vez que for executado. Depois do reboot volta ao normal - fora da tabela de hash)

>[!NOTE]
>
>Uma maneira mais rápida de limpar a tabela de hash é executar o comando `hash -d`

O caminho para esses programas externos ficam na variável `$PATH`. Os caminhos são separados por `:`. Ao digitar `tar`, é verifica se há algum programa chamado `tar` em algum dos caminhos, no caso está em `/bin/`

>[!NOTE]
>
>Para adicionar um novo diretório ao seu caminho `PATH`, use: `export PATH="/home/yourname/myfiles:$PATH"`. Crie um script simples no diretório `myfiles/`, torne-o executável e tente executá-lo a partir de um diretório diferente. Estes comandos pressupõem que você esteja no diretório inicial, que contém um diretório chamado `myfiles`, vide exemplo abaixo:

```
$ touch myfiles/myscript.sh
$ echo '#!/bin/bash' >> myfiles/myscript.sh
$ echo 'echo Hello' >> myfiles/myscript.sh
$ chmod +x myfiles/myscript.sh
$ myscript.sh
Hello
```

- `echo "Linux Ubuntu"`: imprime "Linux Ubuntu" na saída padrão
- `echo $SHELL`: imprime o conteúdo da variável `$SHELL`, no caso se estiver usando o `bash`, vai imprimir `/bin/bash`

É possível executar scripts das seguintes formas (supõe que o arquivo `script.sh` esteja em `/home/rodrigo/exercicios/script.sh`):
- estando no diretório citado acima: `./script.sh`
- estando em outro diretório, só digitar o caminho **completo**: `/home/rodrigo/exercicios/script.sh`
- estando no diretório `/home/rodrigo`: `exercicios/script.sh` (usando caminho **relativo**)

---

#### Variáveis de Ambiente

- `NOME_VARIAVEL=valor`: declaração de uma variável (localmente, visível apenas na sessão atual do shell)
- `echo $NOME_VARIAVEL`: imprime o valor da variável, localmente.

Se criar um script que imprime uma variável que foi declarada como o exemplo acima, irá imprimir vazio, pois ao executar um script, é chamado outra sessão do shell (consequentemente outro **processo filho**), e posteriormente volta para a sessão que estava (mesmo efeito de quando digita apenas `bash`, no caso entra em um novo shell, com um novo **processo filho**)

Para contornar é preciso exportar a variável, usando `export NOME_VARIAVEL`, ou declarar diretamente com o export: `export NOME_VARIAVEL=valor`

Caso abra uma nova janela/aba do shell, será criado um novo processo independente, e nesse caso mesmo exportando a variável, ela **não** estará disponível (pois **não** é mais um processo filho)

- `set`: mostra todas as variáveis, locais e exportadas (declaradas no bash atual, **enxerga** o que foi e o que **não** foi exportado)
- `env`: mostra as variáveis globais (**só** **enxerga** o que foi exportado)

Ex. `ABC=cde`, apenas `set` que vai enxergar. Para que o `env` enxergue, é preciso exportar, `export ABC`.

>[!NOTE]
>
>`set` é um comando do shell (**set is a shell builtin**, enxerga o que foi e o que não foi exportado)<br>
>Já `env` é um comando externo (`/usr/bin/env`, só enxerga o que foi exportado)

- `env TESTE=Windows ./script.sh`: (supõe que o `script.sh`, imprime o valor da variável `TESTE`, que originalmente tem o valor de `Linux`). Nesse caso **APENAS** nessa execução, vai considerar o valor de `TESTE=Windows`. Se na sequencia digitar `echo $TESTE`, vai imprimir `Linux`

- `unset NOME_VARIAVEL`: **remove** a definição da variável (sem o `$`)

>[!NOTE]
>
>Note que **não há espaços** em torno do sinal de igual durante a atribuição de variáveis.

---

#### Algumas variáveis de ambiente importantes

- `HISTFILE`: onde fica o arquivo de histórico de comandos (`~/.bash_history`)
- `HISTFILESIZE`: tamanho máximo do arquivo `~/.bash_history`
- `HISTFIZE`: quantidade máxima de linhas do arquivo `~/.bash_history`
- `HOME`: mostra o home do usuário local logado
- `LOGNAME`: nome do usuário que fez login na sessão atual
- `PATH`: diretórios em que o Linux irá procurar por arquivos executáveis (sem a necessidade de especificar um caminho completo - neste caso, seria possível executar um programa binário que reside, digamos, em `/usr/local/bin` de dentro do seu diretório pessoal, e ele seria executado como se o arquivo fosse local)
- `PWD`: guarda o último local que alterou o diretório (o diretório atual)
- `SHELL`: o shell que está usando (`/bin/bash`)
- `TERM`: o terminal que está logado (`tty`=sem interface gráfica e `xterm`=com interface gráfica)
- `USER`: nome do usuário (igual ao `LOGNAME`)
- `DISPLAY`: indica às aplicações gráficas onde as janelas deverão ser exibidas. Será estudado no Tópico 106.
- `PS1`: Aparência do prompt do shell.
- `OLDPWD`: Diretório anterior
<br><br>

- `$$`: mostra o PID do shell atual
- `$!`: mostra o último processo executado em background
- `$?`: mostra o código de retorno do último processo executado
    - **0** (zero) significa sucesso, **1** ou **2** geralmente erro
<br><br>

- `echo ~`: o `~` tem o home do usuário atual (caso usuário seja lpi1, retorna `/home/lpi1`)
- `echo ~lpi1`: retorna o home do usuário **lpi1** (retorna `/home/lpi1` - esse é ideal para ver de outros usuários, exemplo: `~root` retorna `/root`)

---

#### Comandos Sequenciais, history, man

- `ls ; date ; ls -la`: o `;` executa os comandos em sequência, independentemente se houver erro no comando
- `ls /tmp/teste && echo Linux`: somente executa o segundo comando se o primeiro tiver sido com **sucesso**
- `||` é o contrário de `&&`, ou seja, somente executa o segundo comando caso o primeiro dê erro. Caso o primeiro seja executado com sucesso (`return 0`), o segundo **NÃO** é executado.
<br><br>

- `history`: exibe todos os comandos já executados (**separado** por usuário, normalmente fica em `~/.bash_history`, e só o usuário dono que consegue vê-lo)
- `!!`: executa o último comando que foi executado. (repete o último comando)
- `!+num`, ou seja, `!21`, ou `!23`, ou `!24`, etc, executa o comando que aparece na lista do history (de acordo com o número)
- `!+string`: executa o comando que encontrou com a string descrita. Ex `!uname`
- `history -c`: limpa o arquivo de history
- `/String`: para pesquisar em arquivos man ou com comando `less`
- `history 20`: imprime as últimas vinte linhas do BD dinâmico de **history**, e do arquivo `.bash_history` (mesmo efeito com `tail -n 20 .bash_history`)

>[!NOTE]
>
>As últimas adições ao seu histórico de comandos **não** são gravadas no arquivo `.bash_history` até o encerramento da sessão.

- `man comando` ou `arquivo_de_configuracao` (alguns arquivos de configuração possuem manual também): manual do comando ou arquivo de configuração (alguns casos)

>[!NOTE]
>
>Alguns comandos são do bash (**comandos internos**), e não terão manual próprio, sendo necessário consultar o manual do bash (`man bash`). Ex. comando `alias`, `type`, `cd`.

>[!NOTE]
>
>`info` é um `man` reduzido. Ex. `info ls`

- `CTRL + R`: pesquisa comandos já digitados no histórico de comandos. Caso tenha mais comandos de acordo com a busca, basta ir apertando `CTRL + R`.
<br><br>

- `man -k "termo_pesquisa"` ou `--apropos`: para encontrar o comando desejado a partir de uma pesquisa. Ex. `man -k "update system"`: retorna o comando `fwupdate` (pesquisa  as  descrições  curtas  de  página  de manual  para  palavras-chave  e   exibe   quaisquer correspondências, por meio de uma base de dados)
    - `man -k "system information"`: retorna os comandos que têm alguma referência de informação do sistema: retorna os comandos `dumpe2fs`,`inxi` e `uname`
<br><br>

- `whatis`: parecido com o `man -k`. Explica o que é o comando, o que ele basicamente faz (exibe descrições de uma linha de páginas de manual). Ex. `whatis tar`: exibe: `The GNU version of the tar archiving utility`
- `apropos "update system"`: faz a busca do comando baseado na descrição (similar ao `man -k`)

>[!NOTE]
>
>O comando `apropos` é interessante para quando não lembramos o que comando que queremos, como por exemplo `uname`, para ver o kernel do sistema. Sabemos que o comando tem algo a ver com kernel, assim digitamos `apropos kernel`, que com certeza o comando `uname` será listado. Depois de achar o comando, é possível consultar seu manual com `man uname`. Caso queira uma descrição rápida, pode usar o comando `type`.

Exemplo: encontrar uma maneira de mostrar dispositivo de bloco físico conectado em bytes, ao invés de megabytes ou gigabytes:
```
$ apropis block
$ man lsblk
$ lsblk -b
```

---

#### uname e alias

- `uname`: imprime informações do sistema (**With no OPTION**, same as `-s`)
- `uname -s` ou `--kernel-name`: retorna o nome do kernel
- `uname -r` ou `--kernel-release`: retorna a versão do kernel
- `uname -a` ou `--all`: retorna todas as informações
- `uname -m` ou `--machine`: print the machine hardware name
- `uname -p` ou `--processor`: print the processor type (non-portable)
- `uname -i`, ou `--hardware-platform`: print the hardware platform non-portable)
- `uname -o` ou `--operating-system`: print the operating system
<br><br>
- `alias`: mostra os atalhos de comandos. Por exemplo, para criar um comando que liste o diretório `/tmp`, use `alias temp='ls /tmp'`, depois digite `temp`, que é o nome do alias.
- `unalias temp`: remove o alias criado anteriormente, chamado `temp`

>[!NOTE]
>
>O comando `alias` surte efeito apenas na sessão atual. Para deixar definitivo coloque as entradas desejadas em `.bashrc` do seu usuário local.

---

<a id="which"></a>

#### which

- `which`: retorna somente a localização absoluta de um comando. No caso, algum comando que esteja nos caminhos listados na variável `$PATH`. Ex. `which echo`: retorna que o echo está em `/bin/echo`
- `which uname which`: retorna: `/bin/uname` e `/usr/bin/which`

>[!NOTE]
>
>Se quiser exibir informações sobre comandos internos do shell (“builtin”), use o comando `help`

>[!NOTE]
>
>`which` foi lançado na versão 5 da LPI

---

#### Quoting

Em um comando `echo $TESTE`, a primeira coisa que o shell faz é interpretar as variáveis, para depois executar o comando.

Aspas duplas e simples são para proteger e impedir/controlar a interpretação das variáveis. 

- `echo *`: imprime todo conteúdo da pasta. Para **ignorar** a impressão usa-se `"*"` ou `'*'` (**protegem a interpretação do carácter especial**), poderia usar também `echo \*`, que protege **APENAS** o caractere seguinte. Outro Ex. `echo \*\$`
    - `""` As aspas duplas protegem **tudo**, **exceto**: `\` (barra invertida ou barra de *escape*), `$` (usado para variáveis) e `` ` `` (crase, usada para subcomandos), e, em certos casos, `!`
        - Ex. `echo "$TESTE"`: imprime o conteúdo da variável `TESTE`, nesse caso interpreta o `$`
    - `''` aspas simples já **não** protege.<br>
        - Ex. `echo '$TESTE'`: imprime `$TESTE` (não interpreta o `$`)
        - Ex. `echo \$TESTE`: tem o mesmo efeito, imprime `$TESTE`, pois `\` protege qualquer caractere a seguir

Se tentar imprimir dessa forma: <code>echo Curso &nbsp; &nbsp; &nbsp; Linux &nbsp; &nbsp; &nbsp; LPI-1</code> (sem aspas), o shell vai imprimir sem os espaços: `Curso Linux LPI-1`. Caso use as aspas, aí imprime com os espaços. Ou ainda se proteger os espaços com barra invertida: `Curso\ \ \  Linux\ \ \ LPI-1`

>[!NOTE]
>
>Essa proteção é chamada de **Quoting**

---

### 103.2 Processar fluxos de texto usando filtros

---

#### Aplicando Filtros a Textos e Arquivos - cat, head, tail, sort, less, wc, etc

- `cat alunos.txt`: pega o que tem em `alunos.txt` e joga na saída padrão. (se digita só `cat`, ele pegará o que foi digitado e exibirá na saída padrão. Se direcionar a saída com `>`, exemplo `cat > arquivo.txt`, tudo que digitar vai ser inserido em `arquivo.txt`)
- `cat -n alunos.txt` ou `--number`: exibe as linhas numeradas
- `cat -b alunos.txt` ou `--numer-nonblank`: mostra as linhas numeradas, mas se tiver linha em branco não numera. ( `-b`, `--number-nonblank` number nonempty output lines, overrides `-n`)
- `cat -s alunos.txt` ou `--squeeze-blank`: se tiver mais de uma linha em branco, suprime e deixa apenas uma linha em branco (suppress repeated empty output lines)
- `cat -A alunos.txt` ou `--show-all`: imprime os caracteres especiais que delimitam linhas ou codificação do arquivo. (equivalent to `-vET`)
    - `-v`, `--show-nonprinting`: use `^` and `M-` notation, except for LFD and TAB
    - `-E`, `--show-ends`: display `$` at end of each line
    - `-T`, `--show-tabs`: display `TAB` characters as `^I`

>[!TIP]
>
>Para comparar arquivos podemos usar o comando `diff`. Exemplo: `diff arquivo1.txt arquivo2.txt`, se não retornada nada, quer dizer que os arquivos possuem o mesmo conteúdo.

- `tac`: inverso do `cat`, imprime inversamente a saída do arquivo.
<br><br>

- `head`: mostra as 10 primeiras linhas de um arquivo
- `head -n2` ou `-2`: mostra as duas primeiras linhas
- `head -c50` ou `--bytes 50`: mostra os 50 primeiros bytes do arquivo
<br><br>

- `tail`: mostra as últimas 10 linhas de um arquivo
- `tail -5` ou `-n5`: mostra as últimas 5 linhas
- `tail -f arquivo.txt` ou `--follow`: lê as últimas linhas e fica aguardando alguma saída (algo que seja escrito no arquivo). Comando útil para leitura de log em tempo real. Pode intercalar com `-n` também.

---

#### Exercício interessante com `tail`

1. Enquanto monitora a saída de um comando `tail` no arquivo `/var/log/syslog`, insira um pendrive. Escreva o comando completo que usaria para obter o Produto (Product), o Fabricante (Manufacturer) e a quantidade total de memória (Blocks) do seu pendrive.

**Resposta:**

- `$ tail -f /var/log/syslog | grep -i 'product\:\|blocks\|manufacturer'`

O parâmetro `-i` com o comando `grep`, pois não sabemos se as strings que procuramos estão em maiúsculas ou minúsculas. Também usamos `|` como um `OR` (ou) lógico, então procuramos por linhas contendo **product** `OR` **blocks** `OR` **manufacturer**.

---
- `less`: faz a paginação de um arquivo (geralmente muito longo - `less` é uma evolução do `more`). 
    - mostra a primeira página e para. Se por seta para **baixo**/**cima**, navega no arquivo, assim como a tecla **Enter**. 
    - **barra de espaço** vai para próxima página. 
    - É possível fazer buscar com `/String` (**n**=próxima palavra, **N**=volta a busca)
    - `Ctrl + g`: mostra o status e onde está no arquivo
    - `q`: sai da paginação do `less`
<br><br>

- `wc`: imprime a quantidade de **linhas**, **palavras** e **bytes**. Normalmente 1 caractere é igual a 1 byte, mas caracteres especiais (`ç` `~``_` e etc) podem ter mais de um byte.
- `wc -l arquivo.txt` ou `--lines`: mostra apenas a quantidade de **linhas** 
- `wc -w arquivo.txt` ou `--words`: mostra apenas a quantidade de **palavras**
- `wc -c arquivo.txt` ou `--bytes`: mostra apenas a quantidade de **bytes**
- `wc -m arquivo.txt` ou `--chars`: mostra apenas a quantidade de **caracteres**
- `wc *`: roda o `wc` para todos os arquivos que se encontram no diretório atual e soma no final
<br><br>

- `nl`: similar ao `cat -b` (numera as linhas do arquivo, desconsiderando as linhas em branco - number lines of files)
<br><br>

- `sort arquivo.txt`: ordena o arquivo em ordem alfabética `a` ao `z` (se houver linhas em branco, essas irão para o **início**)
- `sort -r arquivo.txt` ou `--reverse`: ordena ao contrário, do `z` ao `a` (se houver linhas em branco, essas irão para o **final**)
- `sort -k2 arquivo.txt` ou `--key=KEYDEF`: ordena pelo segundo campo (um exemplo clássico seria ordenar pelo sobrenome)
    - é possível usar com o `cat`: `cat alunos.txt | sort -r`
- `sort -R arquivo.txt`: ordena aleatoriamente. Se usar com `head -1`, faz como se fosse um sorteio.

---

#### Exercício interessante de `sort`

1. O arquivo `/etc/passwd` contém a lista de usuários do Linux, os campos são separados pelo caractere `:`, o primeiro campo indica o nome do  usuário e o terceiro o ID do usuário.

Escreva um comando que mostre os últimos 15 registros do arquivo, exibindo apenas o nome do usuário e seu ID, e que esteja ordenado pelo  ID numérico. Por exemplo:
```
usuario1:10
usuario2:12
usuario:3:1000
```
**Resposta**: `tail -n 15 /etc/passwd | cut -d":" -f1,3| sort -t ":" -k2 -g`
- No comando `sort`:
    - O `-g`, `--general-numeric-sort`: compare according to general numerical value
    - O `-t`, `--field-separator=SEP`: use SEP instead of non-blank to blank transition<br>

2. Quantos usuários e grupos existem em seu sistema (lembre-se: use apenas o arquivo /etc/passwd)?

**Resposta**:
- usuários: `cut -d: -f3 /etc/passwd | sort -u | wc -l`
- grupos: `cut -d: -f4 /etc/passwd | sort -u | wc -l`

>[!NOTE]
>
>`-u`, `--uniq` (`sort`): with  `-c`, check for strict ordering; without `-c`, output only the first of an equal run

---

#### uniq, od, paste, split

- `uniq alunos.txt`: mostra as ocorrências únicas (não repetidas)

>[!IMPORTANT]
>
>`uniq` entende apenas uma linha após a outra. Caso haja repetição em linhas diferentes, acaba mostrando duas ou mais vezes. Interessante é usar um `sort` antes: `sort alunos.txt | uniq`

- `sort alunos.txt | uniq -d` ou `--repeated`: mostra apenas as linhas duplicadas (uma vez apenas)
- `sort alunos.txt | uniq -c` ou `--count`: conta quantas repetições há no arquivo (coloca o número de repetições na frente). Conta inclusive espaços em branco

---

- `od`: (dump files in octal and other formats)
- `od alunos.txt`: exibe em formato octal (mas mostra em outros tipos)
- `od -tx alunos.txt` ou `--format` para o `-t`: exibe em hexadecimal ( `-x`)
- `od -c alunos.txt`: mostra caracteres que não são normalmente visíveis que existem em arquivos, como os indicadores de [nova linha](#tr---opções-avançadas). A opção `-c`, de modo que, em vez de exibir a notação numérica para cada byte, as colunas serão mostradas como seus equivalentes em caracteres
<br><br>

---

- `join`: combina dois arquivos por meio de um índice.

Imagine dois arquivos, `codigo-aluno.txt` e `notas-aluno.txt`, tendo o respectivo conteúdo:

`codigo-aluno.txt`
```
1 Ana
2 Joao
3 Andre
4 Maria
5 Carlos
```
e `notas-aluno.txt`
```
1 10
2 8
3 9
4 2
5 0
```

- `join codigo-aluno.txt notas-aluno.txt`: vai interpretar que o primeiro campo é um campo de índice, exibindo a saída:
```
1 Ana 10
2 Joao 8
3 Andre 9
4 Maria 2
5 Carlos 0
```

>[!NOTE]
>
>Caso queira indicar outro campo compo índice, basta usar `join -j2 arq1.txt arq2.txt`
<br><br>

Comando similar é o `paste`, que pega linha a linha dos dois arquivos e exibe. Exemplo com os arquivos de teste feito no exemplo anterior: `paste codigo-aluno.txt notas-aluno.txt`, vai exibir:
```
1 Ana 1 10
2 Joao 2 8
3 Andre 3 9
4 Maria 4 2
5 Carlos 5 0
```

---

- `split`: divide um arquivo em vários outros. Supõe que temos um arquivo de 80 linhas.
- `split -l20 arquivolongo.txt` ou `--lines`: divide cada arquivo em 20 linhas. Criando os arquivos:
    - `xaa`
    - `xab`
    - `xac`
    - `xad`
- `split -l20 arquivolongo.txt novo_arquivo_`: divide da mesma forma que o exemplo anterior, mas cria os arquivos:
    - `novo_arquivo_aa`
    - `novo_arquivo_ab`
    - `novo_arquivo_ac`
    - `novo_arquivo_ad`

>[!TIP]
>
>Para confirmar a quantidade de linhas em cada arquivo, use `wc -l novo_arquivo_*`

>[!NOTE]
>
>O comando `split`, com a opção `-l`, pode ser omitido e colocado diretamente a quantidade de linhas: `split -20 arquivolongo.txt`

>[!NOTE]
>
>O comando `split`, se não usado nenhuma opção, por padrão divide o arquivo em vários outros arquivos de **1000** linhas cada
    
- `split -b100 arquivolongo.txt novo_arquivo_` ou `--bytes`: divide o arquivo a cada 100 bytes.

---

####  tr, cut e sed

- `tr`: pega um conteúdo de texto e substitui ou excluir algum caractere (precisa ser redirecionado/canalizado (*piping*), vindo de um `cat` por exemplo)
- `cat alunos.txt | tr a-z A-Z`: transforma toda letra minúscula em maiúscula.
- `cat alunos.txt | tr A E`: transforma toda letra `A` em `E`.
- `cat alunos.txt | tr ei EI`: transforma **SOMENTE** as letras `ei` minúsculo em `EI` maiúsculo (**NÃO** precisa estar junto o `ei`)
- `cat alunos.txt | tr [:upper:] [:lower:]`: transforma tudo que estiver em *upper* para *lower* (`tr --help` mostra outras opções)
- `cat alunos.txt | tr ' ' '_'`: sempre que tiver um espaço (`' '`), troca por um underline (`'_'`)
- `cat alunos.txt | tr -d 'A'` ou `--delete`: exclui toda letra `A` maiúscula que encontrar
- `cat alunos.txt | tr -d [:upper:]`: exclui toda letra maiúscula que encontrar
- `cat alunos.txt | tr -d [:blank:]`: exclui toda espaço em branco que encontrar
<br><br>

---

#### tr - opções avançadas
- `tr -s` ou `--squeeze-repeats`: retira partes repetidas em um conjunto de caracteres
- `echo "Curso de Liiiiinux | tr -s i`: exibe: `Curso de Linux`. (precisa informar após o `-s` qual caractere deseja remover as repetições)
- echo <code>"Curso de &nbsp;&nbsp;&nbsp; Linux" | tr -s " "</code>: deixa apenas um espaço em branco

Quanto às quebras de linhas tanto no Windows como no Linux, há algumas diferenças
- No Windows usa-se:
    - **LF** = Line Feed = Nova linha, que usa `\n`
    - **CR** = Carriage Return, que usa `\r`
- No Unix/Linux usa-se:
    - **LF**, com `\n`

No arquivo de texto, caso use `cat -A`, poderá ver as quebras, que podem ser:
- **Windows**: `^M` (usa tanto `\n` como `\r`)
- **Unix/Linux**: `$` (usa `\n` apenas)

No geral é para não ter muitos problemas com essas quebras de linha, no entanto pode acontecer se precisar converter esses formatos (se for de **CR-LF** para **LF**, basta remover o `\r`):

Considere dois arquivos, um gerado no windows e outro no Linux:  
`cat -A ArquivoGeradoLinux.txt`
```
Este arquivo foi gerado no Linux$
para exemplificar a aula sobre o comando tr$
no curso de LPIC-1$
```

`cat -A ArquivoGeradoWindows.txt`
```
Este arquivo foi gerado em^M$
um notepad simples do Windows^M$
para exemplificar a aula sobre o comando tr
```

É importante notar a diferença dos arquivos usando o comando `file ArquivoGerado*`, que retorna:
```
ArquivoGeradoLinux.txt:    ASCII text
ArquivoGeradoWindows.txt:    ASCII text, with CRLF line terminators
```

Para ver o `/r` e `/n` que são gerados no arquivo `ArquivoGeradoWindows.txt`, use o comando `od -c ArquivoGeradoWindows.txt` (mais sobre `od` [aqui](#uniq-od-paste-split)), tendo a seguinte saída (o `-c` de `od` significa: *select printable characters or backslash escapes*):
```
0000000   E   s   t   e       a   r   q   u   i   v   o       f   o   i
0000020       g   e   r   a   d   o       e   m  \r  \n   u   m       n
0000040   o   t   e   p   a   d       s   i   m   p   l   e   s       d
0000060   o       W   i   n   d   o   w   s  \r  \n   p   a   r   a
0000100   e   x   e   m   p   l   i   f   i   c   a   r       a       a
0000120   u   l   a       s   o   b   r   e       o       c   o   m   a
0000140   n   d   o       t   r
0000146
```

- `tr -d "\r" < ArquivoGeradoWindows.txt > NovoArquivo.txt`: retira o `\r` do arquivo que foi gerado no Windows e cria um novo arquivo com formato para Unix/Linux (**LF**). Dando um `cat -A` no arquivo pode-se notar a diferença:
```
Este arquivo foi gerado em$
um notepad simples do Windows$
para exemplificar a aula sobre o comando tr
```

---

- `cut`: para cortar partes de um texto

Considere o seguinte conteúdo do arquivo `alunos.txt`:
```
Paulo Freitas
Ana Claudia
Silvia Oliveira
Rafael dos Santos
```
- `cut -c1-5 alunos.txt` ou `--characters`: recorta os 5 primeiros caracteres, ficando a seguinte saída:
```
Paulo
Ana C
Silvi
Rafae
```
- `cut -c5-10 alunos.txt`: recorta do caractere 5 ao caractere 10, ficando a saída:
```
o Frei
Claudi
ia Oli
el dos
```
- `cut -c1,2,5 alunos.txt`: recorta os caracteres 1, 2 e 5, ficando a saída:
```
Pao
AnC
Sii
Rae
```

>[!IMPORTANT]
>
>Quando for range (`-c1-5`, por exemplo), pode usar `-c-5` que vai ter o mesmo efeito. Assim como se usar `-c5-`, que significa do caractere 5 pra frente

- `cut -b1-5 alunos.txt` ou `--bytes`: recorta os 5 primeiros **bytes**, ficando a seguinte saída:
```
Paulo
Ana C
Silvi
Rafae
```
>[!IMPORTANT]
>
>Como nesse caso cada byte é igual a um caractere, a saída será a mesma que utilizando `-c`

- `cut -d" " -f1 alunos.txt` ou `--delimiter`: delimita e extrai o campo 1 (`-f` ou `--fields`), cujo delimitador é o espaço em branco (`" "`), ficando a seguinte saída (como os nomes e sobrenomes são separados por espaço em branco, deve retornar apenas o primeiro nome):
```
Paulo
Ana
Silvia
Rafael
```

>[!IMPORTANT]
>
>Se houvesse um delimitador com `tab`, por exemplo, retornaria o nome completo, pois `tab` é diferente de espaço em branco.

>[!IMPORTANT]
>
>O `-f` pode ser usado com range também: `-f1-3`: do campo 1 ao campo 3. Ou a partir do caractere 2: `-f2-`. Ou também selecionando o campo 1 e 3: `-f1,3`

<br><br>

---

- `sed`: usado para procurar um conteúdo e substituir, e também para excluir alguma parte do texto
- `sed 's/Silva/Sousa/' alunos.txt`: substitui `Silva` por `Sousa`, apenas na primeira ocorrência que encontrar em cada linha.

Por exemplo, supondo que no arquivo `alunos.txt` temos o seguinte conteúdo:
```
Ana Claudia
Ana Claudia Vasconcelos Ana
```

Executando o comando `sed 's/Ana/Maria/' alunos.txt`, teremos a seguinte saída:
```
Maria Claudia
Maria Claudia Vasconcelos Ana
```

Na linha que tem duas ocorrências de `Ana`, apenas a primeira é substituída.

Para que tudo seja substituído, precisa usar a flag `g`, no final da delimitação de substituição (que transforma o comando em `global`):
- `sed 's/Ana/Maria/g' alunos.txt`, assim teremos a saída:
```
Maria Claudia
Maria Claudia Vasconcelos Maria
```

- `sed '3,5 d' alunos.txt`: apaga da linha 3 até a linha 5 (aqui dá impressão que é linha 3 **e** linha 5, mas o comando `sed` dessa forma funciona como se fosse um *range*)
- `sed '/Claudia/d' alunos.txt`: exclui a linha de todas as ocorrências que `Claudia` aparecer
- `sed -i.backup 's/Ana/Claudia alunos.txt'`: troca os nomes no arquivo `alunos.txt` e cria o arquivo `alunos.txt.backup`com o conteúdo inicial (A opção `-i` executa uma operação `sed` local no arquivo original. Se você não usar `.backup` após o parâmetro `-i`, vai reescrever o arquivo original. Qualquer texto inserido após o parâmetro `-i` será o nome com o qual o arquivo original será salvo antes das modificações que você pediu ao `sed` para realizar.)

---

#### Mais exemplos uso `sed`

A exclusão da primeira linha com o sed é realizada por `1d`:
```
$ factor `seq 12` | sed 1d
2: 2
3: 3
4: 2 2
5: 5
6: 2 3
7: 7
8: 2 2 2
9: 3 3
10: 2 5
11: 11
12: 2 2 3
```

Especificamos um intervalo de linhas com uma **vírgula** de separação:
```
$ factor `seq 12` | sed 1,7d
8: 2 2 2
9: 3 3
10: 2 5
11: 11
12: 2 2 3
```

Mais de uma instrução pode ser usada na mesma execução, separadas por **ponto e vírgula**. Nesse caso, no entanto, é importante colocá-las entre **parênteses** para que o ponto e vírgula não seja interpretado pelo shell:
```
$ factor `seq 12` | sed "1,7d;11d"
8: 2 2 2
9: 3 3
10: 2 5
12: 2 2 3
```

Neste exemplo, duas instruções de exclusão foram executadas, primeiro nas linhas que vão de 1 a 7 e depois na linha 11. Um endereço também pode ser uma expressão regular, portanto, apenas as linhas correspondentes serão afetadas pela instrução:
```
$ factor `seq 12` | sed "1d;/:.*2.*/d"
3: 3
5: 5
7: 7
9: 3 3
11: 11
```

A expressão regular `:.*2.*` corresponde a qualquer ocorrência do número 2 em qualquer lugar depois de dois pontos, provocando a exclusão das linhas correspondentes aos números que tenham 2 como fator. Com o `sed`, qualquer coisa colocada entre barras (`/`) é considerada uma expressão regular e, por padrão, todas as ER básicas são suportadas. Por exemplo, `sed -e "/^#/d" /etc/services` mostra o conteúdo do arquivo `/etc/services` sem as linhas que começam com `#` (linhas de comentário).

A instrução de exclusão `d` é apenas uma das muitas instruções de edição fornecidas pelo `sed`. Em vez de excluir uma linha, o `sed` pode substituí-la por um texto determinado:
```
$ factor `seq 12` | sed "1d;/:.*2.*/c REMOVED"
REMOVED
3: 3
REMOVED
5: 5
REMOVED
7: 7
REMOVED
9: 3 3
REMOVED
11: 11
REMOVED
```

A instrução `c REMOVED` simplesmente substitui uma linha pelo texto `REMOVED`. No caso do exemplo, cada linha com uma substring correspondente à expressão regular `:.*2.*` é afetada pela instrução `c REMOVED`. 

A instrução `a TEXT` copia o texto indicado por `TEXT` para uma nova linha após a linha com uma correspondência. 

A instrução `r FILE` faz o mesmo, mas copia o conteúdo do arquivo indicado por `FILE`. A instrução `w` faz o oposto de `r`, ou seja, a linha será anexada ao arquivo indicado.

De longe, a instrução mais usada do `sed` é `s/FIND/REPLACE/`, que é usada para substituir uma correspondência da expressão regular `FIND` pelo texto indicado por `REPLACE`. Por exemplo, a instrução `s/hda/sda/` substitui uma substring que corresponde à ER literal `hda` por `sda`. Apenas a primeira correspondência encontrada na linha será substituída, a menos que o sinalizador `g` seja colocado após a instrução, como em `s/hda/sda/g`.

---

#### Exercício interessante sobre `sed`

1. Gere um comando, ou sequência deles, que mostre o número de linhas do arquivo `/etc/passwd` excluindo-se as linhas que contenham a palavra  "daemon". O resultado do comando deve ser o número de linhas.

**Resposta**: `sed '/daemon/d' /etc/passwd| wc –l` ou `grep -v daemon /etc/passwd | wc –l`

>[!NOTE]
>
>O `grep -v` ou `--invert-match` é o que exclui a linha quando acha ocorrências (e exibe o restante)

2. Alguém acaba de doar um laptop para sua escola e você deseja instalar Linux nele. Ele veio sem manual e você é obrigado a inicializá-lo a partir de um pen drive USB sem nenhuma interface gráfica. Aparece um terminal shell e você sabe que, para cada processador presente, haverá uma linha dedicada no arquivo `/proc/cpuinfo`:
```
processor	: 0
vendor_id	: GenuineIntel
cpu family	: 6
model		: 158

(linhas puladas)

processor	: 1
vendor_id	: GenuineIntel
cpu family	: 6
model		: 158

(more lines skipped)
```
Usando os comandos `grep` e `wc`, exiba o número de processadores presentes:

**Resposta**: `grep processor /proc/cpuinfo | wc -l`

Faça o mesmo com `sed` em vez de `grep`:

**Resposta**: `sed -n /processor/p /proc/cpuinfo | wc -l`

>[!NOTE]
>
>`sed` com o parâmetro `-n` para que `sed` não imprima nada, exceto o que corresponde à expressão processor, conforme instruído pelo comando `p`

3. Liste apenas a primeira, a última e a décima linha do arquivo `/etc/passwd`

**Resposta:** `sed -n -e '1'p -e '10'p -e '$'p /etc/passwd`

>[!NOTE]
>
>o parâmetro `-n` diz ao `sed` para não imprimir nada além do que é especificado pelo comando `p`. O cifrão (`$`) usado aqui é uma expressão regular que representa a última linha do arquivo.

>[!NOTE]
>
>`-e` script, `--expression=script`: add the script to the commands to be executed

---

#### xzcat, bzcat e zcat

Crie os arquivos compactados com os comandos (esses comandos na realidade são diferentes algoritmos de compactação):
- `xz -k arquivolongo.txt` ou `--keep`
- `bzip2 -k arquivolongo.txt` ou `--keep`
- `gzip -k arquivolongo.txt` ou `--keep`

Para consultar os tipos de compactação, use: `file arquivolongo.txt*`, que resulta na saída:
```
arquivolongo.txt:     ASCII text
arquivolongo.txt.bz2: bzip2 compressed data, block size = 900k
arquivolongo.txt.gz:  gzip compressed data, was "arquivolongo.txt", last modified: Sat Dec 28 23:55:42 2024, from Unix, original size modulo 2^32 59
arquivolongo.txt.xz:  XZ compressed data, checksum CRC64
```

Um `cat` no arquivo compactado `NÃO` exibirá seu conteúdo, mostrará apenas o binário do arquivo (pois foi compactado). E é interessante ler o arquivo que está compactado sem ter que descompactar o arquivo (internamente acaba descompactando, mas agiliza usar os comandos de leitura), logo para cada tipo de compressão, há um comando para leitura:
- para **.xz**: `xzcat arquivolongo.txt.xz`
- para **.gzip**: `zcat  arquivolongo.txt.gz`
- para **.bzip2**: `bzcat  arquivolongo.txt.bz2`

---

#### checksums (hashes)

- `md1sum` (mais antigo):
- `md5sum` (mais antigo):
- `sha256sum` (mais moderno - usa 256 bits para criação da hash):
- `sha512sum` (mais moderno e seguro - usa 512 bits):

Exemplos

- `sha256sum ubuntu.iso`: gera uma hash para o arquivo `ubuntu.iso` (**hash**=sequencia de caracteres **única** para o arquivo `ubuntu.iso` - qualquer mudança no arquivo, a **hash** será alterada)

É interessante para download de `.iso`, o qual normalmente disponibiliza um arquivo com os **checksums** de cada versão de arquivos `.iso`

A comparação pode ser a olho, ou pelo comando `sha256sum -c SHA256SUMS` ou `--check`, sendo `SHA256SUMS` o arquivo que contém os checksums das `.iso`, e o comando returna `OK` se estiver correto (mensagem de erro é algo parecido com isso `sha256sum: WARNING: 1 computed checksum did NOT match`)

---

### 103.3 Gerenciamento básico de arquivos

#### cd, ls, file

- `cd /home/lpi1`: entra na pasta `/home/lpi1`
- `cd ..`: volta um nível no diretório
- `cd -`: volta no diretório anterior
- `cd ~`: vai para o `/home` do usuário que está logado
- `cd ../..`: volta dois níveis nas pastas
---

- `ls -l`: lista detalhada, tendo os campos:
    1. tipo do arquivo + permissão
        - `-`: arquivo regular
        - `d`: diretório
        - `c`: arquivo especial
    2. quantidade de hard links
    3. usuário dono do arquivo/diretório
    4. grupo dono do arquivo/diretório
    5. tamanho em bytes
    6. data/hora da última alteração do arquivo/diretório
    7. nome do arquivo

>[!NOTE]
>
> Quando não é especificado o diretório ou arquivo a ser listado, o diretório atual fica implícito.

- `ls -la`: lista detalhada e mostra arquivos ocultos. Repare que no início da lista mostra `.` e `..`. 
    - O ponto `.` se refere ao **diretório atual**. 
    - E os dois pontos `..` se refere ao **diretório anterior**.
- `ls -h` ou `--human-readable`: mostra valores mais fácil para humanos lerem (transforma bytes em KBytes/MBytes, etc)
- `ls -lR` ou `--recursive`: entra em cada diretório recursivamente mostrando que tem dentro de cada um

>[!NOTE]
>
>A adição de barra no diretório não tem efeito. `ls -R curso` é **igual** a `ls -R curso/`

---

<a id="fileglobbing"></a>

#### globbing de arquivos e caracteres curinga

O *globbing* de arquivos é um recurso fornecido pelo shell do Unix/Linux para representar múltiplos nomes de arquivo usando caracteres especiais chamados caracteres curinga.

---

#### Tipos de caracteres curinga

Existem três caracteres que podem ser usados como curingas no Linux:

- `*` (asterisco)
representa zero, uma ou mais ocorrências de qualquer caractere.

- `?` (interrogação)
representa uma única ocorrência de qualquer caractere.

- `[ ]` (caracteres entre colchetes)
representa qualquer ocorrência do(s) caractere(s) inseridos nos colchetes. É possível usar diferentes tipos de caracteres, sejam números, letras ou outros caracteres especiais. Por exemplo, a expressão `[0-9]` representa todos os dígitos.

- `ls -l Aula1*`: traz tudo que houver com o nome `Aula1`+`qualquer coisa`, inclusive o arquivo `Aula1` se houver
- `ls -l Aula1?`: `?` substitui um caractere, exigindo que tenha uma letra/número no seu lugar (não retorna o arquivo `Aula1`, pois é exigido que tenha um caractere no seu lugar)
- `ls -l Aula?0`: mesmo esquema do anterior, nesse caso vai listar os arquivos `Aula10`, `Aula20`, `Aula30`, etc.
- `ls -l Aula[123]`: lista apenas os arquivos `Aula1`, `Aula2` e `Aula3`
- `ls -l Aula[!123]`: não mostra `Aula1`, `Aula2` e `Aula3`, mostra apenas `Aula4`, `Aula5` e `Aula6`
- `ls -l Aula[1-5]`: mostra da mesma forma que a anterior, mas com range (pode negar também com `!`)
- `ls -l Aula[1-5]?`: mostra os arquivos e que tenha alguma coisa após o range.
- `ls -l Aula{10,20,30}`: especifica qual string que deseja. Nesse caso retorna `Aula10`, `Aula20` e `Aula30`
- `ls -l A{ula,ULA}`: mostra tanto `Aula` como `AULA`

>[!TIP]
>
>Para facilitar a leitura de uma estrutura de diretório, use o comando `tree diretorio`.

---

- `file arquivo`: analisa e retorna o que é o arquivo
- `file alunos.txt`: retorna que é um `UTF-8 Unicode text`
- `file script.sh`: retorna que é um `Bourne-Again shell script, UTF-8 Unicode text executable`
- `file aula`: (supõe que o arquivo `aula` está vazio), retorna `empty`
---

#### touch, cp, mv

- `cp alunos.txt /tmp`: copia o arquivo `alunos.txt` para o diretório `/tmp`
- `cp -i alunos.txt /tmp` ou `--interactive`: caso já haja o arquivo no destino, pergunta se quer sobrescrever.
- `cp Diretorio1/ /tmp`: se tentar copiar um diretório vai dar erro (sem a opção `-r`). Precisa usar a opção `-r` ou `--recursive`
- `cp -p Aula8 /tmp/`: preserva ownership e timestamps. Sem o `-p` vai fazer como se criasse um novo arquivo, mudando timestamp e ownership caso outro usuário copiasse o arquivo (same as `--preserve`=mode,`ownership`,`timestamps`)
- `cp Aula1 Curso1`: cria uma cópia de `Aula1` com nome de `Curso1` (copia e muda o nome)
---
- `mv`: move arquivos, é bem parecido com `cp`, não tem as opções `-R` ou `-r` e o `-p`. O `cp` mantém o arquivo de origem, já o `mv` remove.
- `mv Aula1 Curso2`: renomeia `Aula1` para `Curso2` (internamente é como se recortasse `Aula1` e colasse `Curso2` - lembrar que `mv` não mantém a origem) - Tomar **CUIDADO** para sobrescrever o arquivo, correto seria usar com `-i`
- `mv -f Aula1 Curso2` (ou `--force`): caso já exista o arquivo `Curso2`, nem avisa que vai sobrescrever (sobrescreve à força, sem pedir permissão).
- `mv file1 file2 -t exercises/` ou `--target-directory=DIRECTORY`: move ambos arquivos, `file1` e `file2` para o diretório `exercises`
---
- `touch`: serve para criar arquivos (vazio) ou mudar o timestamp dele.
- `touch linux.txt`: cria o arquivo `linux.txt` (vazio). Pode criar vários ao mesmo tempo: `touch file1 file2 file3`
- `touch arquivo.txt`: supondo que `arquivo.txt` já exista, esse comando atualiza a data/hora da última modificação do arquivo.
- `touch -a arquivo.txt`: altera a data do **último acesso** apenas
- `touch -m arquivo.txt`: altera a data da **última modificação** apenas
- `touch -t 201712241000 Aula30`: altera o timestamp do arquivo `Aula30` para às **10h** do dia **24/12/2017**

---

#### rm, mkdir, rmdir, find


- `rm Aula1`: remove o arquivo Aula1, sem perguntar
- `rm -i Aula1`: remove o arquivo Aula1, perguntando se deseja realmente remover
- `rm -r Diretorio/`: para remover diretórios, precisa usar a opção `-r` (remove tudo que estiver no diretório - sem o `-r` não remove, informando que é um diretório)
- `rm Aula1 Aula2 Aula3`: remove três arquivos de uma vez

>[!WARNING]
>
>Tenha muito cuidado com o `-r` ou a combinação de opções de `-rf` quando usá-lo com o comando `rm`. Um comando de remoção recursivo em um diretório de sistema importante pode tornar o sistema inutilizável. Empregue o comando de remoção recursiva somente quando tiver certeza absoluta de que o conteúdo de um diretório pode ser removido do computador com segurança.

---

- `rmdir`: remove diretório (apenas diretórios **VAZIOS** - se tiver arquivo, dá o erro: `Directory not empty`)
    - Caso tenha uma estrutura de pastas seguidas e vazias, pode usar `rmdir -p` ou `--parents` para remover de uma vez. Ex. `rmdir -p Curso/LPI/V1` (desde que todas **VAZIAS**)

---

- `mkdir Linux`: cria o diretório `Linux`
- `mkdir Linux/Ubuntu`: complementando o comando anterior, cria a pasta `Ubuntu`, dentro da pasta `Linux`
    - Se tentar criar uma estrutura que a primeira pasta ainda não existe, como `mkdir Curso/LPI/V1`, vai dar erro.
- `mkdir -p Curso/LPI/V1` ou `--parents`: contorna o erro citado anteriormente e cria a estrutura desejada.

---

<a id="find"></a>

- `find`: usado para procurar arquivos e diretórios no sistema (sintaxe: `find onde_procurar o_que_procurar`)
- `find /home -name Aula10`: procura em `/home` pelo arquivo `Aula10`
- `find /home -name Aula*`: procura em `/home` tudo que começa com `Aula` e termine com qualquer coisa
- `find /home -user lpi2`: procura tudo (arquivos e diretórios) que o dono seja o usuário `lpi2`
- `find /home -user lpi2 -name Aula2`: busca em `/home` o arquivo que se chame `Aula2` e que o dono seja `lpi2`
- `find ./ -ctime -1`: procura no diretório que está atualmente tudo que foi alterado há 1 dia

---

#### critérios para acelerar a pesquisa

- `type f`: busca por arquivos
- `type d`: busca por diretórios
- `type l`: busca por links simbólicos

Exemplo: `find . -type d -name "example"`: procura por todos os diretórios, no diretório atual e abaixo dele, que tenham o nome `example`

Dentre os critérios que podem ser usados com `find` temos:
- `-name`: pesquisa com base no nome fornecido
- `-iname`: pesquisa com base no nome, desconsiderando maiúsculas e minúsculas (sendo, por exemplo, `myFile` = a `MYFILE`)
- `-not`: retorna os resultados que não correspondem ao caso de teste
- `-maxdepth N`: pesquisa no diretório atual, além dos subdiretórios de `N` níveis de produndidade.

---

#### busca com base em quando o arquivo foi modificado

Exemplo: `sudo find / -name "*.conf" -mtime 7`: procura por todos os arquivos em todo o sistema de arquivos (pois começa em `/`), que terminam com os caracteres `.conf` e que foram modificados na base da estrutura de diretórios do sistema (por isso deve usar `sudo`). O argumento `mtime` representa o número de dias desde a última modificação do arquivo

**Observação importante**: argumentos numéricos `n` podem ser especificados para testes (como `-amin`, `-mtime`, `-gid`, `-inum`, `-links`, `-size`, `-uid` e `-used`) da seguinte forma:
- `+n`: para maiores que (greater than) `n`
- `-n`: para menores que (less than) `n`
- `n`: pra exatamente `n`

---

#### localizando arquivos por tamanho

Exemplo: `sudo find /var -size +2G`: procura por arquivos maiores que **2G** em `/var`

A opção `-size` exibe arquivos de tamanhos correspondentes ao argumento passado, vejamos alguns exemplos:
- `-size 100b`: arquivos com exatamente **100 bytes**
- `-size +100k`: arquivos menores que **100 kilobytes**
- `-size -20M`: arquivos menores que **20 megabytes**
- `-size +2G`: arquivos maiores que **2 gigabytes**

>[!NOTE]
>
>Para encontrar arquivos vazios, podemos usar: `find . -size 0b`  ou  `find . -empty`

---

#### Manipular os resultados do `find`

Uma vez que a pesquisa é feita, é possível realizar uma ação no conjunto de resultados usando `-exec`:

Exemplo
```
find . -name "*.conf" -exec chmod 644 '{}' \;
```
Esse comando filtra todos os objetos no diretório atual (`.`) e abaixo dele para nomes de arquivo terminando com `.conf` e em seguida executa o comando `chmod 644` para modificar as permissões de arquivo nos resultados.

Outro exemplo:
```
find . -type f -exec grep "lpi" '{}' \; -print
```

Esse comando busca, na hierarquia de diretórios atual (`.`), por objetos que são arquivos (`-type f`) e em seguida executa o comando `grep "lpi"` para cada arquivo que satisfaça as condições. Os arquivos que atendem a essas condições são impressos na tela (`-print`). As chaves (`{}`) servem para reservar o espaço para os resultados encontrados por `find`. As `{}` são postas entre aspas simples (`'`) para evitar passar arquivos com nomes contendo caracteres especiais para o `grep`. O comando `-exec` é concluído com um ponto e vírgula (`;`), que deve ser escapado (`\;`) para não ser interpretado pelo shell.

Mais um exemplo, agora usando `-delete`
```
find . -name "*.bak" -delete
```

A opção `-delete`, se colocada no final de uma expressão, excluiria todos os arquivos correspondentes à descrição. Esta opção deve ser usada quando você tiver certeza de que os resultados correspondem apenas aos arquivos que deseja excluir.

No exemplo abaixo, `find` localiza todos os arquivos na hierarquia começando no diretório atual e, em seguida, exclui todos os arquivos que terminam com os caracteres `.bak`

---

#### Exercício interessante sobre `find`

1. O administrador do sistema precisa realizar verificações regulares para remover arquivos volumosos. Esses arquivos volumosos estão localizados em `/var` e terminam com uma extensão `.backup`.

Escreva o comando, usando `find`, para localizar esses arquivos:
```
$ find /var -name *.backup
```

Uma análise do tamanho desses arquivos revela que eles variam de `100M` a `1G`. Complete o comando anterior com esta nova informação para poder localizar os arquivos de backup variando de `100M` a `1G`:
```
$ find /var -name *.backup -size +100M -size -1000M
```

Finalmente, complete este comando com a ação `delete` para remover esses arquivos:
```
$ find /var -name *.backup -size +100M -size -1000M -delete
```

2. Encontre todos os arquivos do diretório `/var`, cujo nome termine com `.gz` e que foram modificados nas últimas `48 horas`:
```
# find /var -name “*gz” -mtime -2
```

`mtime` refere-se ao *modification time*. Para evitar as mensagens de erro referentes a
permissões de leitura, é melhor executar como root.

---

#### tar, gzip, bzip2, xz (agrupar e comprimir arquivos)

**Agrupando** arquivos:

- `tar cpvf backup.tar novo*`: agrupa (**não compacta**) todo arquivo que comece com a palavra `novo` e termine com qualquer coisa no arquivo `backup.tar`. Mantendo as permissões (`-p`) (**sempre** precisa usar o `-f` ou `--file`, para criar o arquivo `.tar` desejado)
    - `-c` ou `--create`
    - `-p` ou `--preserve-permissions`, `--same-permissions`
    - `-v` ou `--verbose`
- `tar tf backup.tar`: lista o que há dentro do agrupamento criado anteriormente.
    - `-t` ou `--list`

**Desagrupando**:

- `tar -xvf backup.tar` ou `--extract`, `--get`: desagrupa o arquivo `backup.tar`
- `tar -xvf backup.tar -C /tmp`: desagrupa no diretório `/tmp` (pode usar `-C` ou `--directory`)

>[!NOTE]
>
>Pode escolher o arquivo a ser desagrupado do agrupamento: `tar -xf backup.tar file1`: nesse caso desagrupa apenas o arquivo `file1`. Se não informar, desagrupa tudo.

**Compactando** (são **3** opções principais: `gzip`, `bzip2` e `xz`):

---

#### gzip

- `gzip backup.tar`: cria o arquivo `backup.tar.gz`, mas exclui o arquivo de origem, `backup.tar` (para manter, use o `-k` ou `--keep`)
- `gunzip backup.tar.gz`: descompacta, ou seja, volta o arquivo ser `backup.tar` e exclui o arquivo original, `backup.tar.gz` (para manter o arquivo, use `-k` ou `--keep`)
- `gzip -d backup.tar.gz` ou `--decompress`, `uncompress`: faz o mesmo que o comando anterior.

---

#### bzip2

- `bzip2 -k backup.tar`: cria o arquivo `backup.tar.bz2` mantendo (`-k`) o arquivo `backup.tar`
- `bunzip2 backup.tar.bz2`: descompacta
- `bzip2 -d backup.tar.bz2` ou `--decompress`: também descompacta
    - para manter o arquivo, use o `-k` ou `--keep`

---

#### xz

- `xz -k backup.tar`: compacta e cria o arquivo `backup.tar.xz`, mantendo (`-k`) o arquivo `backup.tar`
- `unxz backup.tar.bz2`: descompacta
- `xz -d backup.tar.bz2` ou `--decompress`: também descompacta
    - para manter o arquivo, use o `-k` ou `--keep`

---

#### Resumo
| compactar  | descompactar  | descompactar  |
|---|---|---|
| gzip  | gunzip  | gzip -d  |
| bzip2  | bunzip2  | bzip2 -d  |
| xz  | unxz  | xz -d  |

---

#### uso mais comum no dia a dia

É interessante quando for compactar, empacotar e compactar usando o mesmo comando:

- `tar -cvpf backup.tar novo*`: comando já visto que empacota tudo que começa com `novo` e termina com qualquer coisa, no arquivo `backup.tar`. A depender do algoritmo de compressão, mude o seguinte:
    - `tar -zcvpf backup.tgz novo*` ou `--gzip`, `--gunzip`, `--ungzip`: empacota e compactar com `gzip`
    - `tar -jcvpf backup.tbz novo*` ou `--bzip2`: empacota e compactar com `bzip2`
    - `tar -Jcvpf backup.txz novo*` ou `--xz`: empacota e compactar com `xz`

Para extrair, precisa apenas substituir o `-c` por `-x`, que vem de "extract".

| gzip  | bzip2  | xz  |
|---|---|---|
| z | j | J |

>[!NOTE]
>
>O `gzip` é mais rápido, mas geralmente compacta um pouco menos, de modo que o arquivo obtido é um pouco maior. O `bzip2` é mais lento, mas comprime um pouco mais, então o arquivo fica um pouco menor. Em geral, porém, `gzip` e `bzip2` são praticamente a mesma coisa; ambos funcionam de forma semelhante.

>[!NOTE]
>
>É interessante renomear usando o padrão acima, `.tgz` para `gzip`. `.tbz` para `bzip2` e `.txz` para `xz`

>[!TIP]
>
>Para saber como os arquivos foram comprimidos, use o comando `file`

**Descompactando**:

Vamos considerar os arquivos que foram diretamente compactados, do último exemplo:

- `tar zxvf backup.tgz`: descompacta o arquivo `backup.tgz` oriundo do algoritmo `gzip`.
    - importante notar o `x` (pode ser `--extract` ou `--get` também). O `z` é referente ao algoritmo, igual na compactação.
- `tar jxvf backup.tbz`: descompacta usando `bzip2`
    - `j`=bzip2
- `tar Jxvf backup.txz`: descompacta usando `xz`
    - `J`=xz

---

<a id="cpio"></a>

#### cpio, dd (agrupar e compactar arquivos também)

- `cpio`: é um agrupador/empacotador, que recebe uma lista de arquivos (geralmente pelo comando `find` ou `ls`) e cria um agrupamento (significa “copy in, copy out”)
- **agrupar**: `find ./ -name "novo*" | cpio -o > backup.cpio` (pode usar `-o` ou `--create`): cria um arquivo de backup chamado `backup.cpio` com os arquivos listados com o comando `find`
- **desagrupar**: `cpio -i < backup.cpio` (`-i` ou `--extract`). Pode ser necessário usar a opção `-d`, `--make-directories`, caso dê erro de criação de diretórios.

Mesmo jeito com `ls`:
- `ls | cpio -o > archive.cpio`: a opção `-o` instrui o cpio a criar uma saída. Neste caso, o arquivo de saída criado é `archive.cpio`. O comando `ls` lista o conteúdo do diretório atual que será empacotado.
- `cpio -id < archive.cpio`: a opção `-i` é usada para realizar a extração. A opção `-d` cria a pasta de destino. O caractere `<` representa a entrada padrão. O arquivo de entrada a ser extraído é `archive.cpio`
<br>

- **compactar**: `find ./ -name "novo*" | cpio -o | gzip > backup.cpio.gz`: agrupa e compacta.
- **descompactar**: `gunzip -c | cpio -i` (`-c`, `--stdout` ou `--to-stdout`): descompacta e desagrupa

---

- `dd`: usado para copiar uma partição inteira. Sendo copiar uma partição inteira para outra partição, para um arquivo ou realizar o contrário (imagem para partição) - sintaxe: `dd if=oldfile of=newfile`
    - `if=`: é o arquivo de entrada
    - `of=` refere-se ao arquivo de saída.
- `dd if=/dev/sr0 of=imagem.img`: copia e cria uma imagem do que tiver no CD-ROM para o arquivo `imagem.img` (pode copiar para outra partição)

>[!NOTE]
>
>O comando `dd` normalmente não exibe nada na tela até que o comando seja concluído. Ao fornecer a opção `status=progress`, o console exibe o andamento do trabalho realizado pelo comando. Por exemplo: `dd status=progress if=oldfile of=newfile.`

---

### 103.4 Usando fluxos, pipes e redirecionamentos

#### Redirecionamentos entrada/saida/erro, | (pipe)

`STDIN (0)` => Program => `STDOUT (1)` Sucesso ou `STDERR (2)` Erro

- `STDIN (0)` entrada (geralmente teclado)
- `STDOUT (1)` saída sucesso (geralmente monitor)
- `STDERR (2)` saída erro (geralmente monitor)

Os canais de comunicação também são acessíveis por meio dos dispositivos especiais `/dev/stdin`, `/dev/stdout` e `/dev/stderr`

---

#### operador >

Esse operador redireciona a saída padrão. Normalmente a saída padrão será a **tela**. No entanto se quiser mudar essa saída, usa `>`, para redirecionar para um arquivo, por exemplo.

---

#### redirecionando saída (sucesso)

- `ls`: a saída vai para tela
- `ls > saida_ls.out`: a saída é redirecionada para um arquivo (não aparece nada na tela)

>[!NOTE]
>
>Se usar apenas `>` em um arquivo com conteúdo, vai apagar o conteúdo e escrever a saída do comando executado. Para não apagar, usar `>>`, que vai concatenando (append) com o conteúdo que já tiver.

>[!IMPORTANT]
>
>Na realidade quando usamos `>` ou `>>`, estamos fazendo implicitamente `1>` ou `1>>`, que no caso significa `STDOUT (1)`. Se quiser pode usar `1>` ou `1>>` normalmente, mas lembrar que **pode ser omitido** sem problemas.

---

#### redirecionando saída (erro)

Caso tente `ls -l /tmp/arquivo_inexistente` e realmente o arquivo `arquivo_inexistente` não existir, vai retornar uma mensagem de erro.

Se tentar redirecionar para um arquivo, como em `ls -l /tmp/arquivo_inexistente > saida_erro_ls.out`, o arquivo ficará em branco, e o erro vai continuar usando a saída do monitor.

Para redirecionar saída de erro `STDERR (2)`, temos que usar: `ls -l /tmp/arquivo_inexistente 2> saida_erro_ls.out`. Podemos usar `2>>` também. Aqui já não é possível omitir o número, tem que colocar `2>` ou `2>>`.

---

#### redirecionamento saída (sucesso e erro)

Agora supomos que no diretório atual tenha o arquivo `Aula3` apenas, e ao executar `ls -l {Aula,AULA}3`, que em tese tenta listar `Aula3` e `AULA3`. No entanto sabemos que `AULA3` não existe, retornando uma saída de **sucesso** e uma de **erro**:
```
$ ls -l {Aula,AULA}3
ls: cannot access 'AULA3': No such file or directory
-rw-rw-r-- 1 rodrigo rodrigo 0 Jan  9 20:07 Aula3
```

Para que seja possível redirecionar o sucesso e o erro, usamos: `ls -l {Aula,AULA}3 > saida_sucesso.out 2> saida_erro.out` (cada saída irá para seu respectivo arquivo)

É possível ainda redirecionar tanto sucesso como erro em um único arquivo, usando: `ls -l {Aula,AULA}3 > saida.out 2>&1`

>[!NOTE]
>
>É possível usar também `ls -l {Aula,AULA}3 &> saida.out`. Tem o mesmo efeito que o comando da linha acima.

**Observação importante**: Supõe que temos um arquivo com os nomes dos alunos, chamado `alunos.txt`. Então desejamos ordenar os nomes, usando o comando `sort`, dessa forma: `sort alunos.txt > alunos.txt`, a ordenação vai funcionar?

É importante destacar que ao usar `> alunos.txt`, o shell entende esse comando como a criação do arquivo `alunos.txt`, logo ele vem zerado de informação (0 bytes). Depois que o shell vai se preocupar com a ordenação, mas como já criou o arquivo `alunos.txt` "vazio" (que inclusive sobrescrever o arquivo `alunos.txt` original), não há mais o que ordenar. Logo, realizar o comando `sort alunos.txt > alunos.txt`, acaba que perdendo os dados, e é preciso tomar muita cautela com execução de comando assim.

Os arquivos são substituídos pelos redirecionamentos de saída, a menos que a opção `noclobber` esteja habilitada no Bash, o que pode ser feito para a sessão atual com o comando `set -o noclobber` ou `set -C`:

```
$ set -o noclobber
$ cat /proc/cpu_info 2>/tmp/error.txt
-bash: /tmp/error.txt: cannot overwrite existing file
```

Para remover a opção noclobber da sessão atual, execute set `+o` noclobber ou set `+C`. Para tornar a opção noclobber persistente, ela deve ser incluída no perfil Bash do usuário ou no perfil de todo o sistema.

O correto é realizar esse comando para um arquivo temporário, e posteriormente copiar para o arquivo original (ou simplesmente renomear)

---

#### redirecionar a entrada

Em situação mais corriqueira, usaríamos:
- `cat alunos.txt | tr 'a-z' 'A-Z'`: deixa tudo com letra maiúscula (redireciona a saída do comando `cat` para `tr` - conhecido como canalização)
- `tr 'a-z' 'A-Z' < alunos.txt`: joga `alunos.txt` como entrada para o comando `tr`

Como o valor numérico do descritor de arquivo redirecionado foi suprimido, o comando de exemplo é equivalente a `tr 'a-z' 'A-Z' 0< alunos.txt`

O uso de um descritor de arquivo diferente de `0` em um redirecionamento de entrada só faz sentido em determinados contextos, porque um programa pode possivelmente solicitar dados dos descritores `3`, `4`, etc. De fato, os programas podem usar qualquer número inteiro maior que `2` como novos descritores de arquivo para entrada/saída de dados.

---

#### tee, xargs, subcomandos

- `tee`: usado para situações que queira jogar a saída padrão para um arquivo e na tela, ao mesmo tempo.

Em situação para jogar a saída padrão para apenas um arquivo, usaríamos: `ls -l /tmp > arquivo`. Mas caso queira que também a saída padrão seja na tela (além do arquivo), use: `ls -l /tmp | tee arquivo`.

- `grep 'model name' </proc/cpuinfo | uniq | tee -a cpu_model.txt`: o `-a` ou `--append` do comando `tee` funciona como o operador `>>`, para evitar que o que foi redirecionado sobrescreva o arquivo

---

<a id="xargs"></a>

- `xargs`: usado para construir e executar comandos a partir de entrada padrão ou de arquivos. É especialmente útil quando precisa passar uma grande quantidade de argumentos para um comando (quando não for possível passar esses argumentos de forma direta)

Exemplo: `echo "file1 file2 file3" | xargs rm`, o que equivale a `rm file1 file2 file3`

Outro exemplo com uso do comando `find`:
```
$ find /home -name "Aula3*" | xargs ls -l
-rw-rw-r-- 1 lpi1 lpi1 0 Jan  9 19:14 /home/lpi1/Aula3
-rw-rw-r-- 1 lpi1 lpi1 0 Jan  9 19:14 /home/lpi1/Aula30
```

Removendo os arquivos que o `find` encontra:
```
find /home -name "Aula1*" | xargs rm -r
```

>[!NOTE]
>
>Pode ser desnecessário usar o `xargs` com a opção `-n 1` ou `-L 1` para processar a saída gerada pelo `find`. O comando `find` tem a opção `-exec` para executar um comando determinado para cada item do resultado da busca.

---

Há também a possibilidade de redirecionar comando com **crase** e **cifrão**, sendo uma possibilidade de inserir comando dentro de comando.
```
# com crase
$ echo "A versão do kernel é: " `uname -r`

#com cifrão
$ echo "A versão do kernel é: " $(uname -r)
```

---

#### redirecionador `<<` (Here Document) e `<<<` (Here String)

O `<<` é usado quando você deseja inserir um conteúdo interativamente, até que informe seu fim. Por exemplo:
```
$ tr a-z A-Z << final
> Curso Preparatorio para Certificacao
> lpic-1
> final
CURSO PREPARATORIO PARA CERTIFICACAO
LPIC-1
```

>[!NOTE]
>
>Veja que a string "final" (pode ser qualquer string) vai informar ao shell que a entrada termina naquele ponto, e então ele irá enviar essa entrada ao comando `tr`.

O outro redirecionador é o `<<<`, que é chamado de **here string**. Ele simplesmente redireciona o que o segue como se fosse o conteúdo de um arquivo texto. Por exemplo:
```
$ tr a-z A-Z < teste.txt 
bash: teste.txt: Arquivo ou diretório não encontrado
 
$ tr a-z A-Z <<< teste.txt 
TESTE.TXT
```

---

#### Exercício interessante
1. Em vez de abrir uma nova sessão remota do shell, o comando `ssh` pode simplesmente executar um comando indicado como argumento: `ssh user@storage "remote command"`. Dado que `ssh` também permite redirecionar a saída padrão de um programa local para a entrada padrão do programa remoto, como o comando `cat` canalizaria um arquivo local chamado `etc.tar.gz` para `/srv/backup/etc.tar.gz` em `user@storage` através de ssh?
```
$ cat etc.tar.gz | ssh user@storage "cat > /srv/backup/etc.tar.gz"
```
ou
```
$ ssh user@storage "cat > /srv/backup/etc.tar.gz" < etc.tar.gz
```

---

### 103.5 Criar, monitorar e eliminar processos

#### processos, ps, pstree, pgrep

Tudo que é executado, como scripts, bash, etc são processos. Cada processo é identificado pelo seu PID (*Process ID*)

PPID (*Parent Process ID*), é o processo pai (quando executamos um processo a partir do bash - sentido de hierarquia)

O primeiro processo iniciado pelo linux é o `init`, que vai receber o PID `1`

---

#### ps

Usado para ver os processos em execução no linux. Ele deriva de vários ambientes (Unix, BSD, GNU), e olhando no seu `man` é possível notar que (isso faz o `ps` ser um dos comandos com mais opções no linux):
- **UNIX**: são precedidos de `-`
- **BSD**: não possuem nada precedido, **SEM** o `-`
- **GNU**: opções longas, que são precedidos de `--`

Exemplo (pesquisar os processos iniciados por um usuário determinado):

```
ps U carol (BSD)
ps -u carol (UNIX)
ps --user carol (GNU)
```

- `ps`: mostra os processos que estão em execução do usuário corrente, no terminal em que está executando o comando `ps`
- `ps -u` (pode usar também `ps -u usuario`): modo de exibição de usuário (mostra mais opções), sendo as colunas:
    - **USER**: usuário que iniciou o processo (proprietário do processo)
    - **PID**: é o identificador único do processo no sistema (usado para comandos como kill para encerrar processos)
    - **%CPU**: percentual de uso da CPU pelo processo
    - **%MEM**: percentual de uso da Memória física pelo processo
    - **VSZ**: Tamanho virtual do processo (em kilobytes)
    - **RSS**: Memória residente usada pelo processo (em kilobytes) - Memória física não trocada usada pelo processo em KiB.
    - **TTY**: `Terminal Type ou TT`: O terminal associado ao processo. Um terminal físico ou virtual (como `pts/0`, que representa uma conexão remota via `SSH`). Se o processo não estiver associado a nenhum terminal, pode aparecer como `?`
    - **STAT**: código que representa o estado do processo. Além de `S`, `R` e `Z` (que vimos ao descrever a saída de `top`), outros valores possíveis seriam: `D` (dormente sem interrupção - geralmente esperando por `I/O`), `T` (interrompido - normalmente por um sinal de controle). Alguns modificadores extras incluem: `<` (prioridade maior que o convencional), `N` (prioridade menor que o convencional), ou `+` (no grupo de processos em primeiro plano).
    - **START** ou **STARTED**: horário que processo foi iniciado
    - **TIME**: indica o tempo total de CPU usado pelo processo, somando todo o tempo que o processo esteve em execução
    - **COMMAND**: o nome ou comando que iniciou o processo. Pode ser abreviado se for muito longo

- `ps -u usuario -f`: (`-f` é de `full-format listing`): lista parecido com `ps -u`, mas inclui algumas novas colunas, conforme exemplo de saída para explicar as colunas:
```
UID        PID  PPID  C STIME TTY          TIME CMD
joao     12345     1  0 10:00 pts/0    00:00:02 bash
joao     12346 12345  1 10:01 pts/0    00:00:01 top
joao     12347 12345  0 10:02 pts/0    00:00:00 ps

```
- **UID**: o usuário que iniciou o processo (`joao` neste caso).
- **PPID (Parent Process ID)**: o `PID` do processo pai. Por exemplo, `12345` iniciou `top` (`PPID` é o `PID` do `bash`)
- **C**: Percentual de CPU usado pelo processo (não confundir com `%CPU` de `ps aux`).
- **STIME**: Hora de início do processo

- `ps -u -x`: mostra processos que não foram iniciados pelo terminal `TTY` ou `pts` (só do usuário corrente) 
    - (`x`:Lift  the  BSD-style  "must have a tty" restriction, which is imposed upon the set of all processes when some BSD-style (without "-") options are used or when the ps personality setting is BSD-like. The set of processes selected in this manner is in addition to the  set  of  processes  selected  by  other means. An  alternate description is that this option causes ps to list all processes owned by you (same EUID as ps), or to list all processes when used together with the a option.)

- `ps -axu`: mostra processos de todos os usuário (inclusive root)
    - `a`: mostra processos que estão vinculados a um `tty` ou terminal.
    - `u`: exibe formato orientado ao usuário.
    - `x`: mostra processos que não estão vinculados a um `tty` ou terminal.
- `ps -axuf`: o `-f` mostra em formato mais parecido de árvore (mostrando qual processo é filho de qual processo, etc)
```
$ ps -axuf
USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root           2  0.0  0.0      0     0 ?        S    Jan10   0:01 [kthreadd]
root           3  0.0  0.0      0     0 ?        S    Jan10   0:00  \_ [pool_workqueue_release]
root           4  0.0  0.0      0     0 ?        I<   Jan10   0:00  \_ [kworker/R-rcu_g]
root           5  0.0  0.0      0     0 ?        I<   Jan10   0:00  \_ [kworker/R-rcu_p]
root           6  0.0  0.0      0     0 ?        I<   Jan10   0:00  \_ [kworker/R-slub_]
```

- `ps u -C vBoxClient`: restringe ao processo `vBoxClient` que está rodando no usuário corrente (como se fosse um filtro, traz o processo pai e seus filhos - interessante rodar com `f` para ver a árvore dos processos)

---

#### pstree

Mostra os processos em formato de árvore, seguindo a hierarquia de execução dos processos.

- `pstree`: mostra os processos em formato de árvore.
- `pstree -p` ou `--show-pids`: mostra a árvore e o `PID` dos processos.

>[!NOTE]
>
>Note que com esse comando de mostrar os processos, o processo número 1 está com o `systemd`, que é um outro padrão adotado no linux que substitui o `init`, para gerenciar processos. Entretanto ele apenas aponta para o outro.

---

#### pgrep

Mostra os IDs dos processos de acordo com os parâmetros fornecidos:

- `pgrep bash`: mostra o ID do processo `bash`. Pode confirmar que realmente é esse ID com o comando `ps axu | grep ID_PROCESSO` (conforme os usuários logarem, vai abrindo novos processos `bash`, que o `pgrep` irá listar)
- `pgrep bash -u root`: retorna o ID do processo `bash` que o usuário `root` está usando.

>[!NOTE]
>
>Pode-se usar o comando `pidof`. Tem o mesmo efeito de `pgrep`. Exemplo: `pidof firefox`

Para fazer com que `kill` funcione de forma semelhante a `pkill` ou `killall` (evitando os comandos para descobrir os PIDs correspondentes), podemos usar a substituição de comandos:
```
$ kill -1 $(pgrep sleep)
```
Como você já deve saber, uma sintaxe alternativa é <code>kill -1 \`pgrep sleep\`</code>

>[!TIP]
>
>Para uma lista exaustiva de todos os sinais de `kill` e seus códigos, digite `kill -l` no terminal. Use `-KILL` (`-9` ou `-s KILL`) para eliminar processos rebeldes quando todos os outros sinais falharem.

---

#### top

Por padrão, a saída é classificada pela porcentagem de tempo da CPU usada por cada processo em ordem decrescente

- `load avarage`: seria a fila para processos serem executados no linux
    - considerando um computador com uma CPU, um valor bom é abaixo de `1`. A partir de `1` precisa ser analisado.
    - um computador com `4` CPUs, o normal seria ir até `4` (aceitável)

- `load average: 0,12, 0,06, 0,01`: respectivamente significa:  
    - **média do último minuto**; 
    - **média dos últimos 5 minutos**; 
    - **média dos últimos 15 minutos**.

- `M`: classifica por uso da **memória**
- `N`: classifica pelo **número ID** do processo
- `P`: classifica por **porcentagem** de uso da CPU
- `T`: classifica por **tempo** de execução

>[!TIP]
>
>Para alternar entre a ordem crescente/decrescente, basta pressionar `R`.

- `u`: abre caixa de diálogo para digitar o usuário desejado para listar os processos (por padrão, são mostrados os processos de todos os usuários).
- `r`: muda prioridade de algum processo (`renice`). `top` pede o valor de `nice` (Os valores possíveis variam de `-20` a `19`, mas apenas o superusuário (root) pode definir um valor negativo ou inferior ao atual.)
- `n`: abre caixa de diálogo para digitar quantidade desejada para listar os processos
- `k`: abre caixa de diálogo perguntando qual processo (PID) deseja enviar sinal de encerrar (por padrão, `SIGTERM` ou `15`)
- `c`:mostra os caminhos absolutos dos programas e diferencia os processos do espaço do usuário dos processos do espaço do kernel (entre colchetes).
- `V`:visão de floresta/hierárquica dos processos.
- `t` e `m`: mudam a aparência das leituras da CPU e da memória, respectivamente, em um ciclo de **quatro estágios**:   
    - os **dois primeiros** pressionamentos mostram barras de progresso
    - o **terceiro** oculta a barra
    - e o **quarto** a traz de volta.
- `W`: salva as definições de configuração em `~/.toprc`
- `?` ou `h`: mostra mais opções do comando `top`
<br>

>[!TIP]
>
>Uma versão mais sofisticada e amigável de `top` é `htop`. Outra alternativa, talvez mais exaustiva, é `atop`. Se ainda não estiverem instalados em seu sistema, use seu gerenciador de pacotes para instalá-los e experimentá-los.

- `top -b` ou `--batch`: batch mode, apenas joga a informação na tela (como um screenshot, para redirecionar para um arquivo, por exemplo)
- `top -b -d3` ou `--delay`: faz a tela atualizar a cada 3 segundos
- `top -b -d3 -n3` ou `--iterations`: faz a tela atualizar a cada 3 segundos, com 3 atualizações (`-n` ou `--iterations` - isso é útil para jogar para um arquivo)
    - exemplo: `top -b -d2 -n5 > processo.out`: a cada 2 segundos, por 5 vezes, joga os processos no arquivo `processo.out`

---

#### Explicação da saída de top

A saída de `top` é dividida em **duas áreas**: a área de **resumo** e a área de **tarefas**.

---

#### A área de resumo em `top`

A área de resumo é composta pelas **cinco linhas superiores** e nos fornece as seguintes informações:
```
top - 11:10:29 up 2:21, 1 user, load average: 0,11, 0,20, 0,14
```
- hora atual (em formato de 24 horas): `11:20:29`
- tempo de atividade (há quanto tempo o sistema está ativo e funcionando): `up 2:21`
- número de usuários logados e carga média da CPU nos últimos 1, 5 e 15 minutos, respectivamente: `load average: 0,11, 0,20, 0,14`
```
Tasks: 73 total, 1 running, 72 sleeping, 0 stopped, 0 zombie 
```
(informações sobre os processos)
- número total de processos em modo ativo: `73 total`
- em execução (os que estão sendo executados): `1 running`
em espera (os que estão esperando para retomar a execução): `72 sleeping`
- interrompidos (por um sinal de controle do trabalho): `0 stopped`
- zumbi (os que concluíram a execução mas ainda estão esperando que o processo pai os remova da tabela de processos): `0 zombie`
```
%Cpu(s): 0,0 us, 0,3 sy, 0,0 ni, 99,7 id, 0,0 wa, 0,0 hi, 0,0 
si, 0,0 st
```
(porcentagem de tempo da CPU gasto em:)
- processos de usuário: `0,0 us`
- processos do sistema/kernel: `0,4 sy`
- processos com um valor nice configurado — quanto mais alto o valor nice, menor a prioridade: `0,0 ni`
- nada — tempo ocioso da CPU: `99,7 id`
- processos aguardando operações de I/O: `0,0 wa`
- processos atendendo interrupções de hardware — periféricos enviando ao processador sinais que precisam de atenção: `0,0 hi`
- processos atendendo interrupções de software: `0,0 si`
- processos atendendo tarefas de outras máquinas virtuais em um ambiente virtual, e que portanto roubam tempo: `0,0 st`
```
- KiB Mem : 1020332 total, 909492 free, 38796 used, 72044 buff/cache
```
(informações da memória em kilobytes)
- quantidade total de memória: `1020332 total`
- memória não utilizada: `909492 free`
- memória em uso: `38796 used`
- memória armazenada em buffer e em cache para evitar acesso excessivo ao disco: `72044 buff/cache`

Note como o `total` é a soma dos outros três valores — `free`, `used` e `buff/cache` - (aproximadamente 1 GB em nosso caso).
```
- KiB Swap: 1046524 total, 1046524 free, 0 used. 873264 avail Mem 
```
(informações de troca em kilobytes)
- quantidade total de espaço de troca: `1046524 total`
- espaço de troca não utilizado: `1046524 free`
- espaço de troca em uso: `0 used`
- quantidade de memória de troca que pode ser alocada a processos sem causar mais trocas: `873264 avail Mem`

---

#### A área de tarefas em `top`: Campos e colunas

Abaixo da área de resumo fica a área de tarefas, que inclui uma série de campos e colunas que informam sobre os processos em execução:

- `PID`: Identificador do processo.
- `USER`: Usuário emissor do comando que originou o processo
- `PR`: Prioridade de processo para o kernel.
- `NI`: Valor nice do processo. Os valores mais baixos têm mais prioridade que os valores altos.
- `VIRT`: Quantidade total de memória usada por processo (incluindo Troca).
- `RES`: Memória RAM usada por processo.
- `SHR`: Memória compartilhada do processo com outros processos.
- `S`: Status do processo. Os valores incluem: `S` (suspensão interrompível — esperando que um evento termine), `R` (executável — em execução ou na fila para ser executado) ou `Z` (zumbi — processos filhos encerrados cujas estruturas de dados ainda não foram removidas da tabela de processos).
- `%CPU`: Porcentagem de CPU usada pelo processo.
- `%MEM`: Porcentagem de RAM utilizada pelo processo, ou seja, o valor de RES expresso em porcentagem.
- `TIME+`: Tempo total de atividade do processo.
- `COMMAND`: Nome do comando/programa que gerou o processo.

---

<a id="kill"></a>

#### kill, killall, pkill

Normalmente os processos monitoram sinais (mensagens) que são enviados pelo kernel ou pelos usuários

- `kill`: geralmente é associado a matar processos, no entanto o correto é dizer que é um comando usado para enviar sinais a um processo. (no `man kill` já diz: send a signal to a process - normalmente é o sinal de encerrar o processo, mas as vezes pode ser usado outros tipos de sinais)
- `kill -l` ou `--list`: mostra todos os sinais que pode-se enviar para um processo (**64 tipos de sinais**). Dependendo da forma que o processo foi desenvolvido, ele pode não aceitar algum sinal.
    - pode usar o ID do sinal ou o nome dele. Ex. `ID 15` é o `SIGTERM`, já o `ID 9` é o `SIGKILL`. O `SIG` pode ser omitido, ficando apenas `TERM` ou `KILL`

---

#### Princiais sinais

- `SIGHUP` ou `ID 1`: pode terminar ou reiniciar um processo ou ainda fazer com que o processo releia suas configurações.
- `SIGINT` ou `ID 2`: interrompe um processo (esse é quando usamos o `CTRL+C`, que envia um `SIGINTERRUPT`)
    - normalmente quando usa `CTRL+C` ou `CTRL+D`, é na realidade enviado um sinal ao processo
- `SIGQUIT` ou `ID 3`: encerra/fecha/para o processo
- `SIGKILL` ou `ID 9`: mata abruptamente um processo. É o único sinal que o processo não pode ignorar.
- `SIGTERM` ou `ID 15`: solicita que o processo finalize (termina sessões ativas e encerra). Vem de `TERMINATION`, e é o **PADRÃO** do `kill`. Ex. `kill 223`: encerra o processo `223` mandando o sinal `SIGTERM` por padrão.

---

#### uso do kill

Primeiro é preciso achar o PID do processo que quer encerra. Por exemplo, vamos simular que seja o Firefox. 

Para encontrar use: `ps axu | grep firefox` ou `pgrep firefox`:

```
$ ps axu | grep firefox
lpi1   104105  4.3  3.5 20911036 574184 ?     Sl   18:12   3:47 /usr/lib/firefox/firefox

$ pgrep firefox
104105
```

- `kill 104105` equivale a `kill -s 15 104105` ou ainda a `kill -s SIGTERM 104105` ou (`--signal`): envia o sinal para encerrar o firefox, de forma soft (`SIGTERM`, `ID 15`). Digite `pgrep firefox` para confirmar.
    - o `-s` pode ser omitido, ficando: `kill -15 104105`
    - para a descrição do sinal também: `kill -SIGTERM 104105`
- `kill -s 9 104105`: encerra o firefox com `SIGKILL` (`ID 9`)

---

#### killall

Se por um lado o `kill` encerra os processos baseado no **PID**, o `killall` encerra os processos baseado no **nome**.

- `killall firefox`: encerra todos os processos que tiver com o nome firefox no linux (que o usuário que está executando seja dono - não é possível encerrar o processo de outro usuário, a não ser que seja root).
- `killall ssh`: encerra todos processos relacionados ao ssh

---

#### pkill

Assim como há o `pgrep`, que encontra o `PID` baseado no **nome**, o `pkill` funciona da mesma forma, ou seja, encontra o **processo** e o **encerra**.

- `pkill firefox`: encerra o firefox (internamente faz a busca pelo PID do firefox e encerra - se não especificar o sinal, manda o padrão `-15`)
- `pkill -1 firefox -u lpi1` ou `--euid`, `euid`: envia o sinal `1` a para  o firefox apenas do usuário `lpi1` (normalmente usado como root, para encerrar processos dos usuários)

---

#### Exercícios interessantes

1. `oneko` é um programa divertido que mostra um gato perseguindo o cursor do mouse. Se ele ainda não estiver instalado em seu sistema desktop, instale-o usando o gerenciador de pacotes de sua distribuição. Vamos usá-lo para estudar o controle de jobs.

Inicie o programa. Qual o procedimento?<br>
Resporta: Digitar `oneko` no terminal.

Mova o cursor do mouse para ver como o gato o persegue. Agora suspenda o processo. Qual o procedimento? Qual é a saída?
Resposta: pressionar a combinação de teclas `Ctrl+z`:
```
[1]+  Stopped                 oneko
```
Verifique quantos jobs estão presentes atualmente. O que você digita? Qual é a saída?
Resposta:
```
$ jobs
[1]+  Stopped                 oneko
```

Agora envie-o para o segundo plano especificando seu ID de trabalho. Qual é a saída? Como você pode saber se o job está sendo executado em segundo plano?
Resposta:
```
$ bg %1
[1]+ oneko &
```
O gato está se movendo outra vez.

Finalmente, encerre o job especificando seu ID de trabalho. O que você digita?<br>
Resposta: `$ kill %1`

2. O sinal `SIGHUP` pode ser usado como forma de reiniciar certos daemons. Com o servidor web Apache HTTPD - por exemplo - enviar `SIGHUP` para o processo pai (iniciado por init) elimina seus filhos. O pai, no entanto, relê seus arquivos de configuração, reabre os arquivos de log e gera um novo conjunto de filhos. Execute as seguintes tarefas:

Inicie o servidor web:
```
$ sudo systemctl start apache2
```

Certifique-se de conhecer o `PID` do processo pai:
```
$ ps auxf | grep apache2
root      159528  0.0  0.0   6804  4832 ?        Ss   19:59   0:00 /usr/sbin/apache2 -k start
www-data  159530  0.0  0.0 1999328 5352 ?        Sl   19:59   0:00  \_ /usr/sbin/apache2 -k start
www-data  159531  0.0  0.0 1999400 6376 ?        Sl   19:59   0:00  \_ /usr/sbin/apache2 -k start
```

O processo pai é aquele iniciado pelo usuário root. Em nosso caso, o `PID` é `159528`.

Faça o servidor web Apache HTTPD reiniciar enviando o sinal `SIGHUP` para o processo pai:
```
$ kill -SIGHUP 159528
```

Verifique se o pai não foi eliminado e se novos filhos foram gerados:
```
$ ps auxf | grep apache2
root      159528  0.0  0.0   6804  5344 ?        Ss   19:59   0:00 /usr/sbin/apache2 -k start
www-data  159988  0.0  0.0 1999444 5240 ?        Sl   20:00   0:00  \_ /usr/sbin/apache2 -k start
www-data  159989  0.0  0.0 1999444 5496 ?        Sl   20:00   0:00  \_ /usr/sbin/apache2 -k start
```
Agora você deve ver o processo pai apache2 junto com dois novos filhos.

3. Como vimos, por padrão, `top` classifica as tarefas por porcentagem de uso da CPU em ordem decrescente (com os valores mais altos no topo). Esse comportamento pode ser modificado com as teclas interativas `M` (uso de memória), `N` (identificador único do processo), `T` (tempo de execução) e `P` (porcentagem de tempo de CPU). No entanto, também podemos classificar a lista de tarefas a gosto, iniciando `top` com a opção `-o` (para saber mais, verifique a página man de `top`). Agora, execute as seguintes tarefas:

Inicie o `top` para que as tarefas sejam classificadas por uso da memória:
```
$ top -o %MEM
```
Verifique se digitou o comando correto destacando a coluna da memória:<br>
Pressione `x`.

- `-o`, `--sort-override` = `FIELDNAME`: specifies the name of the field on which tasks will be sorted, independent of what is reflected in the configuration file.

4.  `ps` também tem uma opção `o` para especificar as colunas que você deseja mostrar. Estude esta opção e execute as seguintes tarefas:

Inicie o `ps` para exibir somente informações sobre o usuário, porcentagem de memória usada, porcentagem de tempo da CPU usado e comando completo:
```
$ ps o user,%mem,%cpu,cmd
```
Agora, inicie o `ps` para que as únicas informações exibida sejam o usuário e o nome dos programas que ele está usando:
```
$ ps o user,comm
```

---

#### uptime, free, screen

- `uptime`: mostra a quanto tempo o computador está ativo, a hora atual do sistema, quanto usuários estão logados e o load average.

---

- `free`: mostra a quantidade de **memória** e **swap** utilizada pelo sistema.
- `free -m`: uso mais comum, pois só o `free` mostra em kylobytes, com `-m` ou `--mebi` mostra em mebibytes (`--mega` mostra em megabytes)
    - assim como `-g` ou `--gibi` que mostra em gibibytes ou `--giga` para mostrar em gigabytes

**Observação importante**: o campo **used** é importante frisar que o linux assumiu a quantidade mostrada e irá usar essa memória quando precisar (não necessariamente que toda essa memória está em uso). Tomar cuidado quando a memória em swap estiver bastante em uso, pois aí significa que a memória principal já foi toda usada.

---

<a id="screen"></a>

#### screen (multiplexadores de terminal)

Em eletrônica, um multiplexador (ou mux) é um dispositivo que permite que várias entradas sejam conectadas a uma única saída.

Nos primórdios do Unix (anos 1970-80), os computadores consistiam basicamente em terminais conectados a um computador central. Era só isso mesmo, sem um monte de janelas ou abas. E essa foi a razão por trás da criação do GNU Screen em 1987: emular múltiplas telas VT100 independentes em um único terminal físico.

- `screen` (`apt install screen`): gerenciar e trabalhar em várias abas (só `screen` entra no modo de abas)
    - `screen` é útil para trabalhar com `ssh`, para evitar de criar múltiplas conexões.

<br>

- `CTRL + a `: modo para aceitar comandos (sempre antes dos comandos, teremos que digitar `CTRL + a`)

<br>

Os comandos a seguir são depois de apertar `CTRL + a` (modo de comando):

- `w`: mostra as janelas (enumeradas) na parte inferior
- `c`: de create, cria nova aba (digite `w` para ver como enumerou outra janela - observe o **asterisco** que indica a que está sendo exibida no momento)
- `A`: renomeia as janelas (antes as duas se chamavam `bash`)
- `screen -t nova-janela`: cria uma nova janela com o nome `nova-janela`

---

#### movendo entre janelas

- `n`: next em inglês, vai para a próxima janela
- `p`: previous em inglês, vai para a janela anterior
- `"`: lista as janelas para escolha

>[!TIP]
>
>Usando `Ctrl + a` e o `número` da janela (ir para a janela número número). Observer o asterisco para saber em qual janela está.

Ao trabalhar com janelas, é importante lembrar o seguinte:

- As janelas executam seus programas de forma totalmente independente umas das outras.
- Os programas continuarão a ser executados mesmo que suas janelas não estejam visíveis (inclusive quando a sessão de screen for desanexada, como veremos em breve).

Para **remover uma janela**, basta encerrar o programa que está em execução nela (quando a última janela for removida, o próprio screen será encerrado). Outra alternativa é usar `Ctrl`+`a`-`k` enquanto estiver na janela que deseja remover; será solicitada a confirmação:
```
Really kill this window [y/n]
Window 0 (bash) killed.
```

---

#### dividindo a tela (regiões)

- `S`: divide a tela horizontalmente
- `|`: divide a tela verticalmente

A única coisa que a nova região mostrará é -- na parte inferior, o que significa que está vazia:
```
   1 ps                                                               --
```

- `Tab`: muda de região (pode usar também por número de janela)
- `Q`: encerra todas as regiões, exceto a atual
- `X`: encerra a região atual (O encerramento de uma região não encerra a janela associada a ela)

---

#### sessões screen

Até agora vimos algumas janelas e regiões, mas todas pertencentes à mesma e única sessão. É hora de começar a ver as sessões. Para ver uma lista de todas as sessões, digite `screen -list` ou `screen -ls`:
```
There is a screen on:
        179522.pts-0.PC-Rodrigo      (01/15/2025 20:15:58 PM)        (Attached)
1 Socket in /run/screen/S-rodrigo
```
- onde `179522` é o `PID`
- `pts-0.PC-Rodrigo` é o nome (indicando o terminal, sendo nesse caso um *pseudo-terminal escravo* + nome do host)
- `Attached` é o status

Para criar um nova sessão: `screen -S "segunda sessao"`
```
$ screen -list 
There are screens on:
        181111.segunda sessao   (01/15/2025 20:39:31 PM)        (Attached)
        179522.pts-0.PC-Rodrigo      (01/15/2025 20:15:58 PM)        (Attached)
2 Sockets in /run/screen/S-rodrigo.
```

Para encerrar uma sessão, saia de todas as janelas ou simplesmente digite o comando `screen -S SESSION-PID -X quit` (também é possível fornecer o nome da sessão). Vamos nos livrar de nossa primeira sessão:
```
$ screen -S 179522 -X quit
```

Você será enviado de volta ao prompt do terminal fora de `screen`. Mas lembre-se, nossa segunda sessão ainda está viva
```
$ screen -list
There is a screen on:
	181111.segunda sessao	(01/15/2025 08:39:31 PM)	(Detached)
1 Socket in /run/screen/S-rodrigo
```

No entanto, como eliminamos a sessão pai, ela recebe um novo rótulo: `Detached` (desanexada).

---

#### Desanexando sessões

Por uma série de razões, podemos querer desanexar uma sessão do screen do terminal a que pertence:

- Para deixar o computador da empresa cumprir seu dever e conectar-se remotamente mais tarde, de casa.
- Para compartilhar uma sessão com outros usuários.

- `d`: Detach (sai da sessão atual do screen - **NÃO** encerra as abas - para sair precisa alternar para a aba que não está em uso)
```
detached from 181111.segunda sessao]
```

Para entrar novamente na sessão desanexada, use o comando `screen -r SESSION-PID`. Outra alternativa é `SESSION-NAME`, como vimos acima. Se houver apenas uma sessão desanexada, nenhuma dessas opções é obrigatória:
```
$ screen -r
```

Este comando basta para anexar novamente a segunda sessão:
```
$ screen -ls
There is a screen on:
        181111.segunda sessao   (01/15/2025 20:39:32 PM)        (Attached)
1 Socket in /run/screen/S-rodrigo.
```

Para fechar a janela é só digitar `exit`

- `screen top`: vai iniciar o screen com o `top`

---

#### Opções importantes para reanexar sessões:

- `-d` `-r`: reanexa uma sessão e — se necessário — a desanexa primeiro.
- `-d` `-R`: igual a `-d` `-r`, mas o screen cria primeiro uma sessão caso ela não exista.
- `-d` `-RR`: igual a `-d` `-R`. No entanto, usa a primeira sessão se houver mais de uma disponível.
- `-D` `-r`: reanexa uma sessão. Se necessário, o comando a desanexa e faz logout remotamente primeiro.
- `-D` `-R`: se uma sessão estiver rodando, ela é reanexada (desanexando e desconectando remotamente primeiro, caso necessário). Se não for o caso, ela é criada e o usuário, notificado.
- `-D` `-RR`: igual a `-D` `-R` — só que mais poderoso.
- `-d` `-m`: inicia o screen em modo `detached` (desanexado). Uma nova sessão é criada, mas desanexada. Útil para scripts de inicialização do sistema.
- `-D` `-m`: igual a `-d` `-m`, mas não bifurca um novo processo. O comando é encerrado se a sessão terminar.

---

#### Copiar e colar: Modo de rolagem

O GNU Screen apresenta um modo de cópia ou modo de rolagem. Dentro dele, você pode mover o cursor na janela atual e através do conteúdo de seu histórico usando as setas do teclado. Você pode marcar o texto e copiá-lo nas janelas. As etapas a seguir são:

1. Entre no modo de cópia/rolagem: `Ctrl+a-[`.
2. Vá para o início da parte do texto que deseja copiar usando as setas do teclado.
3. Marque o início do trecho de texto que deseja copiar: `Espaço`.
4. Vá para o final da parte do texto que deseja copiar usando as setas do teclado.
5. Marque o final do trecho de texto que deseja copiar: `Espaço`.
6. Vá para a janela de sua escolha e cole o texto: `Ctrl+a-]`.

---

#### Personalização de screen

O arquivo de configuração de todo o sistema para screen é `/etc/screenrc`. Também é possível usar `~/.screenrc` no nível do usuário. O arquivo inclui quatro seções de configuração principais:

- `SCREEN SETTINGS`: Você pode definir configurações gerais especificando a diretiva seguida por um espaço e o valor, como em: `defscrollback 1024`.
- `SCREEN KEYBINDINGS`: esta seção é bastante interessante, pois permite redefinir os atalhos de teclado que podem interferir no seu uso diário do terminal. Use a palavra-chave `bind` seguida por um espaço, o caractere a ser usado após o prefixo do comando, outro espaço e o comando, como em: `bind l kill` (esta configuração mudará a forma padrão de eliminar uma janela para `Ctrl`+`a`-`l`).

Para exibir todos os atalhos de screen, digite `Ctrl`+`a`-`?` ou consulte a página de manual.

>[!TIP]
>
>Claro, você também pode alterar o próprio prefixo do comando. Por exemplo, para ir de `Ctrl`+`a` a `Ctrl`+`b`, basta adicionar esta linha: `escape ^Bb`.

- `TERMINAL SETTINGS`: Esta seção inclui as configurações relacionadas aos tamanhos de janela de terminal e buffers — entre outros. Para habilitar o modo sem bloqueio para lidar melhor com conexões SSH instáveis, por exemplo, a seguinte configuração é usada: `defnonblock 5`.
- `STARTUP SCREENS`: Podemos incluir comandos para que diversos programas sejam executados após a inicialização de `screen`; por exemplo `screen -t top top` (o screen abre uma janela chamada `top` com `top` dentro dela).

>[!NOTE]
>
>`screen` é similar ao [tmux](#tmux)

---

#### jobs, bg, fg, nohup

---

#### foreground
- supõe o seguinte comando no terminal: `$ firefox`: vai abrir o firefox, mas vai ficar "preso" ao terminal (processo em `foreground`). Assim que fechar o firefox, o terminal é liberado

---

#### background
- `firefox &` (só colocar `&` no final) executa o firefox em `background` (processo em `background`), vai listar:
```
[1]   2477
```
Onde `[1]` é a tarefa (*task*) ou job do processo, e `2477` é o PID (o processo fica desassociado do terminal).

---

#### jobs

Jobs (trabalhos) são processos iniciados de forma interativa através de um terminal, enviados para o segundo plano e ainda não finalizados.

- `jobs`: mostra as tarefas (*task*) que estão executando em `background`
- `jobs -l`: mostra o PID também (assim como também mostra o *status*):
```
[1]+ 2477 Running
```

- `jobs -n`: lista apenas os processos que mudaram de status desde a última notificação. Os possíveis status incluem `Running`, `Stopped`, `Terminated` ou `Done`:
- `jobs -p`: lista os IDs do processo.
- `jobs -r`: lista apenas os jobs em execução.
- `jobs s`: lista apenas os jobs interrompidos (ou suspensos). 

>[!NOTE]
>
>Lembre-se, um job tem um `ID` de trabalho e um `ID` de processo (`PID`).

---

#### situação interessante

Se abrirmos o `gnome-calculator` no terminal, vai abrir a calculadora e "travar" (ou ficar "preso") o terminal.

No terminal, aperte `CTRL+Z` e será enviado um sinal para o processo da calculadora ficar em `stopped` (`SIGSTOP` ou sinal `19`).

É possível ver com o comando `jobs -l` que realmente o processo da culculadora está em `stopped`.

Procure a calculadora em modo gráfico, e ela estará "congelada".

No terminal, se digitarmos `bg`, vai ser colocado em brackground o **último processo que trabalhamos**, no caso, a calculadora. Voltando nela no modo gráfico, ela voltará a funcionar normalmente.

Se digitarmos `fg`, vai ser pego o **último processo que trabalhamos** (ainda a calculadora) e esse será colocado em `foreground` ("prende" o terminal)

Caso tenhamos mais de um job (*task*) rodando, para colocar em `background` ou `foreground`, usamos o **número** do job (*task*)

Exemplo:
```
[1]- 2477 Running       firefox &
[2]+ 2604 Stopped       gnome-calculator
```

- `bg 2`: colocamos em `background` o job (*task*) `2`. Note o sinal de `+` na task `2`, isso significa que é o último processo trabalhado (para rodar diretamente `fg` ou `bg`)

>[!NOTE]
>
>Lembrando que só `bg` ou `fg` (sem especificar número), vai pegar o último processo para por em `background` ou `foreground`

Para encerrar o processo, usamos o `kill` normalmente: `fill 2477` (encerra o firefox). Depois se digitarmos `jobs -l`, teremos a saída:
```
[1]- Terminated         firefox
```

Agora encerrar a calculadora: `kill -9 2604`. Rode novamente `jobs -l`:
```
[2]+ Killed         gnome-calculador
```

Repare que de acordo com o sinal enviado, `jobs -l` retorna o `SIG` usado para encerrar o processo.

---

#### nohup

Quando acessamos por ssh, e a conexão cai, o shell envia um sinal de `SIGHUP` para os programas abertos naquela sessão, para evitar isso, usamos o `nohup`.

O `nohup` faz com que os programas abertos por ele, ignorem o sinal de `HUP` (o `nohup` não aceita sinal `HUP`)

É possível desvincular jobs de sessões e executá-los mesmo após o encerramento da sessão. Isso é feito com o comando nohup (“no hangup”). A sintaxe é a seguinte:

```
nohup COMMAND &
```

Lembre-se, o `&` envia o processo para o segundo plano e libera o terminal em que estamos trabalhando

>[!NOTE]
>
>O único sinal que não pode ser evitado é o `9` (`SIGKILL`). Os demais podem

- `nohup firefox &`: poderia ser qualquer programa ou script.

Um exemplo bom de uso, mostrado no site da lpi.org:

Vamos desvincular o job em segundo plano ping localhost da sessão atual:
```
$ nohup ping localhost &
[1] 1251
$ nohup: ignoring input and appending output to 'nohup.out'
^C
```

A saída mostra o ID do trabalho (`[1]`) e o PID (`1251`), seguido por uma mensagem nos informando sobre o arquivo `nohup.out`. Este é o arquivo padrão no qual **stdout** e **stderr** serão salvos. Agora podemos pressionar `Ctrl+C` para liberar o prompt de comando, fechar a sessão, iniciar outra como `root` e usar `tail -f` para verificar se o comando está rodando e a saída está sendo escrita no arquivo padrão:
```
$ exit
logout
$ tail -f /home/carol/nohup.out
64 bytes from localhost (::1): icmp_seq=3 ttl=64 time=0.070 ms
64 bytes from localhost (::1): icmp_seq=4 ttl=64 time=0.068 ms
64 bytes from localhost (::1): icmp_seq=5 ttl=64 time=0.070 ms
^C
```

Com isso, não importa se feche o terminal, o comando continuará executando, até o que encerre com comando `kill`, por exemplo.

>[!TIP]
>
>Em vez de usar o `nohup.out` padrão, poderíamos ter especificado um arquivo de saída à escolha com `nohup ping localhost > /path/to/your/file &`.

Se quisermos encerrar o processo, devemos especificar seu PID:
```
# kill 1251
```

---

#### watch, tmux

- `watch`: executa um programa periodicamente, mostrando a saída na tela (execute a program periodically, showing output fullscreen)
- `watch date`: executa `date` a cada 2 segundos (padrão: 2 segundos)
- `watch "ps axu | grep firefox"`: fica monitorando os processos de firefox (de 2 em 2 segundos)
- `watch -n6 free -h`: executa o comando `free -h` a cada 6 segundos (pode usar `--interval` ou `-n`)

---

<a id="tmux"></a>
#### tmux (terminal multiplexer)

- `tmux` (`apt install tmux`): controle de vários terminais em uma sessão/conexão apenas (similar ao [screen](#screen))

O tmux foi lançado em 2007. Embora muito semelhante ao `screen`, ele apresenta algumas diferenças notáveis:

- Modelo cliente-servidor: o servidor fornece uma série de sessões, cada uma das quais pode ter várias janelas anexadas a ele que podem, por sua vez, ser compartilhadas por vários clientes.
- Seleção interativa de sessões, janelas e clientes via menus.
- A mesma janela pode ser anexada a várias sessões.

Disponibilidade de atalhos do vim e do Emacs.
- Suporte para terminal UTF-8 e 256 cores.

O comando `tmux` entra no modo de janelas (nome da janela fica no rodapé)
```
[0] 0:bash*                                                        "debian" 18:53 27-Aug-19
```
Além do `hostname`, a `hora e a data`, a barra de status fornece as seguintes informações:
- Nome da sessão: [0]
- Número da janela: 0:
- Nome da janela: `bash*`. Por padrão, esse é o nome do programa em execução dentro da janela e — ao contrário de `screen` — o `tmux` irá atualizá-lo automaticamente para refletir o programa em execução atual. Observe o **asterisco** indicando que esta é a janela atual em exibição

Você pode atribuir nomes de sessão e janela ao invocar tmux:
```
$ tmux new -s "LPI" -n "Window zero"
```

A barra de status será alterada de acordo:
```
[LPI] 0:Window zero*                                                 "debian" 19:01 27-Aug-19
```

- `CTRL + B`: modo de comandos:
    - `c`: cria nova janela/aba (vai listar no rodapé, acrescentando um número ordinal referente a cada janela)
    - `,` (vírgula): renomeia ma janela (lembrar que precisa apertar `CTRL + B` antes)
    - `p` (previous): volta uma janela
    - `n` (next): vai para a próxima janela (olhar no asterisco `*` que aparece nos números de cada janela - no caso com asterisco é a janela corrente)
    - `l` (last): vai para última janela que estava anteriormente
    - `1-9`: vai de acordo com o número (`CTRL + B ` antes e o número da janela desejada)
    - `w`: lista as janelas que tem, basta escolher e apertar `Enter`
    - `x` ou `&`: close current pane, ou usa `exit`
    - `f`: encontra uma janela pelo nome
    - `.`: altera o número do índice da janela

---

#### painéis (dividir o terminal)

A facilidade de divisão de janelas do `screen` também está presente no `tmux`. As divisões resultantes não são chamadas de regiões, mas de painéis. A diferença mais importante entre regiões e painéis é que os últimos são pseudoterminais completos anexados a uma janela. Isso significa que eliminar um painel também eliminará seu pseudo-terminal e todos os programas associados em execução nele.

- `%`: abre o painel vertical (divide a tela com 2 terminais/janelas, uma na esquerda e outra na direita)
    - se repetir o comando anterior, vai dividir o painel corrente. Ex. caso esteja no painel da direita, vão ficar paines com 50% de tamanho na esqueda, e dois paineis com 25% de tamanho cada.
- `"`: abre o painel horizontal (mesmo esquema do vertical).

Para destruir o painel atual (junto com o pseudoterminal rodando dentro dele e quaisquer programas associados), use `Ctrl`+`b`-`x`. Será solicitada a confirmação na barra de status:
```
kill-pane 1? (y/n)
```

---

#### Comandos importantes dos painéis:

- `Ctrl`+`b`-`↑`,`↓`,`←`,`→`: mover-se entre painéis.
- `Ctrl`+`b`-`;`: passar para o último painel ativo.
- `Ctrl`+`b`-`Ctrl`+`seta`: redimensionar o painel em uma linha.
- `Ctrl`+`b`-`Alt`+`seta`: redimensionar o painel em cinco linhas.
- `Ctrl`+`b`-`{`: trocar de painel (do atual para o anterior).
- `Ctrl`+`b`-`}`: trocar de painel (do atual para o seguinte).
- `Ctrl`+`b`-`z`: aproximar/afastar o painel.
- `Ctrl`+`b`-`t`: O `tmux` exibe um relógio elegante dentro do painel (para removê-lo, pressione `q`).
- `Ctrl`+`b`-`!`: transforma o painel em janela.
- `o`: vai para o próximo painel
- `;`: alterna entre os paineis

Segurando `CTRL + B` e usando as setas do teclado, recimenciona os paineis

---

#### sessões tmux

Para listar as sessões no tmux, você pode usar `Ctrl`+`b`-`s`:
```
(0) + LPI: 2 windows (attached)
```
Outra alternativa é usar o comando `tmux ls`:
```
$ tmux ls
LPI: 2 windows (created Tue Aug 27 19:01:49 2019) [158x39] (attached)
```
Existe apenas uma sessão (`LPI`) que inclui duas janelas. Vamos criar uma nova sessão de dentro de nossa sessão atual. Isso pode ser feito usando `Ctrl`+`b`. Digite `:new` no prompt e pressione Enter. Você será enviado para a nova sessão, conforme pode ser observado na barra de status:
```
[2] 0:bash*                                                       "debian" 19:15 27-Aug-19
```
Por padrão, o `tmux` denomina a sessão `2`. Para renomeá-la, use `Ctrl`+`b`-`$`. Quando solicitado, informe o novo nome e pressione Enter:
```
(rename-session) Second Session
```
Para trocar de sessão, o atalho é `Ctrl`+`b`-`s` (use as setas do teclado e `enter`):
```
(0) + LPI: 2 windows
(1) + Second Session: 1 windows (attached)
```
Para eliminar uma sessão, você pode usar o comando tmux kill-session -t SESSION-NAME. Se digitar o comando de dentro da sessão atual anexada, você será retirado do tmux e levado de volta à sua sessão de terminal inicial:
```
$ tmux kill-session -t "Second Session"
[exited]
$
```

---

#### desanexando sessões (detach)

Ao eliminar `Second Session`, fomos levados para fora do `tmux`. No entanto, ainda temos uma sessão ativa. Peça ao `tmux` uma lista de sessões e você certamente a encontrará ali:
```
$ tmux ls
LPI: 2 windows (created Tue Aug 27 19:01:49 2019) [158x39]
```
No entanto, esta sessão está desanexada de seu terminal. Podemos anexá-la com `tmux attach -t SESSION-NAME` (`attach` pode ser substituído por `at` ou — simplesmente — `a`). Quando há apenas uma sessão, a especificação do nome é opcional:
```
$ tmux a
```
Agora você está de volta à sua sessão; para desanexá-la, pressione `Ctrl`+`b`-`d`:
```
[detached (from session LPI)]
$
```
>[!TIP]
>
>A mesma sessão pode ser anexada a mais de um terminal. Se quiser anexar uma sessão e ter certeza de que ela foi primeiramente desanexada de quaisquer outros terminais, use a opção `-d`: `tmux attach -d -t SESSION-NAME`.

- `Ctrl`+`b`-`D`: seleciona o cliente a desanexar.
- `Ctrl`+`b`-`r`: atualiza o terminal do cliente.

- `tmux ls`ou `tmux list-sessions`: mostra as sessões criadas. Mesmo fechando o terminal e abrindo novamente, vai continuar as sessões.

Exemplo de como é mostrado: `0: 3 windows (createad Fri Jan 15:37:06 2019)`. Sendo o `0` o número de sessão

Para se conectar novamente (na conexão `0`): `tmux attach -t 0`

- `tmux new -s nome_conexao`: nova conexão
- `tmux kill-session -t 0`: encerra conexão. Pode usar o nome da conexão em vez do número

É possível compartilhar o terminal com `tmux`: abra uma sessão `tmux` normalmente, abra outro terminal e conecta na mesma sessão `tmux`. Com isso, tudo que faz em um terminal, reflete no outro.

---

#### Copiar e colar: Modo de rolagem

O `tmux` também possui um modo de cópia, basicamente igual ao do `screen` (lembre-se de usar o prefixo de comando do tmux e não o de screen!). A única diferença em termos de comando é que usamos `Ctrl` + `Espaço` para marcar o início da seleção e `Alt`+`w` para copiar o texto selecionado.

---

#### Personalização do tmux

Os arquivos de configuração do `tmux` tipicamente se localizam em `/etc/tmux.conf` and `~/.tmux.conf`. Quando iniciado, o `tmux` procura por esses arquivos, se eles existirem. Também existe a possibilidade de iniciar o `tmux` com a opção `-f` para fornecer um arquivo de configuração alternativo. Um exemplo de arquivo de configuração do `tmux` pode ser encontrado em `/usr/share/doc/tmux/example_tmux.conf`. O nível de personalização é altíssimo. Eis algumas das coisas que é possível fazer:

- Alterar a tecla de prefixo
```
# Change the prefix key to C-a
set -g prefix C-a
unbind C-b
bind C-a send-prefix
```
- Definir atalhos de teclado extras para janelas superiores a 9
```
# Some extra key bindings to select higher numbered windows
bind F1 selectw -t:10
bind F2 selectw -t:11
bind F3 selectw -t:12
```

Para ver uma lista abrangente com todos os atalhos, digite `Ctrl`+`b`-`?` (pressione `q` para sair) ou consulte a página de manual.

---

### 103.6 Modificar prioridades de execução de processos

#### nice, renice

Internamente o linux tem um algoritmo de gerenciamento de processos, ele gerencia, durante a execução, quem vai ter prioridade a mais do que outro.

É possível ver essa informação com o comando `top` ou `ps -l`

No `top` tem as colunas `PR` e `NI`
- `PR`: prioridade que o linux determina em um dado momento para quem vai consumir mais memória e cpu
- `NI`: ou simplesmente `nice`: propriedade que permite o usuário ou administrador influenciar nessa prioridade.

O `NI` pode ser alterado pelo comando `nice` e `renice`
- `nice`: define o `nice` de um comando assim que o inicia
- `renice`: altera o `nice` de um processo que já está em execução

Os valores do `nice` podem ser definidos entre `-20` até `+19` (pense em um range `-20`-`+19`)

Lembrando que quanto menor o número (**negativo**), maior vai ser a prioridade. Consequentemente, quanto **maior** o número (**positivo**), **menor** será a prioridade (lembrar que são inversamente proporcionais)

O `nice` padrão é `0` (zero)

>[!NOTE]
>
>Apenas o `root` pode colocar um valor **negativo** em um processo. `Usuário comuns` só podem definir valor positivo, ou seja, **podem apenas diminuir** a prioridade de seus processos!

---

#### nice

Exemplo de como iniciar o firefox com prioridade 15 (diminuir a prioridade)
```
$ nice -n 15 firefox &
```
Pode usar `-n` ou `--adjustment`=`N`, ou omitir, usando `-15` diretamente

Agora no `top` é possível ver o firefox com prioridade `15`

Para abrir o `gnome-calculator` com prioridade `-15` (aumentar a prioridade) usamos (como root - lembre-se que apenas root pode ajustar prioridade negativa):
```
# nice -n -15 gnome-calculator &
```

>[!WARNING]
>
>Se for omitir o `-n` para valores negativos, use: `--15` (cuidado pois confunde bastante). Como já visto, poderia usar `--adjustment=-15`

Resumidamente a **calculadora** está com **mais prioridade** do que o **firefox**.

>[!NOTE]
>***********
>Caso o `nice` seja utilizado sem especificar valor, o valor atribuído é `10`
```
nice firefox &
```
Vai executar o firefox com prioridade `10`

Será padrão (`0` zero) quando aberto diretamente.

---

#### renice

O `renice` altera prioridade de processo já em execução.

Exemplo de sintaxe (abaixo veja alterando de `15` para `8` o `gnome-calculator`): `renice -n 8 <PID>`
```
# renice -n 8 193634
193634 (process ID) old priority 15, new priority 8
```

>[!WARNING]
>
>Caso queira omitir o `-n`, tomar cuidado pois omite tudo (é uma pequena diferença do `nice` para o `renice`). Veja abaixo o exemplo:

- `renice -7 <PID>`: para valores negativos
- `renice 7 <PID>`: para valores positivos

Mais exemplos:

- `renice -n 5 -u lpi1` ou `--user`: muda a prioridade de todos os processos do usuário `lpi1` para 5. Pode usar `-g` ou `--pgrp` para grupos.

>[!TIP]
>
>Além de `renice`, a prioridade dos processos pode ser modificada com outros programas, como `top`. No alto da tela principal, o valor nice de um processo pode ser modificado pressionando `r` e, em seguida, o número `PID` do processo. A mensagem `PID to renice [default pid = 1]` aparece, com o primeiro processo listado selecionado por padrão. Para alterar a prioridade de outro processo, digite o `PID` dele e pressione `Enter`. A mensagem `Renice PID 1 to value` será exibida (com o número `PID` solicitado) e um novo valor `nice` poderá ser atribuído.

---

#### Exercícios interessantes

1. A alteração da prioridades dos processos geralmente é necessária quando um processo está ocupando muito tempo da CPU. Usando `ps` com opções padrão para imprimir todos os processos do sistema em formato longo, qual sinalizador de `--sort` permite classificar os processos por utilização da CPU, em ordem crescente?
```
$ ps -el --sort=pcpu
```

2. O comando `schedtool` pode definir todos os parâmetros de agendamento da CPU de que o Linux é capaz ou exibir informações para determinados processos. Como ele pode ser usado para exibir os parâmetros de agendamento do processo `1750`? Além disso, como `schedtool` pode ser usado para alterar o processo `1750` para tempo real com prioridade -90 (conforme exibido por `top`)?
```
$ schedtool 1750
$ schedtool -R -p 89 1750
```
---

### 103.7 Pesquisar em arquivos de texto usando expressões regulares

---

#### grep, intro regex

Regex, Regular Expression (conteúdo/padrão de texto) é um conjunto de caracteres e metacaracteres que vai definir um padrão de texto (diferente de [file globbing](#fileglobbing), que é uma forma do shell identificar grupos de arquivos pelo nome)

Nas expressões regulares básicas, precisamos proteger os caracteres especiais.

---

#### grep

- `grep Linux texto.txt`: busca pela palavra `Linux` dentro do arquivo `texto.txt`. Se houver ocorrências, retorna a linha. Lembrar que `grep` é **case sensitive**.
- `grep -c Linux texto.txt` ou `--count`: retorna a quantidade de ocorrências ou quantas linhas achou o padrão pesquisado. Se usar com com o `-v` ou `--invert-match`, conta as linhas que não teve o padrão pesquisado
- `grep -c Linux *` (file globbing): pesquisa em todos os arquivos do diretório atual a quantidade de linhas que houve ocorrências com a palavra pesquisada. Lista os arquivos seguido de `:` com a quantidade:
```
$ grep -c Linux *
teste:0
saida:0
Aula3:2
texto.txt:3
```

- `grep -i Linux texto.txt` ou `--ignore-case`: mostra tanto `Linux` como `linux`. Ignora o case sensitive. Tomar cuidado com buscas muito grandes, pois é mais pesado pois fica testando as duas possibilidades (maiúsculo e minúsculo)
- `grep -r Linux t*`: procura por arquivos que começam com a letra `t` dentro dos diretórios que existem dentro da pasta atual.

No grep conseguimos usar regex avançado (expande as opções de padrão de expressões regulares) com: `egrep` ou `grep -E` ou `--extended-regexp`

Existe ainda o `fgrep`, que no caso **NÃO** aplica expressões regulares (considera tudo como texto apenas). Equivalente a `grep -F`

- `grep -v Linux texto.txt` ou `--invert-match`: mostra todas as linhas que a ocorrência `Linux` não seja satisfeita (mostra as linhas que **não** tenha `Linux`)

---

Mais opções do grep

- `-f` `FILE` ou `--file=FILE`: Indica um arquivo contendo a expressão regular a ser usada.
- `-n` ou `--line-number`: Mostra o número da linha.
- `-H` ou `--with-filename`: Mostra também o nome do arquivo que contém a linha.
- `-z` ou `--null-data`: Em vez de fazer com que o `grep` trate os fluxos de dados de entrada e saída como linhas separadas (usando newline por padrão), ele passa a encarar a entrada ou saída como uma sequência de linhas. Ao combinar a saída do comando `find` usando a opção `-print0` com o comando `grep`, a opção `-z` ou `--null-data` deve ser usada para processar o fluxo da mesma maneira.


---

#### intro regex, sed

Usando conchetes `[]`

- `egrep "b[aei]g" texto.txt`: busca por uma palavra que começe por `b`, e contenha ou `a` ou `e` ou `i` e termine com `g`
- ``egrep "b[a-u]g" texto.txt``: nos mesmos moldes do exemplo anterior, mas entre o `b` e o `g`, busca as letras de `a` até `u` (não apenas as vogais, mas todas as letras de `a` a `u`)

Começo (`^`) e final de linha (`$`)

- `egrep "^Linux" texto.txt`: busca pela palavra `Linux` toda vez que estiver no **começo da linha**.
- `egrep "Linux$" texto.txt`: busca pela palavra `Linux` toda vez que estiver no **final da linha**.
- `egrep "^#" /etc/ssh/sshd_config`: mostra todos os comentários do arquivo em questão
- `egrep -v "^#" /etc/ssh/sshd_config`: mostra todas as linhas que não possuem comentário - retira os comentários (pode usar `--invert-match`)
- `egrep "^$" texto.txt`: busca por linha em branco
- `egrep -v "^$" texto.txt`: exclui as linhas em branco

---

#### Uso do `*`

- `*`: Pode aparecer ou não, pode aparecer várias vezes (se usado para letras anterior, não precisa aparecer ou pode aparecer várias vezes).

Considere o arquivo `texto.txt` com o seguinte conteúdo:
```
O Xubuntu é baseado no Ubuntu
bag
beg
big
beginner
bigger
bege
bee
```

- `egrep "b[a-i]g*" texto.txt`: vai retornar:
<pre>
O Xubuntu é <b style="color: red">ba</b>seado no Ubuntu
<b style="color: red">bag</b>
<b style="color: red">beg</b>
<b style="color: red">big</b>
<b style="color: red">beg</b>inner
<b style="color: red">bigg</b>er
<b style="color: red">beg</b>e
<b style="color: red">be</b>e
</pre>

Repare que **pode não** conter o `g` (<b style="color: red">ba</b>seado), e pode conter diversos `g` (<b style="color: red">bigg</b>er)

- `egrep "b[a-i]g*e" texto.txt`: vai retornar (aqui precisa ter um `e` depois do `*`):
<pre>
<b style="color: red">bigger</b>
<b style="color: red">bege</b>
<b style="color: red">bee</b>
</pre>

Como precisa ter um `e` após o asterisco e pode ou não ter o `g` antes do asterisco, retorna a saída acima.

---

#### Uso do `+`

- `+`: tem que ter ao menos 1 caracter. Pode aparecer várias vezes (se usado com letra anterior, precisa aparecer pelo menos 1 vez)

- `egrep "b[a-i]g+" texto.txt`: apenas a palavra `baseado`, da linha `Xubuntu é baseado no Ubuntu` que não vai aparecer, pois aqui exige o `g` pelo menos 1 vez. (`bee` também não vai aparecer pelo mesmo motivo)

<pre>
<b style="color: red">bag</b>
<b style="color: red">beg</b>
<b style="color: red">big</b>
<b style="color: red">beg</b>inner
<b style="color: red">bigg</b>er
<b style="color: red">beg</b>e
</pre>

---

#### uso da `?`

- `?`: pode aparecer nenhuma ou só 1 vez.

- `egrep "b[a-i]g?" texto.txt`: mostra quando a letra `g` não aparece nenhuma vez ou apenas 1 vez. Tendo a saída:
<pre>
O Xubuntu é <b style="color: red">ba</b>seado no Ubuntu
<b style="color: red">bag</b>
<b style="color: red">beg</b>
<b style="color: red">big</b>
<b style="color: red">beg</b>inner
<b style="color: red">big</b>ger
<b style="color: red">beg</b>e
<b style="color: red">be</b>e
</pre>

- `egrep "b[a-i]g?e" texto.txt` (incluindo `e` no final): mostra quando a letra `g` não aparece nenhuma vez ou apenas 1 vez e a letra `e` aparece imediatamente após.
<pre>
<b style="color: red">bege</b>
<b style="color: red">bee</b>
</pre>

---

### uso do `.`

- `.`: significa 1 único caracter (o espaço também é considerado um caracter).

Vamos fazer uma comparação:

- `egrep "b[a-i]g" texto.txt`: deixando padrão, sem nenhum quantificador, teremos a saída:
<pre>
<b style="color: red">bag</b>
<b style="color: red">beg</b>
<b style="color: red">big</b>
<b style="color: red">beg</b>inner
<b style="color: red">big</b>ger
<b style="color: red">beg</b>e
</pre>

Agora incluindo o `.`

- `egrep "b[a-i]g." texto.txt`: repare que com o ponto, o qual exige que tenha um único caracter, exclui as palavras que não possuem letras depois do `g`
<pre>
O Xubuntu é <b style="color: red">ba</b>seado no Ubuntu

<b style="color: red">begi</b>nner
<b style="color: red">bigg</b>er
<b style="color: red">bege</b>
</pre>

- `egrep "b[a-i]g..." texto.txt`: mostra a palavra que tem 3 letras (`...`) após o `g`:
<pre>
O Xubuntu é <b style="color: red">ba</b>seado no Ubuntu

<b style="color: red">beginn</b>er
<b style="color: red">bigger</b>
</pre>

---

#### algumas diferenças entre `grep` e `egrep`

Nos exemplos a seguir, cosidere o arquivo `arquivo.txt` com o seguinte conteúdo:
```
ba{1,3}h
ba
baah
baaah
baaaah
```

- `grep 'ba{1,3}h' arquivo.txt`: vai listar apenas a primeira linha, pois usando apenas o `grep`, o retorno irá tratar as chaves apenas como um caracter normal, e não especial

<pre>
<b style="color: red">ba{1,3}h</b>
</pre>

Tratando chaves `{}` como caracter especial, teríamos um quantificador de vezes que determinada palavra vai aparecer.

Exemplo:

- `{1,3}`: determinado caracter vai aparecer de `1` até `3` vezes
- `{4}`: determinado caracter vai aparecer `4` vezes
- `ba{,4}`: agora como `a` está ao lado da chave, ele vai ser a referêcia, e no caso, a letra `a` vai aparecer no máximo 4 vezes
- `ba{4,}`: aqui o caracter `a` vai aparecer no mínimo 4 vezes até N vezes

No `grep` (antigo), temos que "proteger" as chaves para que funcione como expressão regular:
- `grep 'ba\{1,3\}h' arquivo.txt`: dessa forma, retorna:

<pre>
<b style="color: red">bah</b>
<b style="color: red">baah</b>
<b style="color: red">baaah</b>
</pre>

Agora usando `egrep` ou `grep -E`:

- `egrep 'ba{1,3}h' arquivo.txt`: temos o mesmo resultado do comando acima.
<pre>
<b style="color: red">bah</b>
<b style="color: red">baah</b>
<b style="color: red">baaah</b>
</pre>

---

#### Mais exemplos com quantificador `{}`

- `{i}`: O átomo deve aparecer exatamente `i` vezes (sendo `i` um número inteiro). Por exemplo, `[[:blank:]]{2}` corresponde a exatamente dois caracteres em branco.
- `{i,}`: O átomo deve aparecer pelo menos `i` vezes (sendo `i` um número inteiro). Por exemplo,`[[:blank:]]{2,}` corresponde a qualquer sequência de dois ou mais caracteres em branco.
- `{i,j}`: O átomo deve aparecer ao menos `i` vezes e no máximo `j` vezes (`i` e `j` sendo números inteiros, `j` maior que `i`). Por exemplo, `xyz{2,4}` corresponde à string `xy` seguida por dois a quatro caracteres `z`.

De toda forma, se uma substring corresponder a uma expressão regular e uma substring mais longa começando no mesmo ponto também corresponder, a substring mais longa será considerada.

As expressões regulares básicas também suportam chaves, mas elas devem ser precedidas por `\`, `\{` e `\}`. Sozinhas, `{` e `}` são interpretadas como caracteres literais. Uma `\{` seguida por um caractere diferente de um dígito é um caractere literal, não uma abertura de chave.

**Curiosidade**: caso proteja o caracter `{}` usando `egrep`, teremos o mesmo efeito de usar `grep` sem proteger `{}`:
<pre>
<b style="color: red">ba{1,3}h</b>
</pre>

Mais informações sobre regex: `man 7 regex`

---

#### caracter set (caracteres de representação)

- `.`: qualquer caracter
- `[]`: lista normal
    - As listas de expressão de colchetes também aceitam classes em vez de apenas caracteres únicos e intervalos. As classes de caracteres tradicionais são:

        - `[:alnum:]`: Representa um caractere alfanumérico.
        - `[:alpha:]`: Representa um caractere alfabético.
        - `[:ascii:]`: Representa um caractere que pertence ao conjunto de caracteres ASCII.
        - `[:blank:]`: Representa um caractere em branco, ou seja, um espaço ou tabulação.
        - `[:cntrl:]`:Representa um caractere de controle.
        - `[:digit:]` Representa um dígito (de 0 a 9).
        - `[:graph:]` Representa qualquer caractere imprimível, exceto espaço.
        - `[:lower:]` Representa um caractere em minúsculas.
        - `[:print:]` Representa qualquer caractere imprimível, incluindo espaço.
        - `[:punct:]` Representa qualquer caractere imprimível que não seja um espaço ou um caractere alfanumérico.
        - `[:space:]` Representa os caracteres de espaço em branco: espaço, alimentação de formulário (\f), nova linha (\n), retorno de carro (\r), tabulação horizontal (\t) e tabulação vertical (\v).
        - `[:upper:]` Representa uma letra maiúscula.
        - `[:xdigit:]` Representa dígitos hexadecimais (de 0 a F).
- `[^]`: lista negada

---

#### Quantificadores

- `?`: um caracter específico aparecer ou nenhuma vez
- `*`: pode ou não aparecer (quantas vezes for necessário)
- `+`: tem que ter ao menos um ou aparecer vários caracteres
- `{}`: define quantas vezes vai aparecer

---

#### Âncoras (Anchors)

- `^`: começo da linha
- `$`: final da linha
- `\b`: começo ou fim de uma palavra

Exemplo:
- `egrep '\bLinux\b' texto.txt`: retorna só a palavra `Linux` (se tivesse `Linux Ubuntu`, **NÃO** retornaria)

O `\b` considera letras, números e sublinhados (já não entenderia se houvesse hífen)

---

#### uso do operador ou `|`

Ideal para busca com dois ou mais termos

- `egrep 'bag|beg' texto.txt`: retorna:
<pre>
<b style="color: red">bag</b>
<b style="color: red">beg</b>
<b style="color: red">beg</b>inner
<b style="color: red">beg</b>e
</pre>

- `egrep '(bag|beg)inner' texto.txt`: `bag` ou `beg` + terminando com `inner`:
<pre>
<b style="color: red">beg</b>inner
</pre>

---

### 103.8 Edição básica de arquivos

---

#### vi e vim

- `vi /etc/fstab`: abre o arquivo `/etc/fstab`
- `vi +9 /etc/fstab`: abre o arquivo `/etc/fstab` e posiciona o cursor na 9ª linha (se usar só o `+`, vai diretamente para última linha)
- `~`: indica onde o arquivo termina
- `vi --version`: para verficiar se já é o Vi Improved, caso não seja, instalar `apt install vim`

---

#### Modo de Navegação
- `/` (semelhante ao `less`): busca no arquivo
    - `n`: próxima ocorrencia da busca
    - `N`: ocorrência anterior (de baixo para cima)
- `?`: modo de busca començando do final do arquivo
    - `n`: busca de baixo para cima
    - `N`: busca de cima para baixo
- `h`: caracter anterior ←
- `j`: linha de baixo ↓
- `k`: linha de cima ↑
- `l`: próximo caracter →

---

##### Copiar/Colar:
- `cc`: recorta a linha que o cursor estiver e entra no modo de `-- INSERT --`
    - se sair do modo de inserção, com `ESC`, aperte `p` (de paste) para colar o que foi recortado anteriormente com `cc`
- `dd`: recorta, mas **NÃO** entra no modo de edição
- `d3d`: recorta as três linhas que o cursor estiver (a própria que o cursor estiver + as duas seguintes)
- `3dd`: mesmo efeito do comando anterior 
    - `p`: cola o que foi recortado
- `yy`: copia a linha que estiver com o cursor.
    - `p`: cola o que foi copiado
- `y3y`: copia as três linhas que o cursor estiver (a própria que o cursor estiver + as duas seguintes)

---

#### Modo de Comando (ou Modo Normal)

Esse é o modo que o `vim` inicia por padrão.

Mais comuns no dia a dia (**Comandos de dois pontos**).

Os comandos de dois pontos permitem ao usuário realizar pesquisas, salvar, sair, executar comandos do shell, alterar as configurações do vi, etc. Para voltar ao modo normal, executamos o comando :visual ou pressionamos a tecla Enter sem qualquer comando

Comandos de dois pontos mais comuns:
- `:w`: salva e continua no arquivo
- `:q` ou `quit`: quit (se já estiver salvo, sai sem alertar nada)
- `:q!`: sai sem salvar
- `:wq`: salva e sai
- `x` ou `:e` ou `:exit`: salva e sai
- `ZZ`: salva e sai (sem os dois pontos `:`)
- `:! comando`: executa o `comando` no shell e volta para o `vi`
- `:s/REGEX/TEXT/g`: substituir todas as ocorrências da expressão regular `REGEX` por `TEXT` na linha atual. Ele aceita a mesma sintaxe do comando `sed`, incluindo endereços.
- `:visual`: volta ao modo de navegação

>[!TIP]
>
>Os usuários novatos podem ter dificuldade para memorizar todas as teclas de comando do `vi` de uma vez. As distribuições que adotam o vim também possuem o comando `vimtutor`, que usa o próprio `vim` para abrir um guia passo a passo das principais atividades. O arquivo é uma cópia editável que pode ser usada para praticar os comandos e se acostumar progressivamente com eles.

No modo de inserção (digitando a tecla `i` - mais comum)
- `o`: entra no modo `-- INSERT --` a partir da linha de **baixo**
- `O`: entra no modo `-- INSERT --` a partir da linha de **cima**
- `a`: entra no modo `-- INSERT --` a partir do **próximo caracter** que o cursor estiver
- `A`: entra no modo `-- INSERT --` no **final da linha** que o cursor estiver.
- `ESC`: sai do modo de inserção e vai para o modo de navegação

Mais comandos:
- `0, $`: Ir para o início e o fim da linha.
- `1G, G`: Ir para o início e o fim do documento.
- `(, )`: Ir para o início e o fim da frase.
- `{, }`: Ir para o início e o fim do parágrafo.
- `w, W`: Pular palavra e pular palavra incluindo a pontuação.
- `e or E`: Ir para o fim da palavra atual.
- `s, S`: Apagar o caractere sob o cursor ou a linha inteira e entrar no modo de inserção.
- `c`: Alterar o(s) caractere(s) sob o cursor.
- `r`: Substituir o caractere sob o cursor.
- `x`: Excluir os caracteres selecionados ou o caractere sob o cursor.
- `v, V`: Iniciar uma nova seleção com o caractere atual ou a linha inteira.
- `y, yy`: Copia (arranca) o(s) caracter(es) ou a linha inteira.
- `p, P`: Colar o conteúdo copiado, antes ou depois da posição atual.
- `u`: Desfazer a última ação.
- `Ctrl-R`: Refazer a última ação.
- `ZZ`: Fechar e salvar.
- `ZQ`: Fechar e não salvar.

---

##### Combinações de teclas

Se precedido por um número, o comando será executado o mesmo número de vezes. Por exemplo, pressione `3yy` para copiar a linha atual mais as duas seguintes, pressione `d5w` para deletar a palavra atual e as 4 palavras seguintes, e assim por diante.

A maioria das tarefas de edição são combinações de vários comandos. Por exemplo, a sequência de teclas `vey` é usada para copiar uma seleção começando na posição atual até o final da palavra atual. A repetição de comandos também pode ser usada em combinações, então v3ey copiaria uma seleção começando na posição atual até o final da terceira palavra a partir de lá.

O `vi` pode organizar o texto copiado em registros, permitindo manter conteúdos distintos ao mesmo tempo. Um registro é especificado por um caractere precedido por `"` e, uma vez criado, é mantido até o final da sessão atual. A seqüência de teclas `"ly` cria um registro contendo a seleção atual, que estará acessível através da tecla `l` . Então, o registro `l` pode ser colado com `"lp`.

>[!NOTE]
>
Se quiser saber mais sobre os outros modos de execução, abra o vi e digite: `:help vim-modes-intro`

---

#### mais sobre vi

Se digitar somente `vi`, abrimos o `vi`, mas sem arquivo definido. Se digitar qualquer coisa e tentar salvar, será emitido o alerta `E32: No file name` (mesmo que use `:wq!`, vai dar o mesmo erro). Nesse caso precisa salvar e dar um nome ao arquivo: `:w novo-arquivo.txt`

Se estivermos com um arquivo aberto, e em outro terminal executarmos `echo "teste" >> arquivo.txt`, ao voltar no `vi` que estamos editando o arquivo e tentarmos salvar, vai dar um *warning* `W11: Warning: The file "arquivo.txt" has been changed since editing started`. Se tenta salvar, vai alertar que o arquivo mudou desde a leitura, se deseja salvar:
- `y`: sobreescreve e ignora o outro processo
- `n`: continua na edição corrente
- `:e!` (`e` de `edit`): carrega a edição feita por outro processo. O `!` é apenas para quando houver alteração no arquivo, caso só venha o processo externo, basta usar `e` (lembrar, `e` de `edit`)

---

#### nano e emacs

---

#### nano

Os comandos no nano são dados usando a tecla `Ctrl` ou a tecla `Meta` (dependendo do sistema, `Meta` é `Alt` ou `⌘`).

Atalhos listados no site da lPI.org:
- `Ctrl-6` ou `Meta-A`: Iniciar uma nova seleção. Também é possível criar uma seleção pressionando Shift e movendo o cursor.
- `Meta-6`: Copiar a seleção atual.
- `Ctrl-K`: Cortar a seleção atual.
- `Ctrl-U`: Colar o conteúdo copiado.
- `Meta-U`: Desfazer.
- `Meta-E`: Refazer.
- `Ctrl-\`: Substituir o texto na seleção.
- `Ctrl-T`: Iniciar uma sessão de verificação ortográfica para o documento ou seleção atual.

Atalhos mostrados no curso:
- `^`: significa `Ctrl`
- `^Y`: previous page (paginando)
- `^V`: next page (paginando)
- `^_`: informa qual linha quer ir (pode ser linha e coluna)
- `^W`: pesquisa
- `^X`: sai
- `Alt /`: vai para o **final** do texto
- `Alt \`: vai para o **começo** do texto

---

#### emacs

O Emacs é outro editor de texto muito popular para o ambiente de shell. Ao passo que o texto é inserido com a digitação simples, como no `nano`, a navegação é auxiliada por comandos do teclado, como no vi. O Emacs inclui muitos recursos que o tornam mais do que apenas um editor de texto. Também é um IDE (ambiente de desenvolvimento integrado) capaz de compilar, executar e testar programas. O Emacs pode ser configurado como cliente de email, notícias ou RSS, tornando-o um verdadeiro pacote de produtividade.

Caso não tenha instalado, use `apt install emacs`

- `emacs arquivo.txt`: vai abrir com o emacs, no entanto se estiver usando interface gráfica, vai aparecer o emacs gráfico.

Temporariamente mude a variável de ambiente $DISPLAY para vazio: `export DISPLAY=`

- `CTRL + x`: habilita as opções (faça os demais seguido de `CTRL + x`)
    - `CTRL + c` sai do emacs
    - `CTRL + V` procura por arquivo (supõe que abriu só ele)
    - `CTRL + F` criar ou abrir um arquivo (após abrir, pode digitar o arquivo normalmente)
    - `CTRL + S` salvar sem perguntar nada (se usar só `S`, pergunta se deseja salvar)
    - `CTRL + W`: salvar como
    - `CTRL + K`: recorta a partir do cursor (diferente de `vi` que copia a linha toda)
    - `CTRL + /`: desfaz (um recorte, por exemplo - `undo`)
    - `CTRL + Y`: colar
    - `HOME/EDN`: começo ou final da linha
    - `CTRL + E/CTRL + A`: começo ou final da linha
    - `ALT + SHIFT + >/<`: começo/final do texto
    - `ALT + x`: muda o modo de interpretar o arquivo (como html, perl, etc)

---

#### definir o editor padrão

Há algumas situações que o Linux vai requerer que edite algum arquivo por meio de algum comando que chame o editor de texto, nesse caso o Linux vai chamar o editor padrão, como por exemplo: `crontab -e`, para editar o arquivo o cron em relação ao agendamento de tarefas.

- `select-editor`: abre opções para mudar o editor padrão (com o sinal de `<` é o padrão)

- `update-alternatives --config editor`: altera o `editor` (se chamar diretamente `editor`, também vai abrir o editor padrão): escolhe o editor padrão (precisa ser root)

É possível ainda alterar por meio da variável de ambiente `$EDITOR`: `export EDITOR=nano`, aceita `vim`, `emacs`, etc. (sobrescreve a configuração que está no `select-editor`)

Podemos usar também a variável de ambiente `$VISUAL`

Podemos ainda alterar o `~/.bash_rc` ou `~/.bash_profile` do user local, e no final do arquivo colocar: `export VISUAL=vim` (ou `EDITOR`)

---

#### exercícios interessantes site lpi.org

1. O `vi` é usado principalmente como editor de arquivos de configuração e código-fonte, onde a indentação ajuda a identificar seções de texto. Uma seleção pode ser recuada para a esquerda pressionando `<` e para a direita pressionando `>`. Quais teclas devem ser pressionadas no modo normal para recuar a seleção atual três passos para a esquerda?

**Resposta**: As teclas `3<`, que indicam três passos para a esquerda.

2. Uma linha inteira pode ser selecionada pressionando `V` no modo normal do `vi`. No entanto, o caractere de término da nova linha também será incluído. Quais teclas devem ser pressionadas no modo normal para selecionar a partir do caractere inicial até o caractere de nova linha, sem incluí-lo?

**Resposta**: As teclas `0v$h`, que significam `0` (“pular para o início de uma linha”), `v` (“iniciar a seleção de caracteres”), `$` (“ir ao final da linha”) e `h` (“voltar uma posição”).

3. Como o `vi` deve ser executado na linha de comando para abrir `~/.bash_profile` e pular direto para a última linha?

**Resposta**: O comando `vi + ~/.bash_profile` abre o arquivo e posiciona o cursor na última linha.

4. Quais teclas devem ser pressionadas no modo normal do `vi` para excluir caracteres desde a posição atual do cursor até o caractere de ponto final seguinte?

**Resposta**: As teclas `dt.`, que significam `d` (“iniciar a exclusão”), `t` (“pular para o próximo caractere”) and `.` (caractere de ponto final).

5. O `vim` permite selecionar blocos de texto com largura arbitrária, não apenas seções com linhas inteiras. Ao pressionar `Ctrl+V` no modo normal, uma seleção é feita movendo o cursor para cima, para baixo, para a esquerda e para a direita. Usando esse método, como excluir um bloco começando no primeiro caractere da linha atual, contendo as próximas oito colunas e cinco linhas de texto?

**Resposta**: A combinação `0`, `Ctrl-V` e `8l5jd` seleciona e remove o bloco correspondente.

6. Uma sessão do `vi` foi interrompida por uma falha de energia inesperada. Ao reabrir o arquivo, o `vi` pergunta ao usuário se deseja recuperar o arquivo de troca (uma cópia automática feita pelo `vi`). O que o usuário deve fazer para descartar o arquivo de troca?

**Resposta**: Pressionar `d` quando solicitado pelo `vi`.

7. Em uma sessão do `vim`, uma linha foi previamente copiada para o registro `l`. Qual combinação de teclas gravaria uma macro no registro `a` para colar a linha do registro `l` imediatamente antes da linha atual?

**Resposta**: A combinação `qa"lPq`, que significa `q` (“iniciar a gravação da macro”), `a` (“atribuir o registro a à macro”), `"l` (“selecionar o texto no registro `l`”), `P` (“colar antes da linha atual”) e `q` (“encerrar a gravação da macro”).

## Tópico 104: Dispositivos, sistemas de arquivos Linux e padrão FHS
### 104.1 Criar partições e sistemas de arquivos

Em qualquer sistema operacional, um disco precisa ser particionado antes de poder ser usado. Uma partição é um subconjunto lógico do disco físico; as informações sobre as partições são armazenadas em uma tabela de partições. Essa tabela inclui informações sobre o primeiro e o último setores da partição e seu tipo, além de mais detalhes sobre cada partição.

Normalmente, cada partição é vista por um sistema operacional como um “disco” separado, mesmo que todas residam na mesma mídia física. Nos sistemas Windows, elas recebem letras como `C:` (historicamente o disco principal), `D:` e assim por diante. No Linux, cada partição recebe um diretório em `/dev`, como `/dev/sda1` ou `/dev/sda2`.

- `fdisk -l`: lista os discos e as partições dentro de cada disco (precisa rodar como `root`)

>[!NOTE]
>
>Em `Disklabel type` temos o tipo "`dos`" que é quer dizer que está usando o tipo de partição `mbr`. Podemos ter `gpt`, que é referente à instalação do tipo `efi`

- `MBR`: Um remanescente dos primeiros dias do MS-DOS (mais especificamente, o PC-DOS 2.0 de 1983) que, por décadas, foi o esquema de particionamento padrão dos PCs. A tabela de partição é armazenada no primeiro setor de um disco, chamado setor de inicialização, junto com um carregador de inicialização, que em sistemas Linux geralmente é o bootloader GRUB. Mas o MBR tem uma série de limitações que dificultam seu uso em sistemas modernos, como a incapacidade de endereçar discos com mais de `2 TB` de tamanho e o limite de apenas 4 partições primárias por disco.
- `GUID` (`GPT`): Um sistema de particionamento que aborda muitas das limitações do MBR. Não há limite prático para o tamanho do disco, e o número máximo de partições é limitado apenas pelo próprio sistema operacional. É mais comumente encontrado em máquinas mais modernas que usam UEFI em vez da antiga BIOS.

**mbr**
```
# fdisk -l
Disk /dev/vda: 20 GiB, 21474836480 bytes, 41943040 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x6091bf38
```

**gpt**
```
Disk /dev/nvme0n1: 476,94 GiB, 512110190592 bytes, 1000215216 sectors
Disk model: IM2P44F3A NVMe ADATA 512GB              
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: gpt
Disk identifier: 40C27F5D-857D-49AC-AAAB-D20978861944
```

---

#### Manipulando disco/partição com fdisk

Crie um disco a parte na VM, para não ter perigo de perder dados. Para acessar o disco por meio do utilitário do fdisk, `/dev/sda`, use o comando
```
# fdisk /dev/sda
```

Por padrão, é criado o esquema em `mbr`. No entanto é possível alterar. Recomendado apertar a tecla `m` para listar as opções de comandos (o fdisk trabalha com `GPT`, `SGI,` `Sun`, além do `MBR`, que aparece como `DOS`)

Usando as configurações como MBR:

1. `n`: adicionar nova partição (vai perguntar por partições:
    1. `p` para **primárias** (a escolhida) ou 
    2. `e` para **estentidas**
```
Command (m for help): n
Partition type
   p   primary (0 primary, 0 extended, 4 free)
   e   extended (container for logical partitions)
Select (default p): p
``` 

>[!NOTE]
>
>O `fdisk` já faz o cálculo das partições primárias de acordo com o limite.

2. escolher o número da partição: deixar `1` (`default`)
```
Partition number (1-4, default 1):
```
3. escolha do setor de início: deixar padrão também.
```
First sector (2048-20971519, default 2048):
```
4. escolha do último setor, o que vai influenciar e criar o tamanho total da partição. Pode usar `K`, `M`, `G`, `T` ou `P` (`Kilo`, `Mega`, `Giga`, `Tera` ou `Peta`) (Ex. `+1GB` para 1 Giga Byte, `+500M` para 500 Mega Bytes) ou simplesmente escolher o setor (mais avançado)
```
Last sector, +/-sectors or +/-size{K,M,G,T,P} (2048-20971519, default 20971519): +2G
```
Com isso devemos receber a mensagem que a partição foi criada:
```
Created a new partition 1 of type 'Linux' and of size 2 GiB.
```

---

-`p`: lista a(s) partição(ões) criada(s)
```
Command (m for help): p
Disk /dev/sda: 10 GiB, 10737418240 bytes, 20971520 sectors
Disk model: QEMU HARDDISK   
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x9dd711b4

Device     Boot Start     End Sectors Size Id Type
/dev/sda1        2048 4196351 4194304   2G 83 Linux
```

Sendo o significado de cada coluna:
- `Device`: O dispositivo atribuído à partição.
- `Boot`: Mostra se a partição é “inicializável” ou não.
- `Start`: O setor em que a partição começa.
- `End`: O setor em que a partição termina.
- `Sectors`: O número total de setores na partição. Deve ser multiplicado pelo tamanho dos setores para se obter o tamanho da partição em bytes.
- `Size`: O tamanho da partição em formato “legível por humanos”. No exemplo acima, os valores estão em gigabytes.
- `Id`: O valor numérico que representa o tipo de partição.
- `Type`: A descrição do tipo de partição.

>[!NOTE]
>
>Se criarmos mais **2 partições primárias**, **teremos 3 primárias**. Caso crie uma nova partição, o `fdisk` vai **sugerir** para que a próxima partição seja **estendida**. É interessante criá-la com o tamanho **máximo** (ou valor padrão do `fdisk`), pois ela irá comportar as partições lógicas (e a estendida será a **4ª partição**).

>[!NOTE]
>
>Para um sistema operacional como o Linux, as partições primárias e estendidas são tratadas exatamente da mesma maneira, então não há “vantagens” em se usar uma ou outra.

```
Command (m for help): n
Partition type
   p   primary (3 primary, 0 extended, 1 free)
   e   extended (container for logical partitions)
Select (default e): 

Using default response e.
Selected partition 4
First sector (8390656-20971519, default 8390656): 
Last sector, +/-sectors or +/-size{K,M,G,T,P} (8390656-20971519, default 20971519): 

Created a new partition 4 of type 'Extended' and of size 6 GiB.
```

No caso acima, usou todo o restante do disco (`6 GiB`), para ser uma espécie de container das partições lógicas. Agora temos o seguinte esquema no disco:
```
Command (m for help): p
Disk /dev/sda: 10 GiB, 10737418240 bytes, 20971520 sectors
Disk model: QEMU HARDDISK   
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x9dd711b4

Device     Boot   Start      End  Sectors Size Id Type
/dev/sda1          2048  4196351  4194304   2G 83 Linux
/dev/sda2       4196352  6293503  2097152   1G 83 Linux
/dev/sda3       6293504  8390655  2097152   1G 83 Linux
/dev/sda4       8390656 20971519 12580864   6G  5 Extended
```

>[!IMPORTANT]
>
>Lembrar que as partições lógicas começam em `5` (ex. `sda5`). No caso acima, `sda4` é apenas um container para as demais partições lógicas (`Id 5` - Id de partição estendida)

Caso tente adicionar mais uma partição, o `fdisk` vai alertar que todas as partições primárias estão em uso, que vai ser adicionado a partição lógica número `5`:
```
Command (m for help): n
All primary partitions are in use.
Adding logical partition 5
First sector (8392704-20971519, default 8392704):
```

>[!NOTE]
>
>Nesse caso nem pergunta qual o número da partição que queremos, pois como a partição lógica começa em 5, e precisa seguir a sequência, nem é perguntado qual o número desejado.

Após criado a partição lógica, digite `p` para verificar se está tudo correto:
```
p
Disk /dev/sda: 10 GiB, 10737418240 bytes, 20971520 sectors
Disk model: QEMU HARDDISK   
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x9dd711b4

Device     Boot   Start      End  Sectors  Size Id Type
/dev/sda1          2048  4196351  4194304    2G 83 Linux
/dev/sda2       4196352  6293503  2097152    1G 83 Linux
/dev/sda3       6293504  8390655  2097152    1G 83 Linux
/dev/sda4       8390656 20971519 12580864    6G  5 Extended
/dev/sda5       8392704  9416703  1024000  500M 83 Linux
```

>[!IMPORTANT]
>
>Importantíssimo lembrar que as mudanças feitas estão ainda em memória, para salvar as alterações, use `w`.

- `q`: sai sem salvar efetuar as mudanças feitas.
- `w`: salva as alterações realizadas no disco e sai
```
Command (m for help): w
The partition table has been altered.
Calling ioctl() to re-read partition table.
Syncing disks.
```

- `d`: excluir uma partição

>[!IMPORTANT]
>
>Lembrando que as partições primárias podem ser excluídas não importando a sequencia.

```
Command (m for help): d
Partition number (1-5, default 5): 2

Partition 2 has been deleted.

Command (m for help): p
Disk /dev/sda: 10 GiB, 10737418240 bytes, 20971520 sectors
Disk model: QEMU HARDDISK   
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x9dd711b4

Device     Boot   Start      End  Sectors  Size Id Type
/dev/sda1          2048  4196351  4194304    2G 83 Linux
/dev/sda3       6293504  8390655  2097152    1G 83 Linux
/dev/sda4       8390656 20971519 12580864    6G  5 Extended
/dev/sda5       8392704  9416703  1024000  500M 83 Linux
```

Já quando quiser excluir uma partição estendida, a depender da partição, a próxima toma o lugar da anterior. Vamos supor que no exemplo anterior, tenha mais uma partição lógica, como mostrado abaixo:
```
Device     Boot   Start      End  Sectors  Size Id Type
/dev/sda1          2048  4196351  4194304    2G 83 Linux
/dev/sda3       6293504  8390655  2097152    1G 83 Linux
/dev/sda4       8390656 20971519 12580864    6G  5 Extended
/dev/sda5       8392704  9416703  1024000  500M 83 Linux
/dev/sda6       9418752 13613055  4194304    2G 83 Linux
```

Se excluir a partição `sda5`, a `sda6` passará a ser a `sda5`, como abaixo:
```
Command (m for help): d
Partition number (1,3-6, default 6): 5

Partition 5 has been deleted.

Command (m for help): p
Disk /dev/sda: 10 GiB, 10737418240 bytes, 20971520 sectors
Disk model: QEMU HARDDISK   
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x9dd711b4

Device     Boot   Start      End  Sectors Size Id Type
/dev/sda1          2048  4196351  4194304   2G 83 Linux
/dev/sda3       6293504  8390655  2097152   1G 83 Linux
/dev/sda4       8390656 20971519 12580864   6G  5 Extended
/dev/sda5       9418752 13613055  4194304   2G 83 Linux
```

>[!IMPORTANT]
>
>Caso exclua a 4ª partição (`sda4`), que normalmente representa a partição **estendida** (a menos que tenha criado 4 partições primárias), será **EXCLUÍDO TODAS** as partições lógicas ligadas à partição estendida! Restando apenas as **partições primárias**! Muito cuidado!

```
Command (m for help): d
Partition number (1,3-5, default 5): 4

Partition 4 has been deleted.

Command (m for help): p
Disk /dev/sda: 10 GiB, 10737418240 bytes, 20971520 sectors
Disk model: QEMU HARDDISK   
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x9dd711b4

Device     Boot   Start     End Sectors Size Id Type
/dev/sda1          2048 4196351 4194304   2G 83 Linux
/dev/sda3       6293504 8390655 2097152   1G 83 Linux
```

---

#### tipos de partições

- `l`: lista os tipos de partições conhecidas pelo `fdisk`

>[!NOTE]
>
>As principais são: (`83 part linux` e `82 part swap`)

Para alterar de uma partição para outra, por exemplo alterar de `83` para `82` (alterar de tipo `Linux` para `Swap`)

1. `p` para listar as partições criadas
2. `t` para mudar o tipo da partição
3. escolhe a partição
4. escolhe o tipo da partição, no caso é swap, e o código é 82
5. `p` novamente para listar as partições e averiguar se foi feito a mudança

```
Command (m for help): t
Partition number (1-6, default 6): 5
Hex code or alias (type L to list all): 82

Changed type of partition 'Linux' to 'Linux swap / Solaris'.

Command (m for help): p
Disk /dev/sda: 10 GiB, 10737418240 bytes, 20971520 sectors
Disk model: QEMU HARDDISK   
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x9dd711b4

Device     Boot   Start      End  Sectors  Size Id Type
/dev/sda1          2048  4196351  4194304    2G 83 Linux
/dev/sda2       4196352  6293503  2097152    1G 83 Linux
/dev/sda3       6293504  8390655  2097152    1G 83 Linux
/dev/sda4       8390656 20971519 12580864    6G  5 Extended
/dev/sda5       8392704  9416703  1024000  500M 82 Linux swap / Solaris
/dev/sda6       9418752 13613055  4194304    2G 83 Linux
```

---

#### tabelas de partição

É possível mudar a tabela de partição, usando os comandos:
- `g`: cria uma tabela de partição GPT vazia
- `G`: cria uma tabela de partição SGI vazia
- `o`: cria uma tabela de partição DOS vazia
- `s`: cria uma tabela de partição Sun vazia

>[!WARNING]
>
>**Cuidado**: criar outra tabela de partição em um disco já com partições configuradas, faz com que você perca tudo, pois os comandos acima iniciam uma tabela de partição vazia. Caso não tenha salvo depois das mudanças, apenas saia sem salvar (`q`) e entre novamente no `fdisk`.

```
Command (m for help): g

Created a new GPT disklabel (GUID: 1F5CDED2-BB51-C64D-9DD7-CA85697F54AB).
The device contains 'dos' signature and it will be removed by a write command. See fdisk(8) man page and --wipe option for more details.

Command (m for help): p

Disk /dev/sda: 10 GiB, 10737418240 bytes, 20971520 sectors
Disk model: QEMU HARDDISK   
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: gpt
Disk identifier: 1F5CDED2-BB51-C64D-9DD7-CA85697F54AB
```

Caso use o esquema de tabela de partição `GPT`, a grande diferença é que não há aquela característica do `MBR`, com partições primarias e lógicas, ele basicamente vai criando as partições, de 1 até 128 (geralmente limitado pelo sistema operacional).
```
Device       Start     End Sectors  Size Type
/dev/sda1     2048 2099199 2097152    1G Linux filesystem
/dev/sda2  2099200 3123199 1024000  500M Linux filesystem
/dev/sda3  3123200 7317503 4194304    2G Linux filesystem
```

>[!NOTE]
>
>Para um sistema operacional como o Linux, as partições primárias e estendidas são tratadas exatamente da mesma maneira.

---

#### Espaço disponível no disco

Ainda dentro do `fdisk`, podemos ver quando de espaço há no disco que selecionamos:

- `F`: mostra quanto espaço livre tem (espaço que não está alocado nenhuma partição)
```
Command (m for help): F
Unpartitioned space /dev/sda: 6.51 GiB, 6990839296 bytes, 13653983 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes

  Start      End  Sectors  Size
7317504 20971486 13653983  6.5G
```

>[!NOTE]
>
>caso tenha espaço no disco que esteja rodando o sistema, e criar novas partições dentro desse espaço que esteja sobrando, apenas será efetivado quando fazer um `reboot` do sistema.

---

#### Lacunas

Tenha em mente que, ao criar uma nova partição com `fdisk`, o tamanho máximo será limitado pela quantidade máxima de espaço contíguo não alocado no disco. Digamos, por exemplo, que você tenha o seguinte mapa de partições:
```
Device     Boot   Start     End Sectors  Size Id Type
/dev/sdd1          2048 1050623 1048576  512M 83 Linux
/dev/sdd2       1050624 2099199 1048576  512M 83 Linux
/dev/sdd3       2099200 3147775 1048576  512M 83 Linux
```

Em seguida, você exclui a partição `2` e verifica o espaço livre:
```
Command (m for help): F
Unpartitioned space /dev/sdd: 881 MiB, 923841536 bytes, 1804378 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes

  Start     End Sectors  Size
1050624 2099199 1048576  512M
3147776 3903577  755802  369M
```

Somando o tamanho do espaço não alocado, em teoria teríamos `881 MB` disponíveis. Mas veja o que acontece quando tentamos criar uma partição de `700 MB`:
```
Command (m for help): n
Partition type
   p   primary (2 primary, 0 extended, 2 free)
   e   extended (container for logical partitions)
Select (default p): p
Partition number (2,4, default 2): 2
First sector (1050624-3903577, default 1050624):
Last sector, +/-sectors or +/-size{K,M,G,T,P} (1050624-2099199, default 2099199): +700M
Value out of range.
```


>[!IMPORTANT]
>
>Isso acontece porque o maior espaço contíguo não alocado no disco é o bloco de `512 MB` que pertencia à partição `2`. Sua nova partição não pode “pular por cima” da partição `3` para usar parte do espaço não alocado existente depois dela.

---

#### gdisk

`gdisk` é similar ao `fdisk`, no entanto é voltado para trabalhar com partições `GPT` (a interface foi criada a partir do `fdisk`, com um prompt interativo e os mesmos comandos (ou muito semelhantes)

- `gdisk /dev/sda`: acessa o modo de configuração do `gdisk` trabalhando no disco `sda`.

Vamos analisar a saída `p` (listar partições) no `gdisk` para entendermos a diferença para o `fdisk`:
```
Command (? for help): p
Disk /dev/sdb: 3903578 sectors, 1.9 GiB
Model: DataTraveler 2.0
Sector size (logical/physical): 512/512 bytes
Disk identifier (GUID): AB41B5AA-A217-4D1E-8200-E062C54285BE
Partition table holds up to 128 entries
Main partition table begins at sector 2 and ends at sector 33
First usable sector is 34, last usable sector is 3903544
Partitions will be aligned on 2048-sector boundaries
Total free space is 1282071 sectors (626.0 MiB)

Number  Start (sector)    End (sector)  Size       Code  Name
   1            2048         2099199   1024.0 MiB  8300  Linux filesystem
   2         2623488         3147775   256.0 MiB   8300  Linux filesystem
```

Já de cara, notamos algumas coisas diferentes:
- Cada disco possui um Identificador de Disco (`GUID`) exclusivo. Este é um número hexadecimal de 128 bits, atribuído aleatoriamente quando a tabela de partição é criada. Como há `3.4 × 10^38` valores possíveis para esse número, as chances de que 2 discos aleatórios tenham o mesmo GUID são muito pequenas. O GUID pode ser usado para identificar quais sistemas de arquivos montar no momento da inicialização (e onde), eliminando a necessidade de usar o caminho do dispositivo para fazer isso (como `/dev/sdb`).
- Notou a frase **Partition table holds up to 128 entries**? É isso mesmo, dá para ter até `128` partições em um disco `GPT`. Por causa disso, não há necessidade de partições primárias e estendidas.
- O espaço livre é listado na última linha, então não precisamos de um equivalente ao comando `F` do `fdisk`.


>[!NOTE]
>
>A criação é muito similar ao `fdisk`.

- `n`: cria partição
    1. escolhe o número da partição
    2. setor
    3. tipo pelo número (`83` Linux e `82` SWAP - por padrão coloca `83`). Rode `l` para obter uma lista completa
    4. define o tamanho (`+1G`, `+400M`, etc)
- `p`: lista as partições
- `w`: salva as alterações e sai

>[!NOTE]
>
>A principal diferença é que, além do número da partição e do primeiro e último setores (ou o tamanho), também podemos especificar o **tipo** de partição durante a criação. As partições `GPT` suportam muitos mais tipos do que as `MBR`. Para ver uma lista de todos os tipos suportados, use o comando `l`.

>[!NOTE]
>
>Não confunda o tipo de partição com o sistema de arquivos usado nela. Embora no início houvesse uma relação entre eles, hoje não é possível presumir que isso seja verdade. Uma partição Linux, por exemplo, pode conter qualquer sistema de arquivos nativo do Linux, como `ext4` ou `ReiserFS`

---

#### Removendo partição com gdisk

Para excluir uma partição, digite `d` e o número da partição. Ao contrário do `fdisk`, a primeira partição não será selecionada automaticamente se for a única no disco.

Em discos `GPT`, as partições podem ser facilmente reordenadas ou “classificadas” para evitar lacunas na sequência de numeração. Para isso, basta usar o comando `s`. Por exemplo, imagine um disco com a seguinte tabela de partição:
```
Number  Start (sector)    End (sector)  Size       Code  Name
   1            2048         2099199   1024.0 MiB  8300  Linux filesystem
   2         2099200         2361343   128.0 MiB   8300  Linux filesystem
   3         2361344         2623487   128.0 MiB   8300  Linux filesystem
```
Se excluirmos a segunda partição, a tabela fica assim:
```
Number  Start (sector)    End (sector)  Size       Code  Name
   1            2048         2099199   1024.0 MiB  8300  Linux filesystem
   3         2361344         2623487   128.0 MiB   8300  Linux filesystem
```
Se usarmos o comando `s`, ela se torna:
```
Number  Start (sector)    End (sector)  Size       Code  Name
   1            2048         2099199   1024.0 MiB  8300  Linux filesystem
   2         2361344         2623487   128.0 MiB   8300  Linux filesystem
```
Observe que a terceira partição se tornou a segunda.

>[!NOTE]
>
>Ao contrário dos discos `MBR`, ao criar uma partição em discos `GPT`, o tamanho não é limitado pela quantidade máxima de espaço contíguo não alocado. Você pode usar até o último pedacinho de um setor livre, não importa onde ele esteja localizado no disco.

---

#### Opções de recuperação

O `gdisk` fornece recursos para auxiliar nessas tarefas de recuperação, acessadas com o comando `r`

Para reconstruir um cabeçalho `GPT` principal corrompido ou uma tabela de partição, usamos `b` e `c`, respectivamente, ou usamos o cabeçalho principal e a tabela para reconstruir um backup com `d` e `e`. 

Também dá para converter um `MBR` em `GPT` com `f` e fazer o oposto com `g`, entre outras operações. Digite `?` No menu de recuperação para obter uma lista de todos os comandos de recuperação disponíveis e descrições sobre o que eles fazem

---

#### tipos de filesystems

Depois de criar as partições, é preciso definir qual `filesystem` elas terão.

`filesystem`: é a forma que o Linux vai trabalhar os dados dentro do disco (tamanho dos blocos, como vai alocar, como vai fragmentar ou desfragmentar, etc)

Um sistema de arquivos controla como os dados são armazenados e acessados no disco. O Linux suporta muitos sistemas de arquivos, alguns nativos, como a família `ext` (Extended Filesystem), enquanto outros vêm de outros sistemas operacionais como o `FAT` do MS-DOS, o `NTFS` do Windows NT, `HFS` e `HFS +` do Mac OS, etc.

São vários filesystems, vejamos alguns na tabela abaixo

| **tipo de FS** | **Journal?** | **Características** |
|-----|----|----|
| `ext2` | Não | Original do início do Linux |
| `ext3` | Sim | `ext2` com `journal` (o primeiro a ter `journal`) |
| `ext4` | Sim | melhoria do `ext3` |
| `XFS` | Sim | criado pela SGI para o Sistemas IRIX |
| `JSF` | Sim | Criado pela IBM |
| `ReiserFS` | Sim | Melhor performance com pequenos arquivos |
| `Brtfs` | Sim | desenvolvido inicialmente pela Oracle. Nova geração |
| `VFAT` | Não | Usado em Sistemas Windows |

`journal` é uma habilidade que o `filesystem` tem de gravar um `log` das operações feitas dentro do disco (recupera melhor quando há alguma falha **abrupta** do sistema)

---

#### mkfs - criando/definindo partições

`mkfs`: cria/define a estrutura do `filesystem` (lembrar que isso vem depois de criarmos as partições e o tipo delas)

- `mkfs -t ext3 /dev/sdb1` ou `--type`: cria/define uma estrutura no formato `ext3`, no caso na partição `/dev/sda1` (assim como `fdisk`, `mkfs` também precisa ser root para executar)
```
# mkfs -t ext3 /dev/sda1 
mke2fs 1.46.5 (30-Dec-2021)
Discarding device blocks: done                            
Creating filesystem with 524288 4k blocks and 131072 inodes
Filesystem UUID: 4f4f9184-b221-4a05-9302-d3dd63ca9db8
Superblock backups stored on blocks: 
	32768, 98304, 163840, 229376, 294912

Allocating group tables: done                            
Writing inode tables: done                            
Creating journal (16384 blocks): done
Writing superblocks and filesystem accounting information: done
```

Para verificar qual o `filesystem` foi usado em determinada partição, use o comando:
```
# file -s /dev/sdb1
```
Pode usar `-s` ou `--special-files`
```
# file -s /dev/sda1
/dev/sda1: Linux rev 1.0 ext3 filesystem data, UUID=4f4f9184-b221-4a05-9302-d3dd63ca9db8 (large files)
```

>[!NOTE]
>
>Se fizer para `sda2`, que não está formatado, retorna que é dado `/dev/sdb2: data`
```
# file -s /dev/sda2
/dev/sda2: data
```

Outro exemplo criando uma partição do tipo `vfat` em `/dev/sda2`
```
# mkfs -t vfat /dev/sda2
mkfs.fat 4.2 (2021-01-31)

# file -s /dev/sda2 
/dev/sda2: DOS/MBR boot sector, code offset 0x58+2, OEM-ID "mkfs.fat", sectors/cluster 8, Media descriptor 0xf8, sectors/track 63, heads 255, hidden sectors 4196352, sectors 2097144 (volumes > 32 MB), FAT (32 bit), sectors/FAT 2048, serial number 0xf551cd5a, unlabeled
```

Também podemos definir as partições com `mkfs`.`tipo`, como por exemplo: `mkfs.ext3 /dev/sdb1` ou `mkfs.fat /dev/sdb2`, etc.
```
# mkfs.
mkfs.cramfs  mkfs.ext3    mkfs.fat     mkfs.msdos   mkfs.xfs     
mkfs.ext2    mkfs.ext4    mkfs.minix   mkfs.vfat
```

>[!IMPORTANT]
>
>Além de criarmos a partição de `swap`, precisamos formatar a partição para o tipo `swap`, com o comando `mkswap /dev/sdb5`, por exemplo. (Lembrar que não basta apenas definir o **tipo 82**, é preciso formatá-la também!)
```
# mkswap /dev/sda5
Setting up swapspace version 1, size = 500 MiB (524283904 bytes)
no label, UUID=c734486f-f819-41e3-8a02-0aad3f8b93f0
```

Se olhar em `/proc/swaps`, a partição não estará ainda efetivamente como `swap`:
```
# cat /proc/swaps 
Filename				Type		Size		Used		Priority
/dev/dm-1                               partition	2097148		0		-2
```

Para efetivar, é necessário executar o comando: `swapon /dev/sdb5`
```
# cat /proc/swaps 
Filename				Type		Size		Used		Priority
/dev/dm-1                               partition	2097148		0		-2
[root@localhost ~]# swapon /dev/sda5


[root@localhost ~]# cat /proc/swaps 
Filename				Type		Size		Used		Priority
/dev/dm-1                               partition	2097148		0		-2
/dev/sda5                               partition	511996		0		-3
```

>[!NOTE]
>
>`swapoff` retira a partição do `swap`

Os utilitários `mkfs.ext2`, `mkfs.ext3` e `mkfs.ext4` são usados para criar sistemas de arquivos `ext2`, `ext3` e `ext4`. 

De fato, todos esses “utilitários” existem apenas como links simbólicos para outro utilitário chamado `mke2fs`. O `mke2fs` altera seus padrões de acordo com o nome pelo qual é chamado. Dessa forma, todos eles têm o mesmo comportamento e parâmetros na linha de comando.
```
# mkfs.ext4 /dev/sda1
# mke2fs -t ext4 /dev/sda1
```

>[!NOTE]
>
>`# mkfs.ext4 /dev/sdb1` e `# mke2fs -t ext4 /dev/sdb1` são equivalentes!

---

#### Parâmetros mke2fs

O `mke2fs` suporta uma ampla gama de parâmetros e opções de linha de comando. Eis alguns dos mais significativos. Todos eles também se aplicam a `mkfs.ext2`, `mkfs.ext3` e `mkfs.ext4`

```
$ ls -l /usr/sbin/mkfs*
-rwxr-xr-x 1 root root  14720 Dec  4 23:26 /usr/sbin/mkfs
-rwxr-xr-x 1 root root  22912 Dec  4 23:26 /usr/sbin/mkfs.bfs
-rwxr-xr-x 1 root root 573752 Mar 31  2024 /usr/sbin/mkfs.btrfs
-rwxr-xr-x 1 root root  35144 Dec  4 23:26 /usr/sbin/mkfs.cramfs
-rwxr-xr-x 1 root root  31112 Apr 18  2024 /usr/sbin/mkfs.exfat
lrwxrwxrwx 1 root root      6 Apr 28  2024 /usr/sbin/mkfs.ext2 -> mke2fs
lrwxrwxrwx 1 root root      6 Apr 28  2024 /usr/sbin/mkfs.ext3 -> mke2fs
lrwxrwxrwx 1 root root      6 Apr 28  2024 /usr/sbin/mkfs.ext4 -> mke2fs
-rwxr-xr-x 1 root root  52048 Mar 31  2024 /usr/sbin/mkfs.fat
lrwxrwxrwx 1 root root     12 Nov  8 16:18 /usr/sbin/mkfs.hfs -> mkfs.hfsplus
-rwxr-xr-x 1 root root  45424 Apr  1  2024 /usr/sbin/mkfs.hfsplus
-rwxr-xr-x 1 root root  59544 Apr  8  2024 /usr/sbin/mkfs.jfs
-rwxr-xr-x 1 root root  43408 Dec  4 23:26 /usr/sbin/mkfs.minix
lrwxrwxrwx 1 root root      8 Nov  8 16:18 /usr/sbin/mkfs.msdos -> mkfs.fat
lrwxrwxrwx 1 root root      6 Nov  8 16:18 /usr/sbin/mkfs.ntfs -> mkntfs
lrwxrwxrwx 1 root root     10 Nov  8 16:18 /usr/sbin/mkfs.reiserfs -> mkreiserfs
lrwxrwxrwx 1 root root      8 Nov  8 16:18 /usr/sbin/mkfs.vfat -> mkfs.fat
-rwxr-xr-x 1 root root 449528 Oct 17 04:36 /usr/sbin/mkfs.xfs
```

- `b SIZE`: Define o tamanho dos blocos de dados no dispositivo para `SIZE`, que pode ser de `1024`, `2048` ou `4096` bytes por bloco
- `c`: Verifica se existem blocos defeituosos no dispositivo de destino antes de criar o sistema de arquivos. Para fazer uma verificação mais detalhada, porém muito mais lenta, aplique esse parâmetro duas vezes, como em mkfs.ext4 -c -c TARGET.
- `d DIRECTORY`: Copia o conteúdo do diretório especificado para a raiz do novo sistema de arquivos. Útil quando se precisa “pré-preencher” o disco com um conjunto de arquivos predefinido.
- `F`: Perigo! Esta opção força o `mke2fs` a criar um sistema de arquivos, mesmo se as outras opções passadas para ele ou para o alvo forem perigosas ou não fizerem nenhum sentido. Se especificado duas vezes (como em `-F` `-F`), pode inclusive ser usado para criar um sistema de arquivos em um dispositivo montado ou em uso, o que é uma coisa muito, mas muito ruim de se fazer.
- `L VOLUME_LABEL`: Define o rótulo do volume conforme especificado em `VOLUME_LABEL`. Esse rótulo deve ter ao menos **16** caracteres.
- `n`: Esta é uma opção muito útil que simula a criação do sistema de arquivos e mostra o que seria feito se executado sem a opção `n`. Pense nele como um modo de “teste”. É bom verificar as coisas antes de realmente efetuar quaisquer alterações no disco.
- `q`: Modo silencioso. O `mke2fs` será executado normalmente, mas não produzirá nenhuma saída para o terminal. Útil ao executar `mke2fs` a partir de um script.
- `U ID`: Este parâmetro define o `UUID` (Universally Unique Identifier, ou Identificador único universal) de uma partição para o valor especificado como ID. Os `UUID`s são números de `128 bits` em notação hexadecimal que servem para identificar uma partição para o sistema operacional. 

Esse número é especificado como uma string de `32` dígitos no formato `8-4-4-4-12`, ou seja, `8` dígitos, hífen, `4` dígitos, hífen, `4` dígitos, hífen, `4` dígitos, hífen, `12` dígitos, como `D249E380-7719-45A1-813C-35186883987E`. Em vez de um ID, você também pode especificar parâmetros como `clear` para remover o `UUID` do sistema de arquivos, `random` para usar um `UUID` gerado aleatoriamente, ou `time` para criar um `UUID` baseado em tempo.
- `V:` Modo detalhado (ou verboso), exibe muito mais informações durante a operação do que normalmente. Útil para fins de depuração.

---

#### sistema de arquivos XFS

O XFS é um sistema de arquivos de alto desempenho originalmente desenvolvido pela Silicon Graphics em 1993 para seu sistema operacional IRIX. Graças a seu desempenho e recursos de confiabilidade, ele é comumente usado para servidores e outros ambientes que exigem largura de banda alta (ou garantida) do sistema de arquivos.

As ferramentas para gerenciar os sistemas de arquivos XFS são parte do pacote `xfsprogs`. Pode ser preciso instalar esse pacote manualmente, pois ele não vem incluído por padrão em algumas distribuições Linux. Outras, como o Red Hat Enterprise Linux 7, usam o XFS como sistema de arquivos padrão.

Os sistemas de arquivos XFS são divididos em pelo menos 2 partes, uma seção de log, onde é mantido um log de todas as operações do sistema de arquivos (comumente chamadas de Journal, ou diário), e a seção de dados. A seção de log pode estar localizada dentro da seção de dados (que é o comportamento padrão), ou mesmo em um disco separado, para melhor desempenho e confiabilidade.

O comando mais básico para criar um sistema de arquivos XFS é `mkfs.xfs TARGET`, onde `TARGET` é a partição na qual você deseja que o sistema de arquivos seja criado. Por exemplo: `mkfs.xfs /dev/sda1`.

Como no caso do `mke2fs`, o `mkfs.xfs` suporta uma série de opções de linha de comando. Eis algumas das mais comuns.
- `-b size=VALUE`: Define o tamanho do bloco no sistema de arquivos, em bytes, para aquele especificado em `VALUE`. O valor padrão é **4096 bytes** (**4** KiB), o mínimo é **512** e o máximo é **65536** (**64** KiB).
- `-m crc=VALUE`: Os parâmetros iniciados com `-m` são opções de metadados. Este aqui **habilita** (se `VALUE` for `1`) ou **desabilita** (se `VALUE` for `0`) o uso de verificações `CRC32c` para checar a integridade de todos os metadados no disco. Isso permite uma melhor detecção de erros e recuperação de travamentos relacionados a problemas de hardware e, portanto, ele vem habilitado por padrão. O impacto dessa verificação no desempenho costuma ser mínimo e, portanto, normalmente não há razão para desativá-lo.
- `-m uuid=VALUE`: Define o `UUID` da partição conforme o especificado em `VALUE`. Lembre-se de que `UUID`s são números de **32** caracteres (**128** bits) em base hexadecimal, especificados em grupos de **8**, **4**, **4**, **4** e **12** dígitos separados por hífens, como `1E83E3A3-3AE9-4AAC-BF7E-29DFFECD36C0`.
- `-f`: Força a criação de um sistema de arquivos no dispositivo de destino, mesmo se um sistema de arquivos for detectado nele.
- `-l logdev=DEVICE`: Coloca a seção de log do sistema de arquivos no dispositivo especificado, em vez de dentro da seção de dados.
- `-l size=VALUE`: Define o tamanho da seção de log conforme o especificado em `VALUE`. O tamanho pode ser especificado em bytes, e também é possível usar sufixos como `m` ou `g`. `-l size=10m`, por exemplo, limita a seção de log a `10` Megabytes.
- `-q`: Modo silencioso. Neste modo, o `mkfs.xfs` não imprime os parâmetros do sistema de arquivos que está sendo criado.
- `-L LABEL`: Define o rótulo do sistema de arquivos, que pode ter no máximo **12** caracteres.
- `-N`: Semelhante ao parâmetro `-n` do `mke2fs`, faz com que o `mkfs.xfs` exiba todos os parâmetros para a criação do sistema de arquivos, sem realmente criá-lo.

---

#### Criando um sistema de arquivos FAT ou VFAT

O sistema de arquivos FAT originou-se no MS-DOS e, ao longo dos anos, recebeu muitas revisões, culminando no formato FAT32 lançado em 1996 com o Windows 95 OSR2.

O VFAT é uma extensão do formato FAT16 com suporte para nomes de arquivo longos (até 255 caracteres). Ambos os sistemas de arquivos são controlados pelo mesmo utilitário, `mkfs.fat`. `mkfs.vfat` é um nome alternativo para ele.

O sistema de arquivos FAT tem desvantagens importantes que restringem seu uso em discos grandes. O FAT16, por exemplo, suporta volumes de no máximo 4 GB e um tamanho máximo de arquivo de 2 GB. O FAT32 aumenta o tamanho do volume para até 2 PB e o tamanho máximo do arquivo para 4 GB. Por causa disso, os sistemas de arquivos FAT são hoje mais comumente usados em pequenos drives USB ou cartões de memória (de até 2 GB), ou dispositivos e sistemas operacionais legados que não oferecem suporte a sistemas de arquivos mais avançados.

O comando mais básico para a criação de um sistema de arquivos FAT é `mkfs.fat TARGET`, onde `TARGET` é a partição em que você deseja que o sistema de arquivos seja criado. Por exemplo: `mkfs.fat /dev/sdc1`.

Como outros utilitários, o `mkfs.fat` suporta uma série de opções de linha de comando. Abaixo estão as mais importantes. Uma lista completa com a descrição de cada opção pode ser lida no manual do utilitário, com o comando `man mkfs.fat`.

- `-c`: Verifica se existem blocos defeituosos no dispositivo de destino antes de criar o sistema de arquivos.
- `-C FILENAME BLOCK_COUNT`: Cria o arquivo especificado em `FILENAME` e em seguida cria um sistema de arquivos FAT dentro dele, produzindo assim uma “imagem de disco” vazia que pode ser posteriormente gravada em um dispositivo usando um utilitário como o `dd` ou montada como um dispositivo de loopback. Ao usar esta opção, o número de blocos no sistema de arquivos (`BLOCK_COUNT`) deve ser especificado após o nome do dispositivo.
- `-F SIZE`: Seleciona o tamanho do FAT (*File Allocation Table* ou Tabela de Alocação de Arquivos), entre 12, 16 ou 32, ou seja, entre FAT12, FAT16 ou FAT32. Se isso não for especificado, o `mkfs.fat` seleciona a opção apropriada com base no tamanho do sistema de arquivos.
- `-n NAME`: Define o rótulo do volume, ou nome, do sistema de arquivos. Pode ter até **11** caracteres e o padrão é sem nome.
- `-v`: Modo detalhado. Imprime muito mais informações do que o normal, útil para depuração.

>[!NOTE]
>
>O `mkfs.fat` não pode criar um sistema de arquivos “iniciável” De acordo com a página de manual, “isso não é tão fácil quanto você pensa” e não será implementado.

---

#### Btrfs

`BTRFS` - *B-tree File System* (filesystem que visa ser o padrão no Linux futuramente)

BRTFS - Recursos (pronuncia-se “Butter FS”, “Better FS” ou mesmo “Butterfuss”)

É um filesystem moderno em constante desenvolvimento. Foco em tolerância a falhas e facilidade de administração e reparo. Desenvolvido por um grupo de empresas: Oracle, Red Hat, Fujitsu, Intel, SUSE, Facebook, etc

Usado pelo Facebook, TripAdvisor, OpenSUSE, etc

Por ser um sistema de arquivos cópia em gravação (copy-on-write), ele é muito resistente a travamentos. Além disso, o Btrfs é simples de usar e bem suportado por muitas distribuições Linux. Algumas delas, como o SUSE, o usam como sistema de arquivos padrão.

>[!NOTE]
>
>Em um sistema de arquivos tradicional, quando você deseja sobrescrever parte de um arquivo, os novos dados são colocados diretamente sobre os dados antigos que estão substituindo. Em um sistema de arquivos cópia em gravação os novos dados são gravados para liberar espaço em disco, em seguida os metadados originais do arquivo são atualizados para se referir aos novos dados e somente então os dados antigos são liberados, já que não são mais necessários. Isso reduz as chances de perda de dados em caso de travamento, já que os dados antigos só são descartados depois que o sistema de arquivos tem absoluta certeza de que não são mais necessários e os novos dados estão no lugar.

---

#### Recursos do Btrfs

- `Multi-Devices FileSystems` / `RAID` (implementação de RAID dentro do filesystem)
    - Suporta RAID `0`,`1`, `10` (`5` e `6` em desenvolvimento)
    - Normalmente `RAID` é via hardware ou software, e com o `Btrfs`, é diretamente no filesystem
    - No `Btrfs`, o `RAID` **NÃO** precisa ter **HDs idênticos**

- `SubVolumes`:
    - Estrutura dentro de uma partição/volume (semelhante a um diretório)
    - Pode ser montado separadamente



- `Compressão transparente`: compressão que pode ser feita diretamente no filesystem (algoritmos: `zlib`, `LZO`, `ZSTD`) - quem usa o sistema nem percebe que os dados estão sendo comprimidos (lembrar que é uma opção)

>[!NOTE]
>
>`ZSTD` muito usado/desenvolvido pelo Facebook

- `Snapshot`: foto do sistema de arquivos (pode decidir se todos os dias tirar um `snapshot` do filesystem - não é uma cópia de arquivos!)

- `Conversão de ext3 para btrfs`: normalmente a conversão de qualquer outro sistemas de arquivos implica em perda de todos os dados devido à nova formatação. O `Btrfs` tem um recurso para realizar essa conversão sem essa perda de dados. (funciona para `ext2` e `ext4` também)

---

#### Criando um sistema de arquivos Btrfs

O utilitário `mkfs.btrfs` é usado para criar um sistema de arquivos `Btrfs`. Se o comando for usado sem nenhuma opção, ele cria um sistema de arquivos `Btrfs` em um determinado dispositivo, assim:
```
# mkfs.btrfs /dev/sdb1
```

>[!TIP]
>
>Caso não tenha o utilitário `mkfs.btrfs` em seu sistema, procure por `btrfs-progs` no gerenciador de pacotes de sua distribuição.

Você pode usar `-L` para definir um rótulo (ou nome) para o seu sistema de arquivos. Os rótulos `Btrfs` podem ter até **256** caracteres, exceto por quebras de linha:
```
# mkfs.btrfs /dev/sdb1 -L "New Disk"
```

>[!TIP]
>
>Coloque o rótulo entre aspas (como acima) se contiver espaços.

O `Btrfs` tem uma coisa peculiar: é possível incluir múltiplos dispositivos no comando `mkfs.btrfs`. Quando passamos mais de um dispositivo, o sistema de arquivos se estenderá por todos os dispositivos, numa configuração semelhante à de um `RAID` ou `LVM`. Para especificar como os metadados serão distribuídos na matriz de disco, use o parâmetro `-m`. Os parâmetros válidos são `raid0`, `raid1`, `raid5`, `raid6`, `raid10`, `single` e `dup`.

Por exemplo, para criar um sistema de arquivos abrangendo `/dev/sdb1` e `/dev/sdc1`, concatenando as duas partições em uma maior, use:
```
# mkfs.btrfs -d single -m single /dev/sdb /dev/sdc
```

>[!WARNING]
>
>Os sistemas de arquivos abrangendo várias partições, como exemplificado acima, podem parecer vantajosos no início, mas não são uma boa ideia do ponto de vista da segurança de dados, pois uma falha em um único disco da matriz implica em perda de dados com certeza. O risco fica maior quanto mais discos você usa, pois também haverá mais pontos de falha possíveis.

---

#### Gerenciando subvolumes

Subvolumes são como sistemas de arquivos dentro de sistemas de arquivos. Pense neles como um diretório que pode ser montado (e tratado como) um sistema de arquivos independente. Os subvolumes facilitam a organização e a administração do sistema, pois cada um deles pode ter cotas ou regras de snapshot separadas.

>[!NOTE]
>
>Subvolumes não são partições. Uma partição aloca um espaço fixo em uma unidade. Isso pode levar a problemas mais adiante, como uma partição ficando sem espaço quando outra tem bastante espaço restante. Não é assim com subvolumes, já que eles “compartilham” o espaço livre de seu sistema de arquivos raiz e aumentam conforme necessário.

Suponha que você tenha um sistema de arquivos `Btrfs` montado em `/mnt/disk` e deseja criar um subvolume dentro dele para armazenar seus backups. Vamos chamá-lo de `BKP`:
```
# btrfs subvolume create /mnt/disk/BKP
```

A seguir, listamos o conteúdo do sistema de arquivos `/mnt/disk`. Você verá que temos um novo diretório com o mesmo nome do subvolume.
```
$ ls -lh /mnt/disk/
total 0
drwxr-xr-x 1 root   root     0 jul 13 17:35 BKP
drwxrwxr-x 1 carol carol 988 jul 13 17:30 Images
```

>[!NOTE]
>
>Pois é, os subvolumes também podem ser acessados como qualquer outro diretório.

Podemos verificar se o subvolume está ativo com o comando:
```
# btrfs subvolume show /mnt/disk/BKP/
	Name: 			BKP
	UUID: 			e90a1afe-69fa-da4f-9764-3384f66fa32e
	Parent UUID: 		-
	Received UUID: 		-
	Creation time: 		2019-07-13 17:35:40 -0300
	Subvolume ID: 		260
	Generation: 		23
	Gen at creation: 	22
	Parent ID: 		5
	Top level ID: 		5
	Flags: 			-
	Snapshot(s):
```

Você pode montar o subvolume em `/mnt/BKP` passando o parâmetro `-t btrfs -o subvol = NAME` para o comando mount:
```
# mount -t btrfs -o subvol=BKP /dev/sdb1 /mnt/bkp
```

>[!NOTE]
>
>O parâmetro `-t` especifica o tipo de sistema de arquivos a ser montado.

---

#### Trabalhando com snapshots
Os instantâneos (snapshots) são como subvolumes, mas pré-preenchidos com o conteúdo do volume a partir do qual o instantâneo foi obtido.

Quando criado, um instantâneo e o volume original têm exatamente o mesmo conteúdo. Mas a partir desse momento, eles irão divergir. As alterações feitas no volume original (como arquivos adicionados, renomeados ou excluídos) não serão refletidas no instantâneo e vice-versa.

Lembre-se de que um instantâneo não duplica os arquivos e, inicialmente, praticamente não ocupa espaço em disco. Ele simplesmente duplica a árvore do sistema de arquivos enquanto aponta para os dados originais.

O comando para criar um snapshot é o mesmo usado para criar um subvolume, bastando adicionar o parâmetro `snapshot` após `btrfs subvolume`. O comando abaixo cria, em `/mnt/disk/snap`, um instantâneo do sistema de arquivos Btrfs montado em `/mnt/disk`:
```
# btrfs subvolume snapshot /mnt/disk /mnt/disk/snap
```

Agora, imagine que temos o seguinte conteúdo em `/mnt/disk`:
```
$ ls -lh
total 2,8M
-rw-rw-r-- 1 carol carol 109K jul 10 16:22 Galaxy_Note_10.png
-rw-rw-r-- 1 carol carol 484K jul  5 15:01 geminoid2.jpg
-rw-rw-r-- 1 carol carol 429K jul  5 14:52 geminoid.jpg
-rw-rw-r-- 1 carol carol 467K jul  2 11:48 LG-G8S-ThinQ-Mirror-White.jpg
-rw-rw-r-- 1 carol carol 654K jul  2 11:39 LG-G8S-ThinQ-Range.jpg
-rw-rw-r-- 1 carol carol  94K jul  2 15:43 Mimoji_Comparativo.jpg
-rw-rw-r-- 1 carol carol 112K jul 10 16:20 Note10Plus.jpg
drwx------ 1 carol carol  366 jul 13 17:56 snap
-rw-rw-r-- 1 carol carol 118K jul 11 16:36 Twitter_Down_20190711.jpg
-rw-rw-r-- 1 carol carol 324K jul  2 15:22 Xiaomi_Mimoji.png
```

Observe o diretório de snap que contém o instantâneo. Agora vamos remover alguns arquivos e verificar o conteúdo do diretório:
```
$ rm LG-G8S-ThinQ-*
$ ls -lh
total 1,7M
-rw-rw-r-- 1 carol carol 109K jul 10 16:22 Galaxy_Note_10.png
-rw-rw-r-- 1 carol carol 484K jul  5 15:01 geminoid2.jpg
-rw-rw-r-- 1 carol carol 429K jul  5 14:52 geminoid.jpg
-rw-rw-r-- 1 carol carol  94K jul  2 15:43 Mimoji_Comparativo.jpg
-rw-rw-r-- 1 carol carol 112K jul 10 16:20 Note10Plus.jpg
drwx------ 1 carol carol  366 jul 13 17:56 snap
-rw-rw-r-- 1 carol carol 118K jul 11 16:36 Twitter_Down_20190711.jpg
-rw-rw-r-- 1 carol carol 324K jul  2 15:22 Xiaomi_Mimoji.png
```

No entanto, se você verificar dentro do diretório snap, os arquivos excluídos ainda estarão lá e poderão ser restaurados, se necessário.
```
$ ls -lh snap/
total 2,8M
-rw-rw-r-- 1 carol carol 109K jul 10 16:22 Galaxy_Note_10.png
-rw-rw-r-- 1 carol carol 484K jul  5 15:01 geminoid2.jpg
-rw-rw-r-- 1 carol carol 429K jul  5 14:52 geminoid.jpg
-rw-rw-r-- 1 carol carol 467K jul  2 11:48 LG-G8S-ThinQ-Mirror-White.jpg
-rw-rw-r-- 1 carol carol 654K jul  2 11:39 LG-G8S-ThinQ-Range.jpg
-rw-rw-r-- 1 carol carol  94K jul  2 15:43 Mimoji_Comparativo.jpg
-rw-rw-r-- 1 carol carol 112K jul 10 16:20 Note10Plus.jpg
-rw-rw-r-- 1 carol carol 118K jul 11 16:36 Twitter_Down_20190711.jpg
-rw-rw-r-- 1 carol carol 324K jul  2 15:22 Xiaomi_Mimoji.png
```

Também é possível criar instantâneos somente leitura. Eles funcionam exatamente como os instantâneos graváveis, com a diferença de que o conteúdo do instantâneo não pode ser alterado, eles são “congelados” no tempo. Basta adicionar o parâmetro `-r` ao criar o instantâneo:
```
# btrfs subvolume snapshot -r /mnt/disk /mnt/disk/snap
```

---

#### Algumas palavras sobre compactação

O Btrfs suporta a compactação transparente de arquivos, com três algoritmos diferentes disponíveis para o usuário. Isso é feito automaticamente arquivo por arquivo, contanto que o sistema de arquivos seja montado com a opção `-o compress`. Os algoritmos são inteligentes o bastante para detectar arquivos incompressíveis e não tentarão compactá-los, economizando recursos do sistema. Assim, em um único diretório, você pode ter arquivos compactados e descompactados juntos. O algoritmo de compressão padrão é o `ZLIB`, mas o `LZO` (mais rápido, taxa de compressão pior) ou o `ZSTD` (mais rápido que o `ZLIB`, compressão comparável) estão disponíveis, com diversos níveis de compressão (veja o objetivo correspondente nas opções de montagem)

---

#### exFAT

`exFAT` = Extended FAT, ou FAT64 (evolução do FAT32)

O exFAT é um sistema de arquivos criado pela Microsoft em 2006 que aborda uma das limitações mais importantes do FAT32: o tamanho do arquivo e do disco. No exFAT, o tamanho máximo do arquivo é de 16 exabytes (no FAT32 eram 4 GB) e o tamanho máximo do disco é de 128 petabytes.

Como é bem suportado pelos três principais sistemas operacionais (Windows, Linux e macOS), trata-se de uma boa escolha nos casos em que a interoperabilidade é necessária, como em drives flash de grande capacidade, cartões de memória e discos externos. Na verdade, esse é o sistema de arquivos padrão, conforme definido pela SD Association, para os cartões de memória SDXC com mais de 32 GB.

- É um filesystem otimizado para pen drives/flash drives e cartões de memória
- filesystem padrão para os cartões SDXC maiores que 32 GB
- Intermediário entre o FAT e o NTFS
- Mais simples e leve que o NTFS
- Permite arquivos maiores que o FAT
- No FAT32 o limite é `4GB` para arquivos, no exFAT é `16` EB (`exabyte` - antes temos o `terabyte` > `petabyte` > `exabyte`)
- No linux é implementado pelos pacotes `exfat-fuse` e `extfat-utils` (o exFAT é proprietário da Microsoft)

Para trabalhar com exFAT no Linux, precisamos instalar os pacotes (suporte ao exFAT e as ferramentas):
```
apt install exfat-fuse extfat-utils
```

Para criar um pendrive ou sdcard em exFAT, use o comando:
```
mkfs -t exfat /dev/sdb1
```

Também poderia usar: `mkfs.exfat /dev/sdb1` (que é um link para `mkexfatfs`)

Ao contrário dos outros utilitários discutidos nesta lição, o `mkfs.exfat` tem pouquíssimas opções de linha de comando. Elas são:

- `i VOL_ID`: Define o ID do Volume para o valor especificado em `VOL_ID`. Este é um número hexadecimal de **32** bits. Se não for definido, é criado um ID com base na hora atual.
- `n NAME`: Define o rótulo ou nome do volume. Pode ter até **15** caracteres e o padrão é sem nome.
- `p SECTOR`: Especifica o primeiro setor da primeira partição no disco. Este é um valor opcional e o padrão é zero.
- `s SECTORS`: Define o número de setores físicos por cluster de alocação. Deve ser uma potência de dois, como 1, 2, 4, 8 e assim por diante.

Podemos testar montando o dispositivo: `mount /dev/sdb1 /media/pendrive`

Com o comando `df -T` ou `--print-type`, podemos encontrar o pendrive, mostrando o type dele como `fuseblk` (não mostra explicitamente como `exFAT`)

Já com o comando `blkid` (*locate/print block device attributes*) nos mostra como `exFAT` com mais detalhes (mostra todos os pontos de montagens)

---

#### PARTED

Similar ao `fdisk`, no entanto com a grande vantagem de que o `parted` pode redimensionar o tamanho das partições. Pode ser usado para criar, excluir, mover, redimensionar, resgatar e copiar partições

- `parted /dev/sdb`: depois escolha o disco, ou dentro do `parted`: `(parted) select /dev/sdb` (para selecionar o disco)

>[!NOTE]
>
>As mesmas opções do `fdisk` funcionam no `parted`

Por exemplo, o `p` lista as partições, e adicionalmente mostra o `FileSystem`.
```
(parted) p                                                                
Model: ATA QEMU HARDDISK (scsi)
Disk /dev/sda: 10.7GB
Sector size (logical/physical): 512B/512B
Partition Table: msdos
Disk Flags: 

Number  Start   End     Size    Type      File system     Flags
 1      1049kB  2149MB  2147MB  primary   ext3
 2      2149MB  3222MB  1074MB  primary   fat32
 3      3222MB  4296MB  1074MB  primary
 4      4296MB  10.7GB  6441MB  extended
 5      4297MB  4821MB  524MB   logical   linux-swap(v1)
 6      4822MB  5896MB  1074MB  logical                   swap
```

>[!WARNING]
>
>Diferente de `fdisk` e `gdisk`, o `parted` faz alterações no disco **imediatamente** após o comando ser emitido, sem esperar por outro comando para gravar as alterações

>[!WARNING]
>
>**Tenha cuidado**! Se você não especificar um dispositivo, o `parted` seleciona automaticamente o disco primário (normalmente `/dev/sda`) para operar.

---

#### Selecionando discos

Para mudar para um disco diferente do especificado na linha de comando, usamos o comando `select`, seguido pelo nome do dispositivo (use `print devices` para consultar os discos disponíveis):
```
(parted) select /dev/sdb
Using /dev/sdb
```

---

#### Obtendo informações

O comando `print` pode ser usado para obter mais informações sobre uma partição específica ou até mesmo todos os dispositivos de bloco (discos) conectados ao seu sistema.

Para obter informações sobre a partição atualmente selecionada, basta digitar `print`:
```
(parted) print
Model: ATA CT120BX500SSD1 (scsi)
Disk /dev/sda: 120GB
Sector size (logical/physical): 512B/512B
Partition Table: msdos
Disk Flags:

Number  Start   End    Size    Type     File system     Flags
 1      2097kB  116GB  116GB   primary  ext4
 2      116GB   120GB  4295MB  primary  linux-swap(v1)
```

Use `print devices` para obter uma lista de todos os dispositivos de bloco conectados ao seu sistema:
```
(parted) print devices
/dev/sdb (1999MB)
/dev/sda (120GB)
/dev/sdc (320GB)
/dev/mapper/cryptswap (4294MB)
```

Para obter informações sobre todos os dispositivos conectados de uma vez, usamos `print all`. Se quiser saber quanto espaço livre existe em cada um deles, o comando é `print free`:
```
(parted) print free
Model: ATA CT120BX500SSD1 (scsi)
Disk /dev/sda: 120GB
Sector size (logical/physical): 512B/512B
Partition Table: msdos
Disk Flags:

Number  Start   End     Size    Type     File system     Flags
        32.3kB  2097kB  2065kB           Free Space
 1      2097kB  116GB   116GB   primary  ext4
        116GB   116GB   512B             Free Space
 2      116GB   120GB   4295MB  primary  linux-swap(v1)
        120GB   120GB   2098kB           Free Space
```

---

#### Criando uma tabela de partição em um disco vazio

Para criar uma tabela de partição em um disco vazio, use o comando `mklabel`, seguido pelo tipo de tabela de partição que deseja usar.

Existem muitos tipos suportados de tabelas de partição, mas os principais que você deve conhecer são `msdos`, usado aqui para se referir a uma tabela de partição MBR, e `gpt` para se referir a uma tabela de partição GPT. Para criar uma tabela de partição MBR, digite:
```
(parted) mklabel msdos
```

E para criar uma tabela de partição GPT, o comando é:
```
(parted) mklabel gpt
```

---

#### Criando uma partição

Para criar uma partição, usamos o comando `mkpart` com a sintaxe `mkpart PARTTYPE FSTYPE START END`, onde:
- `PARTTYPE`: É o tipo de partição, que pode ser `primary`, `logical` ou `extended` no caso de uma tabela de partição MBR.
- `FSTYPE`: Especifica qual sistema de arquivos será usado nesta partição. Note que `parted` não cria o sistema de arquivos. Ele apenas define um sinalizador na partição que informa ao sistema operacional que tipo de dados esperar dela.
- `START`: Especifica o ponto exato no dispositivo onde a partição começa. Você pode usar unidades diferentes para especificar esse ponto. `2s` pode ser usado para se referir ao segundo setor do disco, ao passo que `1m` se refere ao início do primeiro megabyte do disco. Outras unidades comuns são `B` (bytes) e `%` (porcentagem do disco).
- `END`: Especifica o fim da partição. Observe que este não é o tamanho da partição, este é o ponto no disco onde ele termina. Por exemplo, se você especificar `100m`, a partição terminará 100 MB após o início do disco. Podemos usar as mesmas unidades do parâmetro `START`.

Assim, o comando:
```
(parted) mkpart primary ext4 1m 100m
```

Cria uma partição primária do tipo `ext4`, começando no primeiro megabyte do disco e terminando após o 100º megabyte.

---

#### Removendo uma partição

Para remover uma partição, use o comando `rm` seguido pelo número da partição, que você pode exibir usando o comando print. Portanto, `rm 2` removeria a segunda partição no disco atualmente selecionado.

---

#### Recuperando partições

O `parted` é capaz de recuperar uma partição excluída. Considere que temos a seguinte estrutura de partição:
```
Number  Start   End     Size    File system  Name     Flags
 1      1049kB  99.6MB  98.6MB  ext4         primary
 2      99.6MB  200MB   100MB   ext4         primary
 3      200MB   300MB   99.6MB  ext4         primary
```

Por acidente, você removeu a partição 2 usando `rm 2`. Para recuperá-la, pode-se usar o comando `rescue`, com a sintaxe `rescue START END`, onde `START` é o local aproximado onde a partição começava e `END` o local aproximado onde terminava.

O `parted` irá analisar o disco em busca de partições e se oferecer para restaurar as que forem encontradas. No exemplo acima, a partição 2 começava em 99,6 MB e terminava em 200 MB. Portanto, você pode usar o seguinte comando para recuperar a partição:
```
(parted) rescue 90m 210m
Information: A ext4 primary partition was found at 99.6MB -> 200MB.
Do you want to add it to the partition table?

Yes/No/Cancel? y
```

A partição e seu conteúdo serão recuperados dessa forma. Note que o `rescue` só pode recuperar partições em que haja um sistema de arquivos instalado. Partições vazias não são detectadas.

#### Redimensionar o disco

O parted pode ser usado para redimensionar partições, tornando-as maiores ou menores. No entanto, existem algumas ressalvas:

- Durante o redimensionamento, a partição deve estar desmontada e não estar em uso.
- É preciso ter espaço livre suficiente após a partição para que ela possa ser ampliada no tamanho que se deseja.

O comando é `resizepart`, seguido pelo `número da partição` e o `ponto onde deve terminar`. Por exemplo, se tivermos a seguinte tabela de partição:
```
Number  Start   End     Size    File system  Name     Flags
 1      1049kB  99.6MB  98.6MB  ext4         primary
 2      99.6MB  200MB   100MB   ext4
 3      200MB   300MB   99.6MB  ext4         primary
```

Se tentarmos aumentar a partição `1` usando `resizepart`, uma mensagem de erro seria disparada, já que, com o novo tamanho, a partição 1 se sobreporia à partição `2`. No entanto, a partição `3` pode ser redimensionada, já que há espaço livre depois dela, o que pode ser verificado com o comando `print free`:
```
(parted) print free
Model: Kingston DataTraveler 2.0 (scsi)
Disk /dev/sdb: 1999MB
Sector size (logical/physical): 512B/512B
Partition Table: gpt
Disk Flags:

 Number  Start   End     Size    File system  Name     Flags
        17.4kB  1049kB  1031kB  Free Space
 1      1049kB  99.6MB  98.6MB  ext4         primary
 2      99.6MB  200MB   100MB   ext4
 3      200MB   300MB   99.6MB  ext4         primary
        300MB   1999MB  1699MB  Free Space
```

Portanto, podemos usar o seguinte comando para redimensionar a partição `3` para `350` MB:
```
(parted) resizepart 3 350m

(parted) print
Model: Kingston DataTraveler 2.0 (scsi)
Disk /dev/sdb: 1999MB
Sector size (logical/physical): 512B/512B
Partition Table: gpt
Disk Flags:

Number  Start   End     Size    File system  Name     Flags
 1      1049kB  99.6MB  98.6MB  ext4         primary
 2      99.6MB  200MB   100MB   ext4
 3      200MB   350MB   150MB   ext4         primary
```

Lembre-se de que o novo ponto final é especificado a partir do início do disco. Então, como a partição 3 terminava em 300 MB, agora ela precisa terminar em 350 MB.

Mas redimensionar a partição é apenas parte da tarefa. Você também precisa redimensionar o sistema de arquivos que reside nela. Para sistemas de arquivos `ext2`/`3`/`4`, isso é feito com o comando `resize2fs`. No caso do exemplo acima, a partição 3 ainda mostra o tamanho “antigo” quando montada:
```
$ df -h /dev/sdb3
Filesystem      Size  Used Avail Use% Mounted on
/dev/sdb3        88M  1.6M   80M   2% /media/carol/part3
```

Para ajustar o tamanho, o comando `resize2fs DEVICE SIZE` pode ser usado, onde `DEVICE` corresponde à partição que você deseja redimensionar e `SIZE` é o novo tamanho. Se você omitir o parâmetro de tamanho, ele usará todo o espaço disponível da partição. Antes de redimensionar, é aconselhável desmontar a partição.

No exemplo acima:
```
$ sudo resize2fs /dev/sdb3
resize2fs 1.44.6 (5-Mar-2019)
Resizing the filesystem on /dev/sdb3 to 146212 (1k) blocks.
The filesystem on /dev/sdb3 is now 146212 (1k) blocks long.

$ df -h /dev/sdb3
Filesystem      Size  Used Avail Use% Mounted on
/dev/sdb3       135M  1.6M  123M   2% /media/carol/part3
```

Para **encolher** uma partição, o processo deve ser feito na ordem inversa. Primeiro você redimensiona o sistema de arquivos para um tamanho novo e menor, em seguida redimensiona a própria partição usando `parted`.

>[!WARNING]
>
>Preste atenção ao reduzir partições. Se errar na ordem das coisas, você vai perder dados!

Em nosso exemplo:
```
# resize2fs /dev/sdb3 88m
resize2fs 1.44.6 (5-Mar-2019)
Resizing the filesystem on /dev/sdb3 to 90112 (1k) blocks.
The filesystem on /dev/sdb3 is now 90112 (1k) blocks long.

# parted /dev/sdb3
(parted) resizepart 3 300m
Warning: Shrinking a partition can cause data loss, are you sure
you want to continue?

Yes/No? y

(parted) print
Model: Kingston DataTraveler 2.0 (scsi)
Disk /dev/sdb: 1999MB
Sector size (logical/physical): 512B/512B
Partition Table: gpt
Disk Flags:

Number  Start   End     Size    File system  Name     Flags
 1      1049kB  99.6MB  98.6MB  ext4         primary
 2      99.6MB  200MB   100MB   ext4
 3      200MB   300MB   99.7MB  ext4         primary
 ```
 
 >[!TIP]
 >
 >
Em vez de especificar um novo tamanho, você pode usar o parâmetro `-M` de `resize2fs` para ajustar o tamanho do sistema de arquivos, deixando-o grande o suficiente para os arquivos que contém.

>[!NOTE]
>
>Em linhas gerais, o `fdisk` é mais simples de usar (criar, excluir partições). Sendo o `parted` utilizado apenas quando tiver que redimencionar alguma partição.

---

#### GPARTED

`gparted` é o `parted` em modo gráfico para **Gnome**. Para desktops **KDE** há o `Partition Manager`.

comandos dentro dele:

- `print`: informações sobre a partição selecionada
- `print devices`: lista todos dispositivos de blocos conectados no sistema
- `print all`: informações de todos os dispositivos conectados
- `print free`: mostra espaço livre
- `mklabel` (`msdos` ou `gpt`): cria tabela de partição
- `parted -l`: mostra os tipos das partições
- `lsblk -f` ou `--fs`: faz o mesmo que o comando anterior (*list block devices*)
- `blkid`: também o mesmo (*locate/print block device attributes*)

---

#### um pouco mais sobre swap

Para criar a partição `swap` usando `fdisk` ou `gdisk`, proceda como se estivesse criando uma partição normal, conforme explicado anteriormente. A única diferença é que você precisará alterar o tipo de partição para Linux swap.
- No `fdisk`, use o comando t. Selecione a partição que deseja usar e mude seu tipo para **82**. Grave as alterações no disco e saia com `w`.
- No `gdisk`, o comando para alterar o tipo de partição também é `t`, mas o código é `8200`. Grave as alterações no disco e saia com `w`.

Se estiver usando o `parted`, a partição deve ser identificada como uma partição de troca durante a criação, apenas use `linux-swap` como tipo de sistema de arquivos. Por exemplo, o comando para criar uma partição de troca de 500 MB, começando com 300 MB no disco é:
```
(parted) mkpart primary linux-swap 301m 800m
```

Assim que a partição for criada e devidamente identificada, basta usar `mkswap` seguido do dispositivo que representa a partição que deseja usar, como:
```
# mkswap /dev/sda2
```

Para habilitar a troca nesta partição, use `swapon` seguido do nome do dispositivo:
```
# swapon /dev/sda2
```

Da mesma forma, `swapoff`, seguido pelo nome do dispositivo, desabilita a troca naquele dispositivo.

O Linux também suporta o uso de arquivos de troca em vez de partições. Basta criar um arquivo vazio do tamanho que desejar usando `dd` e então usar `mkswap` e `swapon` tendo esse arquivo como destino.

Os comandos a seguir criam um arquivo de **1** GB chamado `myswap` no diretório atual, preenchido com zeros, e então o configuram e habilitam como um arquivo de troca.

Crie o arquivo de troca:
```
$ dd if=/dev/zero of=myswap bs=1M count=1024
1024+0 records in
1024+0 records out
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 7.49254 s, 143 MB/s
```

- `if =`: é o arquivo de entrada, a fonte dos dados que serão gravados no arquivo. Neste caso, é o dispositivo `/dev/zero`, que fornece tantos caracteres `NULL` quanto solicitados. 
- `of =`: é o arquivo de saída, o arquivo que será criado. - `bs =`: é o tamanho dos blocos de dados, especificados aqui em Megabytes, e c
- `count =:` é a quantidade de blocos a serem gravados na saída. 1.024 blocos de 1 MB cada equivalem a 1 GB.

#### mkswap myswap
Setting up swapspace version 1, size = 1024 MiB (1073737728 bytes)
no label, UUID=49c53bc4-c4b1-4a8b-a613-8f42cb275b2b

#### swapon myswap
Usando os comandos acima, este arquivo de troca será usado apenas durante a sessão atual do sistema. Se a máquina for reinicializada, o arquivo ainda estará disponível, mas não será carregado automaticamente. Você pode automatizar esse processo adicionando o novo arquivo de troca a `/etc/fstab`, que discutiremos em uma lição posterior.

>[!TIP]
>
>Tanto o `mkswap` quanto o `swapon` vão reclamar se seu arquivo de troca tiver permissões inseguras. O sinalizador de permissão de arquivo recomendado é `0600`. O proprietário e o grupo devem ser `root`.

---

#### exercícios interessantes da lpi.org

1. Imagine que você tenha `2` partições, uma em `/dev/sda1` e outra em `/dev/sda2`, ambas com **20 GB** de tamanho. Como você pode usá-las em um único sistema de arquivos `Btrfs`, de forma que o conteúdo de uma partição seja automaticamente espelhado na outra, como em uma configuração `RAID1`? Qual será o tamanho do sistema de arquivos?

**Resposta**: O comando seria `mkfs.btrfs /dev/sda1 /dev/sdb1 -m raid1`. O sistema de arquivos resultante teria um tamanho de **20 GB**, já que uma partição age simplesmente como um espelho da outra.

2. Considere um disco de 2 GB com uma tabela de partição MBR e o seguinte layout:
```
Disk /dev/sdb: 1.9 GiB, 1998631936 bytes, 3903578 sectors
Disk model: DataTraveler 2.0
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x31a83a48

Device     Boot   Start     End Sectors  Size Id Type
/dev/sdb1          2048 1050623 1048576  512M 83 Linux
/dev/sdb3       2099200 3147775 1048576  512M 83 Linux
```

É possível criar uma partição de 600 MB nele? Por quê?

**Resposta**: Não, pois não há espaço contíguo suficiente. A primeira pista de que tem algo “errado” é a lista de dispositivos: temos `/dev/sdb1` e `/dev/sdb3`, mas não `/dev/sdb2`. Então, algo está faltando.

Em seguida, precisamos ver onde uma partição termina e onde a outra começa. A partição um termina no setor 1050623, e a partição 2 no 2099200. Há uma “lacuna” de 1048577 setores. Como cada setor tem 512 bytes, o total seriam 536.871.424 bytes. Dividindo por 1024, obtemos 524.288 Kilobytes. Dividimos por 1024 novamente e obtemos…​ 512 MB. Esse é o tamanho da “lacuna”.

Se o disco tem 2 GB, resta então um máximo de 512 MB após a partição 3. Mesmo que no total haja cerca de 1 GB não-alocado, o maior bloco contíguo tem 512 MB. Portanto, não há espaço para uma partição de 600 MB.

3. Em um disco em `/dev/sdc`, temos uma primeira partição de 1 GB contendo cerca de 256 MB de arquivos. Usando `parted`, como podemos reduzi-la para que tenha somente espaço suficiente para os arquivos?

**Resposta**: Essa operação teria várias etapas. 
- Primeiro, encolhemos o sistema de arquivos usando `resize2fs`. Ao invés de especificar o novo tamanho diretamente, podemos usar o parâmetro `-M` para que ele fique “grande o bastante”. Assim: `resize2fs -M /dev/sdc1`.

- Em seguida, redimensionamos a própria partição com o parted usando `resizepart`. Como se trata da primeira partição, podemos pressupor que ela começa em zero e termina em `241 MB`. Assim, o comando seria `resizepart 1 241M`.

4. Ao longo desta lição, você experimentou alguns comandos no `parted` mas, por engano, excluiu a 3ª partição do seu disco rígido. Você sabe que ela vinha depois de uma partição UEFI de 250 MB e de uma partição de troca de 4 GB, e tinha 10 GB de tamanho. Qual comando você pode usar para recuperá-la?

Não entre em pânico, você tem todas as informações necessárias para recuperar a partição. Basta usar `rescue` e fazer as contas. Você tinha 250 MB + 4096 MB (4*1024) antes, então o ponto inicial deve ser em torno de 4346 MB. Juntando com 10.240 MB (10*1024) de tamanho, ela deve terminar em 14.586 MB. Então, `rescue 4346m 14586m` deve resolver o problema. Pode ser preciso dar um pouco de “folga” ao rescue, começando um pouco antes e terminando um pouco depois, dependendo da geometria do seu disco.

---

### 104.2 Manutenção da integridade de sistemas de arquivos

#### df 

O comando `df` fornece uma lista de todos os sistemas de arquivos disponíveis (já montados) em seu sistema, incluindo o tamanho total, quanto espaço foi usado, quanto espaço está disponível, a porcentagem de uso e onde estão montados
```
$ df
Filesystem     1K-blocks      Used Available Use% Mounted on
udev             2943068         0   2943068   0% /dev
tmpfs             595892      2496    593396   1% /run
/dev/sda1      110722904  25600600  79454800  25% /
tmpfs            2979440    951208   2028232  32% /dev/shm
tmpfs               5120         0      5120   0% /run/lock
tmpfs            2979440         0   2979440   0% /sys/fs/cgroup
tmpfs             595888        24    595864   1% /run/user/119
tmpfs             595888       116    595772   1% /run/user/1000
/dev/sdb1          89111      1550     80824   2% /media/carol/part1
```

- `df`: *report file system disk space usage* (mostra informações de uso, disponibilidade - **partição precisa estar montada**) pode usar apontando a partição. Ex. `df -h /home` ou `--human-readable`
- `df -h` ou `--human-readable`: mostra de forma mais fácil de entender
```
$ df -h
Filesystem      Size  Used Avail Use% Mounted on
udev            2.9G     0  2.9G   0% /dev
tmpfs           582M  2.5M  580M   1% /run
/dev/sda1       106G   25G   76G  25% /
tmpfs           2.9G  930M  2.0G  32% /dev/shm
tmpfs           5.0M     0  5.0M   0% /run/lock
tmpfs           2.9G     0  2.9G   0% /sys/fs/cgroup
tmpfs           582M   24K  582M   1% /run/user/119
tmpfs           582M  116K  582M   1% /run/user/1000
/dev/sdb1        88M  1.6M   79M   2% /media/carol/part1
```

- `df -T` ou `--print-type`: mostra também o tipo de cada filesystem
```
Um parâmetro útil é -T, que também imprime o tipo de cada sistema de arquivos:

$ df -hT
Filesystem     Type      Size  Used Avail Use% Mounted on
udev           devtmpfs  2.9G     0  2.9G   0% /dev
tmpfs          tmpfs     582M  2.5M  580M   1% /run
/dev/sda1      ext4      106G   25G   76G  25% /
tmpfs          tmpfs     2.9G  930M  2.0G  32% /dev/shm
tmpfs          tmpfs     5.0M     0  5.0M   0% /run/lock
tmpfs          tmpfs     2.9G     0  2.9G   0% /sys/fs/cgroup
tmpfs          tmpfs     582M   24K  582M   1% /run/user/119
tmpfs          tmpfs     582M  116K  582M   1% /run/user/1000
/dev/sdb1      ext4       88M  1.6M   79M   2% /media/carol/part1
```

- `df -ht xfs` ou `--type`: mostra só as partições que são `xfs`
```
# df -ht xfs
Filesystem           Size  Used Avail Use% Mounted on
/dev/mapper/cs-root   17G  5.8G   12G  35% /
/dev/vda1            960M  458M  503M  48% /boot
/dev/sdb1            960M   39M  922M   5% /mnt/xfs
```

- `df -hx xfs` ou `--exclude-type`: mostra as partições, exceto `xfs`
```
# df -hx xfs
Filesystem      Size  Used Avail Use% Mounted on
devtmpfs        4.0M     0  4.0M   0% /dev
tmpfs           634M     0  634M   0% /dev/shm
tmpfs           254M  5.5M  249M   3% /run
tmpfs           127M   52K  127M   1% /run/user/42
tmpfs           127M   36K  127M   1% /run/user/1000
```

- `df -i` ou `--inodes`: mostra os **inodes** disponíveis e usados, por partição. (lembra `ls -li`, que traz o inode de cada arquivo/diretório)
```
$ df -i
Filesystem      Inodes  IUsed   IFree IUse% Mounted on
udev            737142    547  736595    1% /dev
tmpfs           745218    908  744310    1% /run
/dev/sda6      6766592 307153 6459439    5% /
tmpfs           745218    215  745003    1% /dev/shm
tmpfs           745218      4  745214    1% /run/lock
tmpfs           745218     18  745200    1% /sys/fs/cgroup
/dev/sda1        62464    355   62109    1% /boot
tmpfs           745218     43  745175    1% /run/user/1000
```

>[!NOTE]
>
>O comando `df -i` é bom para verificar quando o sistema está informando que está sem espaço, no entanto há espaço disponível, mas é muito provável que tenha chegado ao limite dos inodes.

Também podemos personalizar a saída de `df`, selecionando o que deve ser exibido e em que ordem, usando o parâmetro `--output=` seguido por uma lista separada por vírgulas dos campos que desejamos exibir. Alguns dos campos disponíveis são:
- `source`: O dispositivo correspondente ao sistema de arquivos.
- `fstype`: O tipo de sistema de arquivos.
- `size`: O tamanho total do sistema de arquivos.
- `used`: Quanto espaço está sendo usado.
- `avail`: Quanto espaço está disponível.
- `pcent`: A porcentagem de uso.
- `target`: Onde o sistema de arquivos é montado (ponto de montagem).

Se quiser uma saída mostrando o `destino`, a `fonte`, o `tipo` e o `uso`, você pode usar:
```
$ df -h --output=target,source,fstype,pcent
Mounted on                    Filesystem     Type     Use%
/dev                          udev           devtmpfs   0%
/run                          tmpfs          tmpfs      1%
/                             /dev/sda1      ext4      25%
/dev/shm                      tmpfs          tmpfs     32%
/run/lock                     tmpfs          tmpfs      0%
/sys/fs/cgroup                tmpfs          tmpfs      0%
/run/user/119                 tmpfs          tmpfs      1%
/run/user/1000                tmpfs          tmpfs      1%
/media/carol/part1            /dev/sdb1      ext4       2%
/media/carol/part3            /dev/sdb3      ext4       3%
/media/carol/part2            /dev/sdb2      ext4       3%
/media/carol/Samsung Externo  /dev/sdc1      fuseblk   75%
```

O `df` também pode ser usado para verificar as informações do `inode`, passando os seguintes campos para `--output=`:
 `itotal`: O número total de `inodes` no sistema de arquivos.
- `iused`: O número de `inodes` usados no sistema de arquivos.
- `iavail`: O número de `inodes` disponíveis no sistema de arquivos.
- `ipcent`: A porcentagem de `inodes` usados no sistema de arquivos.

Por exemplo:
```
$ df --output=source,fstype,itotal,iused,ipcent
Filesystem     Type      Inodes  IUsed IUse%
udev           devtmpfs  735764    593    1%
tmpfs          tmpfs     744858   1048    1%
/dev/sda1      ext4     7069696 318651    5%
tmpfs          tmpfs     744858    222    1%
tmpfs          tmpfs     744858      3    1%
tmpfs          tmpfs     744858     18    1%
tmpfs          tmpfs     744858     22    1%
tmpfs          tmpfs     744858     40    1%
```

---

#### du (disk usage)

O `du` é recursivo por natureza. Em sua forma mais básica, o comando simplesmente mostra quantos blocos de 1 Kilobyte estão sendo usados pelo diretório atual e todos os seus subdiretórios

- `du`: mostra o espaço que está sendo usado por cada dos diretórios (*estimate file space usage*)
- `du -a` ou `--all`: mostra também os arquivos. (pode usar `-h` `--human-readable`)

```
$ du
4816	.
```

Isso não é muito útil, então podemos solicitar uma saída maior e “legível por humanos” adicionando o parâmetro `-h`:
```
$ du -h
4.8M	.
```

Por padrão, o `du` só mostra a contagem de uso para os diretórios (considerando todos os arquivos e subdiretórios dentro deles). Para mostrar uma contagem individual para todos os arquivos no diretório, usamos o parâmetro `-a`:
```
$ du -ah
432K	./geminoid.jpg
508K	./Linear_B_Hero.jpg
468K	./LG-G8S-ThinQ-Mirror-White.jpg
656K	./LG-G8S-ThinQ-Range.jpg
60K	./Stranger3_Titulo.png
108K	./Baidu_Banho.jpg
324K	./Xiaomi_Mimoji.png
284K	./Mi_CC_9e.jpg
96K	./Mimoji_Comparativo.jpg
```

O comportamento padrão é mostrar o uso de cada subdiretório e, em seguida, o uso total do diretório atual, incluindo subdiretórios:
```
$ du -h
4.8M	./Temp
6.0M	.
```

No exemplo acima, podemos ver que o subdiretório `Temp` ocupa `4,8 MB` e o diretório atual, incluindo `Temp`, ocupa `6,0 MB`. Mas quanto espaço os arquivos no diretório atual ocupam, excluindo os subdiretórios? Para isso temos o parâmetro `-S`:
```
$ du -Sh
4.8M	./Temp
1.3M	.
```

>[!NOTE]
>
>O `du` explora os diretórios indicados de forma recursiva (recursivo por natureza)

- `du -c` ou `--total`: sumariza o total de uso no final da saída do programa.
- `du -s` ou `--summarize`: mostra apenas o total por cada argumento (não pode usar em conjunto do `-a`)
- `du -sh /home`: indica um diretório
- `du -sh /var/*`: ver cada diretório em `/var`

>[!IMPORTANT]
>
>Observe que, mesmo que não esteja sendo mostrado o restante dos diretórios, seus tamanhos ainda estão sendo levados em consideração (irão imprimir o mesmo valor do tamanho)

---

#### Limitar a profundidade nos diretórios:

- `du -h /var`: vai até o final de cada diretório em `/var`
- `du -h --max-depth=2 /var` ou `-d`: vai até no máximo 2 níveis de diretório

sem `-d`
```
$ du -h
216K	./somedir/anotherdir
224K	./somedir
232K	.
```

com `-d`
```
$ du -h -d1
224K	./somedir
232K	.
```

Observe que, mesmo que anotherdir não esteja sendo mostrado, seu tamanho ainda está sendo levado em consideração.

Você pode querer excluir alguns tipos de arquivos da contagem, o que é feito com `--exclude="PATTERN"`, onde `PATTERN` é o padrão que deve ser correspondido. Considere este diretório:
```
$ du -ah
124K	./ASM68K.EXE
2.0M	./Contra.bin
36K	./fixheadr.exe
4.0K	./README.txt
2.1M	./Contra_NEW.bin
4.0K	./Built.bat
8.0K	./Contra_Main.asm
4.2M	.
```

Agora, usamos `--exclude` para filtrar todos os arquivos com a extensão `.bin`:
```
$ du -ah --exclude="*.bin"
124K	./ASM68K.EXE
36K	./fixheadr.exe
4.0K	./README.txt
4.0K	./Built.bat
8.0K	./Contra_Main.asm
180K	.
```

Observe que o total não reflete mais o tamanho dos arquivos excluídos.

- `du -S` ou `--separate-dirs`: espaço que os arquivos no diretório atual ocupam, **excluindo** os subdiretórios

sem `-S`
```
$ du -h
4.8M	./Temp
6.0M	.
```

com `-S`
```
$ du -Sh
4.8M	./Temp
1.3M	.
```

Se quiser manter essa distinção entre o espaço usado pelos arquivos no diretório atual e o espaço usado pelos subdiretórios, mas também quiser um total geral no final, você pode adicionar o parâmetro `-c` ou `--total`:
```
$ du -Shc
4.8M	./Temp
1.3M	.
6.0M	total
```

---

#### complemento sobre inodes

Nos filesystem mais "tradicionais", como os `ext2`/`ext3`/`ext4` por exemplo, a alocação de espaço para os inodes é fixa e determinada no momento da criação da partição.

No entanto, alguns filesystem possuem um recurso chamado "Alocação Dinâmica de Inodes", em que o problema de falta de espaço disponível para os inodes não deve acontecer pois o filesystem se encarregará de criar dinamicamente mais espaço se necessário, entre eles temos o `ReiserFS` (em desuso), `XFS`, `JFS`, `ZFS` e `BTRFS`.

Lembrar que um inode (`index node`) é uma estrutura de dados usada por filesystem como `ext4`, `XFS`, entre outros, para armazenar informações sobre um arquiivo ou diretório, exceto o nome e os dados do arquivo. O nome do arquivo é armazenado separadamente na entrada do diretório, que aponta para o ` correspondente.

Cada arquivo ou diretório em um filesystem Linux é associado a um inode único (dentro de um filesystem específico). Quando você acessa um arquivo, o filesystem primeiro localiza o inode associado ao nome do arquivo e, em seguida, usa as informações armazenadas no inode para acessar os dados do arquivo.

---

#### fsck

- `fsck`: *filesystem check*: usado para analisar uma partição e realizar correção (erros como inconsistências, blocos corrompidos, após uma queda de energia, etc )

>[!NOTE]
>
>Apenas vai funcionar se a partição **NÃO ESTIVER MONTADA** ou em **somente em leitura**!

Assim como o `mkfs` tem variações, o `fsck` também possui. O `fsck.ext2`, `fsck.ext3`, `fsck.ext4`, vão chamar o `e2fsck` (comprove com `ls -l /sbin/fsck*`)
```
$ ls -l /sbin/fsck*
-rwxr-xr-x 1 root root  43440 Dec  4 23:26 /sbin/fsck
-rwxr-xr-x 1 root root   1185 Mar 31  2024 /sbin/fsck.btrfs
-rwxr-xr-x 1 root root  31168 Dec  4 23:26 /sbin/fsck.cramfs
-rwxr-xr-x 1 root root  56528 Apr 18  2024 /sbin/fsck.exfat
lrwxrwxrwx 1 root root      6 Apr 28  2024 /sbin/fsck.ext2 -> e2fsck
lrwxrwxrwx 1 root root      6 Apr 28  2024 /sbin/fsck.ext3 -> e2fsck
lrwxrwxrwx 1 root root      6 Apr 28  2024 /sbin/fsck.ext4 -> e2fsck
-rwxr-xr-x 1 root root  80264 Mar 31  2024 /sbin/fsck.fat
lrwxrwxrwx 1 root root     12 Nov  8 16:18 /sbin/fsck.hfs -> fsck.hfsplus
-rwxr-xr-x 1 root root 287696 Apr  1  2024 /sbin/fsck.hfsplus
-rwxr-xr-x 1 root root 386448 Apr  8  2024 /sbin/fsck.jfs
-rwxr-xr-x 1 root root  55712 Dec  4 23:26 /sbin/fsck.minix
lrwxrwxrwx 1 root root      8 Nov  8 16:18 /sbin/fsck.msdos -> fsck.fat
lrwxrwxrwx 1 root root     10 Nov  8 16:18 /sbin/fsck.reiserfs -> reiserfsck
lrwxrwxrwx 1 root root      8 Nov  8 16:18 /sbin/fsck.vfat -> fsck.fat
-rwxr-xr-x 1 root root   2566 Oct 17 04:36 /sbin/fsck.xfs
-rwxr-xr-x 1 root root    752 Sep  5 16:38 /sbin/fsck.zfs
```

Portanto podemos usar `fsck -t fat` para checar uma partição `FAT` ou usar `fsck.fat`

Em teoria, se executarmos só `fsck`, é para ele detectar a partição, de acordo com o sistema de arquivos (filesystem)

Ex. `fsck /dev/sda2` ou `fsck.ext4 /dev/sda2`, etc

>[!WARNING]
>
>**NUNCA** execute `fsck` (ou utilitários relacionados) em um sistema de arquivos montado. Se isso for feito, pode haver perda de dados
```
# mount /dev/sdb1 /media/
[root@localhost ~]# fsck /dev/sdb1 
fsck from util-linux 2.37.4
e2fsck 1.46.5 (30-Dec-2021)
/dev/sdb1 is mounted.
e2fsck: Cannot continue, aborting.
```

Depois de desmontar a partição desejada, execute (nesse caso é uma partição `ext4`, no entanto o `fsck` detecta e faz a verificação):
```
# umount /media 
[root@localhost ~]# fsck /dev/sdb1 
fsck from util-linux 2.37.4
e2fsck 1.46.5 (30-Dec-2021)
/dev/sdb1: clean, 11/65536 files, 12955/262144 blocks
```

O `fsck` aceita alguns argumentos de linha de comando. Estes são alguns dos mais comuns:
- `-A`: Verifica todos os sistemas de arquivos listados em `/etc/fstab`.
- `-C`: Exibe uma barra de progresso ao verificar um sistema de arquivos. Atualmente funciona apenas em sistemas de arquivos `ext2`/`3`/`4`.
- `-N`: Imprime na tela o que seria feito e sai, sem de fato verificar o sistema de arquivos.
- `-R`: Quando usado em conjunto com `-A`, ele pula a verificação do sistema de arquivos raiz.
- `-V`: Modo detalhado, imprime mais informações do que o normal durante a operação. Útil para depuração.

O utilitário específico para sistemas de arquivos `ext2`, `ext3` e `ext4` é o `e2fsck`, também chamado `fsck.ext2`, `fsck.ext3` e `fsck.ext4` (esses três são apenas links para `e2fsck`). Por padrão, ele é executado no modo interativo: quando um erro é encontrado no sistema de arquivos, ele para e pergunta ao usuário o que fazer. O usuário deve digitar `y` para corrigir o problema, `n` para deixá-lo sem solução ou `a` para corrigir o problema atual e todos os subsequentes.

É claro que sentar em frente a um terminal esperando o `e2fsck` perguntar o que fazer não é um uso produtivo do seu tempo, especialmente se você estiver lidando com um grande sistema de arquivos. Dessa forma, existem opções que fazem com que o `e2fsck` seja executado em modo não interativo:
- `-p`: Essa opção tenta corrigir automaticamente quaisquer erros encontrados. Se for encontrado um erro que requeira intervenção do administrador do sistema, o `e2fsck` fornecerá uma descrição do problema e sairá.
- `-y`: Responde `y` (sim) a todas as questões.
- `-n`: O oposto de `-y`. Além de responder `n` (não) a todas as questões, faz com que o sistema de arquivos seja montado somente para leitura e, portanto, não possa ser modificado.
- `-f`: Força o `e2fsck` a verificar um sistema de arquivos mesmo se ele estiver marcado como “limpo”, ou seja, que foi corretamente desmontado.

---

#### tune2fs

O `tune2fs` faz ajustes e configurações nas partições (adjust tunable file system parameters on `ext2`/`ext3`/`ext4` file systems)

Para ver os parâmetros atuais de qualquer sistema de arquivos, use o parâmetro `-l` seguido pelo dispositivo que representa a partição. O exemplo abaixo mostra a saída desse comando na primeira partição do primeiro disco (`/dev/sda1`) de uma máquina:
```
# tune2fs -l /dev/sda1
tune2fs 1.44.6 (5-Mar-2019)
Filesystem volume name:   <none>
Last mounted on:          /
Filesystem UUID:          6e2c12e3-472d-4bac-a257-c49ac07f3761
Filesystem magic number:  0xEF53
Filesystem revision #:    1 (dynamic)
Filesystem features:      has_journal ext_attr resize_inode dir_index filetype needs_recovery extent 64bit flex_bg sparse_super large_file huge_file dir_nlink extra_isize metadata_csum
Filesystem flags:         signed_directory_hash
Default mount options:    user_xattr acl
Filesystem state:         clean
Errors behavior:          Continue
Filesystem OS type:       Linux
Inode count:              7069696
Block count:              28255605
Reserved block count:     1412780
Free blocks:              23007462
Free inodes:              6801648
First block:              0
Block size:               4096
Fragment size:            4096
Group descriptor size:    64
Reserved GDT blocks:      1024
Blocks per group:         32768
Fragments per group:      32768
Inodes per group:         8192
Inode blocks per group:   512
Flex block group size:    16
Filesystem created:       Mon Jun 17 13:49:59 2019
Last mount time:          Fri Jun 28 21:14:38 2019
Last write time:          Mon Jun 17 13:53:39 2019
Mount count:              8
Maximum mount count:      -1
Last checked:             Mon Jun 17 13:49:59 2019
Check interval:           0 (<none>)
Lifetime writes:          20 GB
Reserved blocks uid:      0 (user root)
Reserved blocks gid:      0 (group root)
First inode:              11
Inode size:	          256
Required extra isize:     32
Desired extra isize:      32
Journal inode:            8
First orphan inode:       5117383
Default directory hash:   half_md4
Directory Hash Seed:      fa95a22a-a119-4667-a73e-78f77af6172f
Journal backup:           inode blocks
Checksum type:            crc32c
Checksum:                 0xe084fe23
```

- `tune2fs -m1 /dev/sda1`: deixa `1%` de blocos reservados (padrão é `5%`). Dependendo do tamanho da partição, `5%` é um valor bem alto, que acaba perdendo espaço.
```
# tune2fs -m1 /dev/sdb1 
tune2fs 1.46.5 (30-Dec-2021)
Setting reserved blocks percentage to 1% (2621 blocks)
```

- `tune2fs -j /dev/sda1`: supondo que `/dev/sda1` é uma partição `ext2`, que não tem `journal`, o `-j` transforma em uma `ext3` e adiciona o `journal`.

Posteriormente, ao montar o sistema de arquivos convertido, não se esqueça de definir o tipo para `ext3` para que o journal possa ser usado.

Ao lidar com sistemas de arquivos com journaling, o parâmetro `-J` permite usar parâmetros extras para definir algumas opções de diário, como:
- `-J size=`: para definir o tamanho do diário (em megabytes)
- `-J location=`: para especificar onde o diário deve ser armazenado (seja um bloco específico ou uma posição específica no disco com sufixos como `M` ou `G`) e até mesmo colocar o diário em um dispositivo externo com `-J device=`.

Para especificar diversos parâmetros ao mesmo tempo, eles devem ser separados por vírgula. Por exemplo: `-J size=10,location=100M,device=/dev/sdb1` criam um diário (Journal) de `10 MB` na posição `100 MB` do dispositivo `/dev/sdb1`.

>[!WARNING]
>
>O `tune2fs` tem uma opção de “força bruta”, `-f`, que o força a completar uma operação mesmo que sejam encontrados erros. Nem é preciso dizer que esse recurso deve ser usado com extrema cautela.

- `tune2fs -L "Teste Particao" /dev/sdb1`: altera o label da partição (até 16 caracteres)
```
# tune2fs -L "Particao Teste" /dev/sdb1
tune2fs 1.46.5 (30-Dec-2021)
```

Depois rode `dumpe2fs -h /dev/sdb1` para ver a mudança
```
dumpe2fs -h /dev/sdb1
dumpe2fs 1.46.5 (30-Dec-2021)
Filesystem volume name:   Particao Teste
Last mounted on:          <not available>
Filesystem UUID:          9c76954f-572c-4f5f-ae10-a5f94b91f51b
Filesystem magic number:  0xEF53
Filesystem revision #:    1 (dynamic)
```

O `dumpe2fs` faz um "dumpping" das informações da partição (dump `ext2`/`ext3`/`ext4` file system information)

Para mudar o tempo de checagem (*Check interval*, no caso executa `fsck`) de uma partição, usamos `tune2fs -i 1m /dev/sdb1` (`d` para dias, `m` para meses e `y` para anos):

Antes da alteração:
```
# dumpe2fs -h /dev/sdb1 | grep interval
dumpe2fs 1.46.5 (30-Dec-2021)
Check interval:           5184000 (2 months)
```

Depois de executar `tune2fs -i 1m /dev/sdb1`
```
# tune2fs -i 1m /dev/sdb1 
tune2fs 1.46.5 (30-Dec-2021)
Setting interval between checks to 2592000 seconds
```

Verificando a mudança
```
# dumpe2fs -h /dev/sdb1 | grep interval
dumpe2fs 1.46.5 (30-Dec-2021)
Check interval:           2592000 (1 month)
```

Para alterar a contagem de verificação de disco de acordo com o número de montagens da partição (*Maximum mount count*) para `30` montagens, use o comando `tune2fs -c 30 /dev/sdb1` (para redefinir use `-c 0` | se usar `-1` significa que não haverá um limite máximo de montagens)
```
# dumpe2fs -h /dev/sdb1 | grep Maximum
dumpe2fs 1.46.5 (30-Dec-2021)
Maximum mount count:      75

# tune2fs -c 30 /dev/sdb1
tune2fs 1.46.5 (30-Dec-2021)
Setting maximal mount count to 30


# dumpe2fs -h /dev/sdb1 | grep Maximum
dumpe2fs 1.46.5 (30-Dec-2021)
Maximum mount count:      30
```

A opção `-e BEHAVIOUR` define o comportamento do kernel quando um erro é encontrado no sistema de arquivos. Existem três comportamentos possíveis:
- `continue`: Continua a execução normalmente.
- `remount-ro`: Remonta o sistema de arquivos como somente leitura.
- `panic`: Causa um kernel panic.

O comportamento padrão é `continue`. `remount-ro` pode ser útil em aplicativos com dados sensíveis, pois irá interromper imediatamente as gravações no disco, evitando mais erros potenciais.

---

#### xfs_admin

Como o tune2fs está para as partições `ext2`, `ext3` e `ext4`, temos o `xfs_admin` que é equivalemnte para partições `XFS`

>[!NOTE]
>
>`apt install xfs*`: para instalar tudo relacionado ao `XFS`

- `xfs_info /dev/sdb1`: traz informações sobre o filesystem
```
# xfs_info /dev/sdb1
meta-data=/dev/sdb1              isize=512    agcount=4, agsize=65536 blks
         =                       sectsz=512   attr=2, projid32bit=1
         =                       crc=1        finobt=1, sparse=1, rmapbt=0
         =                       reflink=1    bigtime=1 inobtcount=1 nrext64=0
data     =                       bsize=4096   blocks=262144, imaxpct=25
         =                       sunit=0      swidth=0 blks
naming   =version 2              bsize=4096   ascii-ci=0, ftype=1
log      =internal log           bsize=4096   blocks=16384, version=2
         =                       sectsz=512   sunit=0 blks, lazy-count=1
realtime =none                   extsz=4096   blocks=0, rtextents=0
```

- `xfs_admin -L Teste_XFS /dev/sdb1`: altera o label da partição (tem que estar desmontado)
```
# xfs_admin -L Teste_XFS /dev/sdb1
writing all SBs
new label = "Teste_XFS"
```

- `xfs_admin -l /dev/sda1`: mostra o label da partição `XFS`
```
# xfs_admin -l /dev/sdb1
label = "Teste_XFS"
```

---

#### Mantendo integridade do XFS

O `xfs_admin` é similar ao `tune2fs`

- `xfs_repair /dev/sdb1`: (similar ao `fsck`) checa a partição
```
# xfs_repair /dev/sdb1
Phase 1 - find and verify superblock...
Phase 2 - using internal log
        - zero log...
        - scan filesystem freespace and inode maps...
        - found root inode chunk
Phase 3 - for each AG...
        - scan and clear agi unlinked lists...
        - process known inodes and perform inode discovery...
        - agno = 0
        - agno = 1
        - agno = 2
        - agno = 3
        - process newly discovered inodes...
Phase 4 - check for duplicate blocks...
        - setting up duplicate extent list...
        - check for inodes claiming duplicate blocks...
        - agno = 0
        - agno = 1
        - agno = 2
        - agno = 3
Phase 5 - rebuild AG headers and trees...
        - reset superblock...
Phase 6 - check inode connectivity...
        - resetting contents of realtime bitmap and summary inodes
        - traversing filesystem ...
        - traversal finished ...
        - moving disconnected inodes to lost+found ...
Phase 7 - verify and correct link counts...
done
```

- `xfs_repair -n /dev/sdb1`: checa a partição, mas não faz nada (apenas para encontrar o erro e não tratá-lo)

`xfs_repair` aceita uma série de opções de linha de comando. Dentre elas:
- `-l LOGDEV` e `-r RTDEV`: Necessários se o sistema de arquivos tem log externo e seções em tempo real. Neste caso, substitua `LOGDEV` e `RTDEV` pelos dispositivos correspondentes.
- `-m N`: Usado para limitar o uso de memória de `xfs_repair` para `N` megabytes, algo que pode ser útil nas configurações do servidor. De acordo com a página do manual, por padrão `xfs_repair` adapta seu uso de memória conforme necessário, até 75% da RAM física do sistema.
- `-d`: O modo “dangerous” (perigoso) permite reparar sistemas de arquivos montados como apenas leitura,
- `-v`: Você deve ter adivinhado: modo verboso. Cada vez que este parâmetro é usado, a “verbosidade” é aumentada (por exemplo,`-v -v` imprime mais informações do que apenas `-v`).

>[!NOTE]
>
>Observe que `xfs_repair` não é capaz de reparar sistemas de arquivos com um log “sujo”. É possível “zerar” um log corrompido com o parâmetro `-L`, mas tenha em mente que este é um último recurso, pois pode resultar em corrupção do sistema de arquivos e perda de dados.

- `xfs_db /dev/sdb1`: (modo `debug`, é um utilitário parecido com o `parted`) entra em uma linha de comando (`help` para opções). Faz o reparo e debug diretamente no filesystem. Um exemplo é o `frag`, que mostra a fragmentação do filesystem. No `xfs` acontece fragmentação.
```
# xfs_db /dev/sdb1
xfs_db> frag
actual 0, ideal 0, fragmentation factor 0.00%
Note, this number is largely meaningless.
Files on this filesystem average -nan extents per file
xfs_db> quit
```

- `xfs_fsr /dev/sdb1`: é um desfragmentador (filesystem organizer for XFS - filesystem precisa estar montado - reorganiza o filesystem). Rodar só `xfs_fsr` ele irá olhar no `fstab` qual partição é `XFS`.
```
# xfs_fsr /dev/sdb1
/mnt/xfs start inode=0
```

#### adicional

- `blkid /dev/sdb5`: mostra o UUID da partição `/dev/sdb5`

---

### 104.3 Controle da montagem e desmontagem dos sistemas de arquivos

A partição só passa a ser **útil** no momento que ela é montada (**Montar** significa **anexar** o sistema de arquivos em um ponto específico da árvore de diretórios do sistema). Os sistemas de arquivos podem ser montados manual ou automaticamente e há muitas maneiras de fazê-lo.

Exemplo:` /dev/sda1` é a partição e `/media/diretorio` é o ponto de montagem da partição (`df -h` mostra as partições montadas)

Por exemplo:
```
/dev/sdb1            960M   39M  922M   5% /tmp
```

No exemplo acima, temos que `/tmp` está associada à partição `/dev/sdb1` (que no caso é o segundo disco do computador)

#### Outro exemplo (retirado da lpi.org)

para montar uma unidade flash USB contendo um sistema de arquivos `exFAT` localizado em `/dev/sdb1` em um diretório chamado `flash` em seu diretório inicial, você usaria:
```
# mount -t exfat /dev/sdb1 ~/flash/
```

>[!NOTE]
>
>Muitos sistemas Linux usam o shell Bash, e nesse caso o til `~` no caminho para o ponto de montagem é uma abreviação para o diretório inicial do usuário atual. Se o nome do usuário atual for `john`, por exemplo, ele será substituído por `/home/john`.

Após a montagem, o conteúdo do sistema de arquivos estará acessível no diretório `~/flash`:
```
$  ls -lh ~/flash/
total 469M
-rwxrwxrwx 1 root root 454M jul 19 09:49 lineage-16.0-20190711-MOD-quark.zip
-rwxrwxrwx 1 root root  16M jul 19 09:44 twrp-3.2.3-mod_4-quark.img
```

`mount` é usado para montagem e `umount` para desmontagem (são temporários, ao reiniciar é perdido). Para tornar permanente precisamos alterar o arquivo `/etc/fstab` (por isso `/etc` tem que ficar junto do `/` - visto no item [102.1](#102.1), mais precisamente [aqui](#dir-nao-podem-ficar-fora-de-barra) )

Se rodar apenas `mount` mostra todas as partições montadas no sistema, inclusive as automáticas e dinâmicas:
```
# mount
proc on /proc type proc (rw,nosuid,nodev,noexec,relatime)
sysfs on /sys type sysfs (rw,nosuid,nodev,noexec,relatime,seclabel)
devtmpfs on /dev type devtmpfs (rw,nosuid,seclabel,size=4096k,nr_inodes=154289,mode=755,inode64)
securityfs on /sys/kernel/security type securityfs (rw,nosuid,nodev,noexec,relatime)
tmpfs on /dev/shm type tmpfs (rw,nosuid,nodev,seclabel,inode64)
devpts on /dev/pts type devpts (rw,nosuid,noexec,relatime,seclabel,gid=5,mode=620,ptmxmode=000)
tmpfs on /run type tmpfs (rw,nosuid,nodev,seclabel,size=259580k,nr_inodes=819200,mode=755,inode64)
cgroup2 on /sys/fs/cgroup type cgroup2 (rw,nosuid,nodev,noexec,relatime,seclabel,nsdelegate,memory_recursiveprot)
pstore on /sys/fs/pstore type pstore (rw,nosuid,nodev,noexec,relatime,seclabel)
none on /run/credentials/systemd-tmpfiles-setup-dev.service type ramfs (ro,nosuid,nodev,noexec,relatime,seclabel,mode=700)
configfs on /sys/kernel/config type configfs (rw,nosuid,nodev,noexec,relatime)
/dev/sda1 on /boot type xfs (rw,relatime,seclabel,attr2,inode64,logbufs=8,logbsize=32k,noquota)
none on /run/credentials/systemd-tmpfiles-setup.service type ramfs (ro,nosuid,nodev,noexec,relatime,seclabel,mode=700)/dev/sdb1 on /mnt/xfs type xfs (rw,relatime,seclabel,attr2,inode64,logbufs=8,logbsize=32k,noquota)
```

Entre a enorme saída podemos notar que há um saída `/dev/sda1` e `/dev/sdb1` indicando o primeiro disco e o segundo disco.

Caso queira listar por tipo de partição: `mount -t ext4`
```
/dev/sda1 on / type ext4 (rw,noatime,errors=remount-ro)
```

pode especificar vários sistemas de arquivos de uma vez, separando-os com uma vírgula:
```
# mount -t ext4,fuseblk
/dev/sda1 on / type ext4 (rw,noatime,errors=remount-ro)
/dev/sdb1 on /home/carol/flash type fuseblk (rw,nosuid,nodev,relatime,user_id=0,group_id=0,default_permissions,allow_other,blksize=4096) [DT_8GB]
```

- `umount -f`: força a desmontagem de um sistema de arquivos
- `umount -r`: se o sistema de arquivos não puder ser desmontado, esse comando tenta torná-lo somente leitura 
- `mount -a`: **monta tudo** que estiver em `/etc/fstab` (ideal para quando adicionar novas linhas nele e não precisar reiniciar o sistema para montar as partições)
- `umount -a`: **desmonta tudo** que estiver em `/etc/fstab` (desde que a partição não esteja em uso)
- `mount -t` ou `--types`: especifica o filesystem (Exemplo: `mount -t exfat /dev/sdb1 ~/flash/`)

Só `mount -t ext4`: mostra apenas as partições `ext4` montadas. (pode vários também, como em `mount -t ext4,btrfs`)

- `mount /dev/sdb2 /tmp/teste_mount`: monta a partição `sdb2` no diretório `/tmp/teste_mount`

Se der um `ls /tmp/teste_mount`, podemos ver que foi montado, e que há o diretório `lost+found`, que é para recuperar arquivos perdidos

Para desmontar: `umount /dev/sdb2` ou `umount /tmp/teste_mount` (informa ou a **partição** ou o **ponto de montagem**)

- `mount -r`: monta a partição em **read only**

Se em `/etc/fstab` tivermos:
```
/dev/sr0          /media/cdrom        auto       noauto,users    0    0
```

Podemos apenas executar `mount /dev/sr0`, o ponto de montagem (`/media/cdrom`) já vai ser usado, uma vez que está inserido dentro do `fstab` (já de conhecimento do `fstab` o restante)

Podemos confirmar com `df- h` (comando que mostra as partições montadas)

>[!NOTE]
>
>Normalmente o Linux identifica o CDROM como `/dev/sr0`

>[!NOTE]
>
>Lembrando que Linux com interface gráfica normalmente irá montar sozinho (diferentemente de linha de comando, sempre teremos que montar manualmente)

>[!NOTE]
>
>Ao reiniciar, perdemos o que foi montado manualmente. Precisa constar no `/etc/fstab` para ficar permanente

---

#### lidando com arquivos abertos

Ao desmontar um sistema de arquivos, pode aparecer a mensagem de erro `target is busy`. Isso acontece quando algum arquivo do sistema de arquivos está aberto. No entanto, nem sempre a localização de um arquivo aberto é óbvia, nem o que está acessando o sistema de arquivos.

Nesses casos, podemos usar o comando `lsof` seguido do nome do dispositivo que contém o sistema de arquivos para ver uma lista de processos que o acessam e quais arquivos estão abertos. Por exemplo:
```
# umount /dev/sdb1
umount: /media/carol/External_Drive: target is busy.
```

```
# lsof /dev/sdb1
COMMAND  PID   USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
evince  3135 carol   16r   REG   8,17 21881768 5195 /media/carol/External_Drive/Documents/E-Books/MagPi40.pdf
```

- `COMMAND` é o nome do executável que abriu o arquivo - `PID` é o número do processo
- `NAME` é o nome do arquivo que está aberto. No exemplo acima, o arquivo `MagPi40.pdf` foi aberto pelo programa `evince` (um visualizador de PDF). Se fecharmos o programa, poderemos desmontar o sistema de arquivos.

>[!NOTE]
>
>Antes que a saída de `lsof` apareça, os usuários de GNOME poderão ver uma mensagem de aviso na janela do terminal.
```
lsof: WARNING: can't stat() fuse.gvfsd-fuse file system /run/user/1000/gvfs
Output information may be incomplete.
```
O `lsof` tenta processar todos os sistemas de arquivos montados. Essa mensagem de aviso surge porque o `lsof` encontrou um sistema de arquivos virtual `GNOME` (GVFS). Esse é um caso especial de sistema de arquivos no espaço de usuário (`FUSE`). Ele age como uma ponte entre `GNOME`, suas APIs e o kernel. Ninguém — nem mesmo o `root — pode` acessar um desses sistemas de arquivo, exceto pelo proprietário que o montou (neste caso, `GNOME`). Você pode ignorar esse aviso.

---

#### Onde montar?

Você pode montar um sistema de arquivos em qualquer lugar que desejar. No entanto, existem algumas práticas recomendadas para facilitar a administração do sistema.

Tradicionalmente, `/mnt` era o diretório sob o qual todos os dispositivos externos eram montados e, dentro dele, existia uma série de “pontos de ancoragem” pré-configurados para dispositivos comuns, como drives de CD-ROM (`/mnt/cdrom`) e disquetes (`/mnt/floppy`).

Ele foi substituído por `/media`, que agora é o ponto de montagem padrão para qualquer mídia removível pelo usuário (por exemplo, discos externos, pendrives, leitores de cartão de memória, etc.) conectada ao sistema.

Na maioria das distribuições Linux e ambientes de desktop modernos, os dispositivos removíveis são montados automaticamente em `/media/USER/LABEL` quando conectados ao sistema, sendo `USER` o nome de usuário e `LABEL` o nome do dispositivo. Por exemplo, um drive flash USB com o nome FlashDrive conectado pelo usuário john seria montado em `/media/john/FlashDrive/`. A maneira como isso é feito varia de acordo com o ambiente de desktop. Dito isto, sempre que você precisar montar manualmente um sistema de arquivos, é melhor fazer isso em `/mnt`.

---

#### Parâmetros do /etc/fstab

No próprio arquivo é disponibilizado um esquema do que deve ser seguido como inserir uma nova configuração:
```
<file system> <mount point>   <type>  <options>       <dump>  <pass>
```

O `<file system>` pode usar a partição desejada (como `/dev/sdb1`) ou o **UUID** da partição (pode ser obtido com `blkid /dev/sdb1` ou `dumpe2fs -h /dev/sdb1`, esse último para partições `ext2`,`3` e `4`)


>[!NOTE]
>
>**UUID**: identificação única para determinado dispositivo. Cada filesystem tem o seu **UUID**

Antes de formatar a partição, temos apenas o **PARTUUID**:
```
# blkid /dev/sda2 
/dev/sda2: PARTUUID="18178e8f-49a1-4345-b791-a0cfd0e6f202"
```

Após formatar `/dev/sda2`, do exemplo anterior:
```
# mkfs.ext3 /dev/sda2
mke2fs 1.46.5 (30-Dec-2021)
Discarding device blocks: done                            
Creating filesystem with 512000 1k blocks and 128016 inodes
Filesystem UUID: 29343bfe-107d-4db8-9333-5a3adb637c4b
Superblock backups stored on blocks: 
	8193, 24577, 40961, 57345, 73729, 204801, 221185, 401409

Allocating group tables: done                            
Writing inode tables: done                            
Creating journal (8192 blocks): done
Writing superblocks and filesystem accounting information: done 

# blkid /dev/sda2 
/dev/sda2: UUID="29343bfe-107d-4db8-9333-5a3adb637c4b" SEC_TYPE="ext2" TYPE="ext3" PARTUUID="18178e8f-49a1-4345-b791-a0cfd0e6f202"
```

>[!NOTE]
>
>Podemos também usar o **Filesystem volume name** para identificar uma partição

- `<mount point>`: diretório onde quer montar a partição definida em `<file system>`
- `<type>`: tipo de filesystem que será usado (`auto`: identifica automaticamente, poderia ser `ext4`, `swap`, etc)

>[!NOTE]
>
>Se usar o tipo `swap`, o ponto de montagem (`<mount point>`) deve ser definido como `none`, pois internamente já será feito um `swapon` quando o computador for ligado, colocando em `swap` no sistema.
```
<file system>   <mount point>   <type>  <options>       <dump>  <pass>
/dev/sdb5       none            swap    defaults            0    0
```

>[!NOTE]
>
>**swap** não precisa de ponto de montagem, por isso se usa `none`

- `<options>`: quem será o dono da partição, se permite escrita ou só leitura, permitir que só quem montou possa desmontar, etc (comum usar `defaults`)
    - podemos usarmos:
    - `noauto`: quando o computador realizar o boot, esse ponto de montagem **NÃO** irá montar sozinho (apesar de estar mapeado no `fstab`, **não** será montado sozinho) **NÃO** monta com `mount`/`umount -a`
    - `users`: permite que qualquer usuário monte e desmonte a partição/FS (user1 pode montar e user2 pode desmontar)
    - `user`: permite qualquer usuário montar, mas só quem montou que pode desmontar
- `<dump>`: usado para *backup*, usualmente quando inicia o computador (`0`=desligado). É pouco usado atualmente.
- `<pass>`: checagem do filesystem (`fsck`) no momento do boot do computador. (`0`=desligado), se usar `1`, faz `fsck` na primeira partição listada

>[!NOTE]
>
>Lembrando que após realizar as mudanças em `/etc/fstab`, use `mount -a` para efetivar as mudanças.

E montagens utilizando o **Label**, usamos no `fstab`:
```
LABEL=NOME_LABEL    /ponto_montagem    type    options    0    0
```

>[!NOTE]
>
>Sempre é recomendado usar **UUID**, pois não muda (é fixo). Já **Label** ou identificação de partição pode ser alterado. Nas partições se houver **label**, retorna também.

---

#### resumo das propriedades do /etc/fstab (via lpi.org)

O arquivo `/etc/fstab` contém descrições sobre os sistemas de arquivos que podem ser montados. Trata-se de um arquivo de texto em que cada linha descreve um sistema de arquivos a ser montado, com seis campos por linha, na seguinte ordem:
```
FILESYSTEM MOUNTPOINT TYPE OPTIONS DUMP PASS
```

Onde:

- `FILESYSTEM`: O dispositivo que contém o sistema de arquivos a ser montado. Em vez do dispositivo, você pode especificar o **UUID** ou rótulo da partição, algo que discutiremos mais tarde.
- `MOUNTPOINT`: Onde o sistema de arquivos será montado.
- `TYPE`: O tipo de sistema de arquivos.
- `OPTIONS`: Opções de montagem que serão passadas para `mount`. São uma lista de parâmetros separados por vírgulas, que podem ser genéricos ou específicos ao sistema de arquivos. Entre os genéricos temos:
    - `atime` e `noatime`: Por padrão, cada vez que um arquivo é lido, a informação de data e hora de acesso é atualizada. Se essa opção for desativada (com `noatime`), a E/S do disco fica mais veloz. Não confundir com a hora de modificação, que é atualizada sempre que um arquivo é gravado.
    - `auto` e `noauto`: Se o sistema de arquivos pode (ou não) ser montado automaticamente com `mount -a`.
    - `defaults`: Passa as opções `rw`, `suid`, `dev`, `exec`, `auto`, `nouser` e `async` para `mount`.
    - `dev` e `nodev`: Indica se os dispositivos de caractere ou de bloco no sistema de arquivos montado devem ser interpretados.
    - `exec` e `noexec`: Permite ou nega a permissão para executar binários no sistema de arquivos.
    - `user` e `nouser`: Permite (ou não) a um usuário comum montar o sistema de arquivos.
    - `group`: Permite a um usuário montar o sistema de arquivos se o usuário pertencer ao mesmo grupo que possui o dispositivo que o contém.
    - `owner`: Permite a um usuário montar um sistema de arquivos se ele for proprietário do dispositivo que o contém.
    - `suid` e `nosuid`: Permite ou não que os bits `SETUID` e `SETGID` tenham efeito.
    - `ro` e `rw`: Montam um sistema de arquivos como somente leitura ou gravável.
    - `remount`: Tenta remontar um sistema de arquivos já montado. Não é usado em `/etc/fstab`, mas como um parâmetro para `mount -o`. Por exemplo, para remontar a partição já montada `/dev/sdb1` como somente leitura, você pode usar o comando `mount -o remount,ro /dev/sdb1`. Ao remontar, não é necessário especificar o tipo de sistema de arquivos, apenas o nome do dispositivo ou o ponto de montagem.
    - `sync` e `async`: Definem se todas as operações de E/S devem ser realizadas no sistema de arquivos de forma síncrona ou assíncrona. `async` geralmente é o padrão. A página de manual de `mount` avisa que usar `sync` em mídias com um número limitado de ciclos de gravação (como drives flash ou cartões de memória) pode encurtar a vida útil do dispositivo.
- `DUMP`: Indica se qualquer sistema de arquivos `ext2`, `ext3` ou `ext4` deve ser considerado para backup pelo comando `dump`. Normalmente o valor é `zero`, o que significa que devem ser ignorados.
- `PASS`: Quando diferente de `zero`, define a ordem na qual os sistemas de arquivos serão checados na inicialização. Normalmente é `zero`.

---

#### Diferença entre /etc/mtab e /etc/fstab

Ambos são arquivos relacionados ao sistema de arquivos no Linux, mas possuem propósitos diferentes:

| Arquivo        | Propósito |
|---------------|-----------|
| `/etc/fstab`  | Define quais sistemas de arquivos devem ser montados automaticamente na inicialização. |
| `/etc/mtab`   | Lista os sistemas de arquivos que estão **atualmente montados** no sistema. |

---

#### **1. `/etc/fstab` – Configuração de Montagem Permanente**
- Esse arquivo contém uma **lista de sistemas de arquivos** que devem ser montados automaticamente na inicialização.
- Ele especifica o dispositivo, ponto de montagem, sistema de arquivos, opções de montagem, e outras configurações.

#### **Exemplo de `/etc/fstab`**
```plaintext
/dev/sda1  /       ext4   defaults  0  1
/dev/sdb1  /mnt/dados  xfs    defaults  0  2
UUID=1234-5678  /mnt/backup  ext4  noatime,nodiratime  0  2
```
- Define onde e como os discos serão montados automaticamente.
- O UUID pode ser usado no lugar do nome do dispositivo (`/dev/sdX`).

---

#### **2. `/etc/mtab` – Sistemas de Arquivos Montados no Momento**
- Esse arquivo **reflete o estado atual** do sistema de arquivos.
- Ele é atualizado dinamicamente quando um sistema de arquivos é montado ou desmontado.

#### **Exemplo de `/etc/mtab`**
```plaintext
/dev/sda1 / ext4 rw,relatime 0 0
tmpfs /run tmpfs rw,nosuid,nodev,noexec,relatime,size=102400k 0 0
/dev/sdb1 /mnt/dados xfs rw,relatime 0 0
```
- Aqui vemos que `/dev/sdb1` está montado em `/mnt/dados` com sistema de arquivos `xfs`.
- O `rw` indica que o sistema está montado como leitura e escrita.

---

#### **Principais Diferenças**

| Característica | `/etc/fstab` | `/etc/mtab` |
|---------------|-------------|-------------|
| Propósito | Configuração fixa dos sistemas de arquivos | Lista os sistemas atualmente montados |
| Atualização | Definido pelo usuário/administrador | Atualizado dinamicamente pelo sistema |
| Persistência | Permanente (usado na inicialização) | Temporário (atualizado em tempo real) |
| Edição manual | Sim | Não recomendado (pode causar inconsistências) |

---

#### **Como Verificar os Sistemas Montados**
Além do `/etc/mtab`, você pode usar:
```bash
mount
```
ou
```bash
findmnt
```
Esses comandos fornecem informações semelhantes ao `/etc/mtab`.

---

#### **Conclusão**
- **Se quiser definir montagens permanentes**, edite `/etc/fstab`.
- **Se quiser ver o que está montado agora**, consulte `/etc/mtab` ou use `mount`.

>[!WARNING]
>
>O `/etc/mtab` é um arquivo de controle em que o sistema mantém todos as montagens atuais. Ele não deve ser editado pelo administrador.

---

#### blkid

`blkid` é um comando usado para ajudar a identificar partições. Se usado no disco (exemplo `/dev/sdb`), retorna támbem o tipo (exemplo `gpt`). O **UUID** sempre vai aparecer, assim como o **TYPE** da partição.
```
# blkid /dev/sdb 
/dev/sdb: PTUUID="aa223223-d885-f443-887e-9b63eda08354" PTTYPE="gpt"

# blkid /dev/sdb1 
/dev/sdb1: LABEL="Teste_XFS" UUID="c98c49d2-7ba7-4cb6-a26c-1dde0582c70f" TYPE="xfs" PARTUUID="bf0de504-1cf8-1b47-b89b-789e4a7f2c1e"

# blkid /dev/sdb2
/dev/sdb2: UUID="c3ddaf9c-7c99-464c-95e0-05ece53da144" TYPE="ext4" PARTUUID="2730647a-a98b-ba48-90b2-ad5c7752f917"
```

Se usar só `blkid` retorna todas as partições de todos os discos:
```
# blkid
/dev/mapper/cs-root: UUID="738dd9df-9a21-4e05-b791-4f24b06463f9" TYPE="xfs"
/dev/vda2: UUID="LTx50A-QCNl-KksU-3oBb-q1Sx-pCf7-hZ8l9Z" TYPE="LVM2_member" PARTUUID="6091bf38-02"
/dev/sdb1: LABEL="Teste_XFS" UUID="c98c49d2-7ba7-4cb6-a26c-1dde0582c70f" TYPE="xfs" PARTUUID="bf0de504-1cf8-1b47-b89b-789e4a7f2c1e"
/dev/vda1: UUID="6873c779-e68b-40e6-b1bd-2ed31c4e9789" TYPE="xfs" PARTUUID="6091bf38-01"
/dev/sda1: UUID="42e213f9-41cf-46fe-9855-198664d10e7c" TYPE="ext4" PARTUUID="1794c035-36cb-a54f-b07a-82caf1da8e11"
/dev/sda2: UUID="29343bfe-107d-4db8-9333-5a3adb637c4b" SEC_TYPE="ext2" TYPE="ext3" PARTUUID="18178e8f-49a1-4345-b791-a0cfd0e6f202"
/dev/sdb2: UUID="c3ddaf9c-7c99-464c-95e0-05ece53da144" TYPE="ext4" PARTUUID="2730647a-a98b-ba48-90b2-ad5c7752f917"
/dev/mapper/cs-swap: UUID="05b1b5c7-c88b-4d9c-80bd-c01714735bbd" TYPE="swap"
```

---

#### lsblk

Lista todos os discos e partições em formato de diretório, mostrando diversas informações como tamanho, se é um disco ou partição (`disk` ou `part`)
```
# lsblk
NAME        MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTS
sda           8:0    0   10G  0 disk 
├─sda1        8:1    0    1G  0 part 
└─sda2        8:2    0  500M  0 part 
sdb           8:16   0    8G  0 disk 
├─sdb1        8:17   0    1G  0 part /mnt/xfs
└─sdb2        8:18   0  500M  0 part 
sr0          11:0    1 1024M  0 rom  
vda         252:0    0   20G  0 disk 
├─vda1      252:1    0    1G  0 part /boot
└─vda2      252:2    0   19G  0 part 
  ├─cs-root 253:0    0   17G  0 lvm  /
  └─cs-swap 253:1    0    2G  0 lvm  [SWAP]
```

Para descobrir o UUID usando o lsblk, basta adicionar o parâmetro `-f` ou `--fs`.
```
# lsblk -f
NAME        FSTYPE      FSVER    LABEL     UUID                                   FSAVAIL FSUSE% MOUNTPOINTS
sda                                                                                              
├─sda1      ext4        1.0                42e213f9-41cf-46fe-9855-198664d10e7c                  
└─sda2      ext3        1.0                29343bfe-107d-4db8-9333-5a3adb637c4b                  
sdb                                                                                              
├─sdb1      xfs                  Teste_XFS c98c49d2-7ba7-4cb6-a26c-1dde0582c70f      921M     4% /mnt/xfs
└─sdb2      ext4        1.0                c3ddaf9c-7c99-464c-95e0-05ece53da144                  
sr0                                                                                              
vda                                                                                              
├─vda1      xfs                            6873c779-e68b-40e6-b1bd-2ed31c4e9789    502.6M    48% /boot
└─vda2      LVM2_member LVM2 001           LTx50A-QCNl-KksU-3oBb-q1Sx-pCf7-hZ8l9Z                
  ├─cs-root xfs                            738dd9df-9a21-4e05-b791-4f24b06463f9     11.2G    34% /
  └─cs-swap swap        1                  05b1b5c7-c88b-4d9c-80bd-c01714735bbd                  [SWAP]
```

Sendo cada coluna com os seguintes valores:
- `NAME`: Nome do dispositivo que contém o sistema de arquivos.
- `FSTYPE`: Tipo de sistema de arquivos.
- `LABEL`: Rótulo do sistema de arquivos.
- `UUID`: Identificador Universal Único (**UUID**) atribuído ao sistema de arquivos.
- `FSAVAIL`: Espaço disponível no sistema de arquivos.
- `FSUSE%`: Porcentagem de uso do sistema de arquivos.
- `MOUNTPOINT`: Onde o sistema de arquivos é montado.

Em `/etc/fstab`, um dispositivo pode ser especificado por seu `UUID` com a opção `UUID=` seguida pelo `UUID`, ou com `LABEL=`, seguida pelo rótulo. Assim, em vez de:
```
/dev/sda1  /  ext4  noatime,errors
```

Usaríamos:
```
UUID=6e2c12e3-472d-4bac-a257-c49ac07f3761  /  ext4  noatime,errors
```

Ou, se tivermos um disco rotulado como `homedisk`:
```
LABEL=homedisk  /home ext4  defaults
```

A mesma sintaxe pode ser usada com o comando `mount`. Em vez do nome do dispositivo, passe o `UUID` ou `rótulo`. Por exemplo, para montar um disco NTFS externo com o UUID 56C11DCC5D2E1334 em `/mnt/external`, o comando seria:
```
$ mount -t ntfs UUID=56C11DCC5D2E1334 /mnt/external
```

>[!NOTE]
>
>`blkid` lista o `PARTUUID` e `UUID`, que podem ser usados para montar partições (assim como `LABEL`, mas menos recomendado).

Podem ocorrer problemas ao se especificar o nome do dispositivo que contém o sistema de arquivos a ser montado. Às vezes, o mesmo nome pode ser atribuído a outro dispositivo, dependendo de quando ou onde ele foi conectado ao sistema. Por exemplo, um pendrive em `/dev/sdb1` pode ser atribuído a `/dev/sdc1` se conectado em outra porta ou após outro pendrive.

Uma maneira de evitar isso é especificar o rótulo ou **UUID** (*Universally Unique Identifier*) do volume. Ambos são especificados quando o sistema de arquivos é criado e não serão alterados, a menos que o sistema de arquivos seja destruído ou atribuído manualmente a um novo rótulo ou **UUID**.

Exemplos de como montar usando **UUID**
```
mount UUID="c3ddaf9c-7c99-464c-95e0-05ece53da144" /mnt/ext4
```

Podemos confirmar com o comando `df -T /dev/sdb2`:
```
# df -T /dev/sdb2 
Filesystem     Type 1K-blocks  Used Available Use% Mounted on
/dev/sdb2      ext4    469328    14    439618   1% /mnt/ext4
```

Pode confirmar também com o `lsblk` (vide última linha):
```
# lsblk
NAME        MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTS
sda           8:0    0   10G  0 disk 
├─sda1        8:1    0    1G  0 part 
└─sda2        8:2    0  500M  0 part 
sdb           8:16   0    8G  0 disk 
├─sdb1        8:17   0    1G  0 part /mnt/xfs
└─sdb2        8:18   0  500M  0 part /mnt/ext4
```

---

#### definindo pontos de montagens com o systemd

Além do `fstab`, podemos usar o `systemd` para definir pontos de montagem.

Basicamente criaremos uma `Unit` em `/lib/systemd/system` ou em `/etc/systemd/system` (**LPI** indica que seja em `/etc`, mas em `/lib` funciona também)

Criar um arquivo chamado `mnt-montagem.mount`, com o conteúdo (use a extensão `.mount`):
```
# cat mnt-montagem.mount 
[Unit]
Description="Ponto de Montagem Teste"

[Mount]
What=/dev/sdb2
Where=/mnt/montagem
Type=ext4 #poderia ser auto
Options=defaults

[Install]
WantedBy=multi-user.target
```

Onde as opções são:
- `Description=`: Descrição curta da unidade de montagem, algo como `Mounts the backup disk`.
- `What=`: O que deve ser montado. O volume tem de ser especificado como `/dev/disk/by-uuid/VOL_UUID`, onde `VOL_UUID` é o `UUID` do volume.
- `Where=`: Deve ser o caminho completo para o local em que o volume será montado.
- `Type=`: O tipo de sistema de arquivos.
- `Options=`: Opções de montagem que podem ser desejáveis; são as mesmas usadas com o comando mount ou em `/etc/fstab`.
- `WantedBy=`:  Usado para o gerenciamento de dependências. Neste caso, usaremos `multi-user.target`, que indica que sempre que o sistema inicializar em um ambiente multiusuário (uma inicialização normal) a unidade será montada.

>[!IMPORTANT]
>
>**É muito importante** que o nome do arquivo faça referência ao ponto de montagem desejado. Nesse caso é em `/mnt/montagem`. logo substituir `/` por `-`, no nome do arquivo (ficando `mnt-montagem.mount`). Senão teremos o erro `Where= setting doesn't match unit name. Refusing`.)
```
# systemctl status mnt-montagem.mount
○ mnt-montagem.mount - "Ponto de Montagem Teste"
     Loaded: bad-setting (Reason: Unit mnt-montagem.mount has a bad unit file setting.)
     Active: inactive (dead)
      Where: /mnt/ext4
       What: /dev/sdb2

Feb 16 15:20:42 localhost.localdomain systemd[1]: mnt-montagem.mount: Where= setting doesn't match unit name. Refusing.
Feb 16 15:20:48 localhost.localdomain systemd[1]: mnt-montagem.mount: Where= setting doesn't match unit name. Refusing.
Feb 16 15:20:48 localhost.localdomain systemd[1]: mnt-montagem.mount: Where= setting doesn't match unit name. Refusing.
Feb 16 15:20:48 localhost.localdomain systemd[1]: mnt-montagem.mount: Where= setting doesn't match unit name. Refusing.
Feb 16 15:20:49 localhost.localdomain systemd[1]: mnt-montagem.mount: Where= setting doesn't match unit name. Refusing.
Feb 16 15:20:49 localhost.localdomain systemd[1]: mnt-montagem.mount: Where= setting doesn't match unit name. Refusing.
Feb 16 15:20:49 localhost.localdomain systemd[1]: mnt-montagem.mount: Where= setting doesn't match unit name. Refusing.
Feb 16 15:21:06 localhost.localdomain systemd[1]: mnt-montagem.mount: Where= setting doesn't match unit name. Refusing.
Feb 16 15:34:28 localhost.localdomain systemd[1]: mnt-montagem.mount: Where= setting doesn't match unit name. Refusing.
Feb 16 15:34:49 localhost.localdomain systemd[1]: mnt-montagem.mount: Where= setting doesn't match unit name. Refusing.
```

Acima foi propositalmente colocado o ponto de montagem `/mnt/ext4`, diferindo do nome do arquivo (`mnt-montagem.mount`). Se permanecer `/mnt/ext4`, o arquivo deveria se chamar `mnt-ext4.mount`

Para montar o ponto de montagem criado no exemplo acima, use: `systemctl start mnt-montagem.mount`:

Use `systemct status mnt-montagem.mount` (com `status` é dado mais informações e `enable` carrega durante o boot)
```
# systemctl status mnt-montagem.mount
● mnt-montagem.mount - "Ponto de Montagem Teste"
     Loaded: loaded (/usr/lib/systemd/system/mnt-montagem.mount; disabled; preset: disabled)
     Active: active (mounted) since Thu 2025-02-16 15:39:30 -03; 3s ago
      Until: Thu 2025-02-16 15:39:30 -03; 3s ago
      Where: /mnt/montagem
       What: /dev/sdb2
      Tasks: 0 (limit: 7714)
     Memory: 44.0K
        CPU: 6ms
     CGroup: /system.slice/mnt-montagem.mount

Feb 16 15:39:30 localhost.localdomain systemd[1]: Mounting "Ponto de Montagem Teste"...
Feb 16 15:39:30 localhost.localdomain systemd[1]: Mounted "Ponto de Montagem Teste".
```

>[!NOTE]
>
>Pode acontecer de aparecer a linha:<br> `Process: 5333 ExecMount=/bin/mount /dev/sdb2 /mnt/montagem -t ext4 -o defaults (code=exited, status=0/SUCESS)` dentro da saída de `systemctl status mnt-montagem.mount`, indicando que o `systemd` nos bastidores faz basicamente um `mount`ps

Confirme ainda com `df -T /dev/sdb2` que a partição `/dev/sdb2` foi montada no diretório `/mnt/montagem`:
```
# df -T /dev/sdb2
Filesystem     Type 1K-blocks  Used Available Use% Mounted on
/dev/sdb2      ext4    469328    14    439618   1% /mnt/montagem
```

- `systemctl stop mnt-montagem.mount`: desmonta `/mnt/montagem`
- `systemctl enable mnt-montagem.mount`: faz com que em todo processo de boot do computador, seja montado `/mnt/montagem`
```
# systemctl status mnt-montagem.mount
● mnt-montagem.mount - "Ponto de Montagem Teste"
     Loaded: loaded (/usr/lib/systemd/system/mnt-montagem.mount; disabled; preset: disabled)
     Active: active (mounted) since Thu 2025-02-16 15:46:12 -03; 8min ago
      Until: Thu 2025-02-16 15:46:12 -03; 8min ago
      Where: /mnt/montagem
       What: /dev/sdb2
      Tasks: 0 (limit: 7714)
     Memory: 44.0K
        CPU: 5ms
     CGroup: /system.slice/mnt-montagem.mount

Feb 16 15:46:12 localhost.localdomain systemd[1]: Mounting "Ponto de Montagem Teste"...
Feb 16 15:46:12 localhost.localdomain systemd[1]: Mounted "Ponto de Montagem Teste".


[root@localhost system]# systemctl enable mnt-montagem.mount
Created symlink /etc/systemd/system/multi-user.target.wants/mnt-montagem.mount → /usr/lib/systemd/system/mnt-montagem.mount.


[root@localhost system]# systemctl status mnt-montagem.mount
● mnt-montagem.mount - "Ponto de Montagem Teste"
     Loaded: loaded (/usr/lib/systemd/system/mnt-montagem.mount; enabled; preset: disabled)
     Active: active (mounted) since Thu 2025-02-16 15:46:12 -03; 9min ago
      Until: Thu 2025-02-16 15:46:12 -03; 9min ago
      Where: /mnt/montagem
       What: /dev/sdb2
      Tasks: 0 (limit: 7714)
     Memory: 44.0K
        CPU: 5ms
     CGroup: /system.slice/mnt-montagem.mount

Feb 16 15:46:12 localhost.localdomain systemd[1]: Mounting "Ponto de Montagem Teste"...
Feb 16 15:46:12 localhost.localdomain systemd[1]: Mounted "Ponto de Montagem Teste".
```

---

#### Montagem automática de uma unidade de montagem

As unidades de montagem podem ser montadas automaticamente sempre que o ponto de montagem for acessado. Para isso, precisamos de um arquivo `.automount`, junto com o arquivo `.mount` descrevendo a unidade. O formato básico é:
```
[Unit]
Description=

[Automount]
Where=

[Install]
WantedBy=multi-user.target
```

Como anteriormente, `Description=` é uma breve descrição do arquivo e `Where=` é o ponto de montagem. Por exemplo, um arquivo `.automount` em nosso exemplo anterior ficaria assim:
```
[Unit]
Description=Automount for the external data disk

[Automount]
Where=/mnt/external

[Install]
WantedBy=multi-user.target
```

Salve o arquivo com o mesmo nome do ponto de montagem (neste caso, `mnt-external.automount`), recarregue o `systemd` e inicie a unidade:
```
# systemctl daemon-reload
# systemctl start mnt-external.automount
```

Agora, sempre que o diretório `/mnt/external` for acessado, o disco será montado. Como anteriormente, para habilitar a montagem automática em cada inicialização usaríamos:
```
# systemctl enable mnt-external.automount
```

---

#### complementando mount

Por padrão somente o user **root** pode usar o `mount`, no entanto, se definirmos no `fstab` a `<options>` como `users`. Assim **qualquer** usuário poderá montar
```
<file system>   <mount point>   <type>  <options>       <dump>  <pass>
/dev/sdb2       /mnt/teste1      auto     users           0    0
```

Lembrando que se usar `user` (sem `s`) permite que qualquer usuário monte a partição, mas **APENAS** quem **montou** poderá **desmontar**.

Já `users` (com `s`) permite que **QUALQUER** usuário monte e desmonte a partição em específico.

Como, por exemplo, se tivermos a seguinte configuração no arquivo `/etc/fstab`:
```
/dev/sdb1    /media/rodrigo    auto    users    0     0
```

No usuário limitado, podemos rodar tanto `mount /dev/sdb1` como `mount /media/rodrigo`, que iremos montar a partição normalmente.

É possível fazer associação (*bind*) com o `mount` (montar um diretório no outro)

Como `root`, podemos pegar uma pasta qualquer, como a `/opt` e associá-la com o diretório `/home/rodrigo/teste` (pertencente ao usuário **rodrigo**), com o seguinte comando:
```
# mount --bind /opt /home/rodrigo/teste
```

Se rodarmos o `df` apenas, ainda não aparecerá esse novo ponto de montagem (`df` apenas **não** mostra os *bindings*), precisamos rodar `df -a`. Note que a associação será feita na partição (por exemplo `sda1`) que está `/opt`

No usuário limitado (`rodrigo` por exemplo), se executar um `ls` em `~/teste` podemos ver o que está em `/opt`, devido à associação criada.

Algo importante é que toda informação que o comando `df` está mostrando, é coletado lá em `/proc/mounts` que por sua vez é um link para `/proc/self/mounts`. Há um terceiro local também que geralmente o `systemd` olha para ele: `/proc/self/mountinfo`
```
# ls -l /proc/mounts 
lrwxrwxrwx. 1 root root 11 Feb 14 14:03 /proc/mounts -> self/mounts
```

Se rodar só o `mount`, tem o mesmo efeito do `df`

É possível ver pelo `systemctl` também: `systemctl list-units --type=mount`

A partir daqui, podemos pegar o `.mount` e rodar com `status`, para ver por exemplo, de onde ele está originando o ponto de montagem (por exemplo do `fstab`)
```
# systemctl status boot.mount
Warning: The unit file, source configuration file or drop-ins of boot.mount changed on disk. Run 'systemctl daemon-reload' to reload units.
● boot.mount - /boot
     Loaded: loaded (/etc/fstab; generated)
     Active: active (mounted) since Fri 2025-02-14 14:03:40 -03; 6 days ago
      Until: Fri 2025-02-14 14:03:40 -03; 6 days ago
      Where: /boot
       What: /dev/vda1
       Docs: man:fstab(5)
             man:systemd-fstab-generator(8)
      Tasks: 0 (limit: 7714)
     Memory: 4.0K
        CPU: 3ms
     CGroup: /system.slice/boot.mount

Feb 14 14:03:40 localhost systemd[1]: Mounting /boot...
Feb 14 14:03:40 localhost systemd[1]: Mounted /boot.
```

#### Complemento para umount

- `umount -f`: força a desmontagem de um sistema de arquivos
- `umount -r`: se o sistema de arquivos não puder ser desmontado, esse comando tenta torná-lo somente leitura

Considere um sistema de arquivos remoto montado em `/mnt/server` que se tornou inacessível devido à perda de conectividade de rede. Como poderíamos forçar a desmontagem, ou montá-lo como somente leitura se isso não for possível?

Passe os parâmetros `-f` e `-r` para `unmount`. O comando seria `umount -f -r /mnt/server`. Lembre-se de que podemos agrupar parâmetros, então `umount -fr /mnt/server` também funcionaria.

---

#### Exercícios interessantes da lpi.org

1. Considere a seguinte entrada em `/etc/fstab`:
```
/dev/sdb1 /data ext4 noatime,noauto,async
```
Esse sistema de arquivos será montado se o comando `mount -a` for emitido? Por quê?

**Resposta**: Ele **não** será montado. A chave é o parâmetro `noauto`, que indica que esta entrada será ignorada por `mount -a`.

---

2. Como usar mount para remontar como somente leitura um sistema de arquivos exFAT com o UUID `6e2c12e3-472d-4bac-a257-c49ac07f3761`, montado em `/mnt/data`?

**Resposta**: Visto que o sistema de arquivos está montado, você não precisa se preocupar com o tipo de sistema de arquivos ou o ID, basta usar a opção remount com o parâmetro ro (somente leitura) e o ponto de montagem:
```
# mount -o remount,ro /mnt/data
```

---

3. Como obter uma lista de todos os sistemas de arquivos `ext3` e `ntfs` atualmente montados em um sistema?

Use `mount -t`, seguido por uma lista separada por vírgula dos sistemas de arquivos:
```
# mount -t ext3,ntfs
```

---

4. Considere a entrada a seguir em `/etc/fstab`:
```
/dev/sdc1 /backup ext4 noatime,nouser,async
```

Seria possível um usuário montar esse sistema de arquivos com o comando `mount /backup`? Por quê?

**Resposta**: Não, o parâmetro `nouser` impede que usuários comuns montem este sistema de arquivos.

---

4. Considere um sistema de arquivos remoto montado em `/mnt/server` que se tornou inacessível devido à perda de conectividade de rede. Como poderíamos forçar a desmontagem, ou montá-lo como somente leitura se isso não for possível?

**Resposta**: Passe os parâmetros `-f` e `-r` para `unmount`. O comando seria `umount -f -r /mnt/server`. Lembre-se de que podemos agrupar parâmetros, então `umount -fr /mnt/server` também funcionaria.

---

5. Escreva uma entrada de `/etc/fstab` para montar um volume `btrfs` com o rótulo Backup em `/mnt/backup`, com opções padrão e sem permitir a execução de binários por ele.

**Resposta**: A linha seria `LABEL=Backup /mnt/backup btrfs defaults,noexec`

---

6. Considere a seguinte unidade de montagem do `systemd`:
```
[Unit]
Description=External data disk

[Mount]
What=/dev/disk/by-uuid/56C11DCC5D2E1334
Where=/mnt/external
Type=ntfs
Options=defaults

[Install]
WantedBy=multi-user.target
```

Qual seria uma entrada equivalente a `/etc/fstab` neste sistema de arquivos??

**Resposta**: A entrada seria: `UUID=56C11DCC5D2E1334 /mnt/external ntfs defaults`

7. Qual deve ser o nome de arquivo da unidade acima, para que ela possa ser usada pelo `systemd`? Onde ela deve ser posta?

**Resposta**: O nome de arquivo deve ser idêntico ao do ponto de montagem, no caso `mnt-external.mount`, posto em `/etc/systemd/system`.

8. (exercício Prof. Ricardo) No momento, seu diretório `/var` está montado na mesma partição que o diretório `/`. Para liberar algum espaço na partição `/`, faça com que o diretório `/var` seja permanentemente montado na partição `/dev/sdX1`. Lembre-se que os dados atuais do diretório `/var` estão fisicamente localizados na partição em que o `/` está montado, normalmente `/dev/sda1`,  e você terá que movê-los de alguma forma antes de simplesmente montar a nova partição. Cuidado ao realizar esse procedimento, na dúvida consulte a folha de respostas.

**Resposta**: O primeiro passo é montar a partição em um diretório temporário e mover os dados:
```
# mkdir /mnt/temp_var
# mount /dev/sdX1 /mnt/temp_var
# mv /var/* /mnt/temp_var/
```

Em seguida, configuramos o Linux para sempre montar o diretório `/var` na nova partição, que neste momento já possui os dados. Com o editor vi, edite o arquivo `/etc/fstab` e insira o seguinte registro:
```
/dev/sdX1 /var auto defaults 0 1
```

Para aplicar as configurações do `/etc/fstab`, execute o comando abaixo ou reinicialize o Linux:
```
# mount -a
# umount /mnt/temp_var 
```

---

### 104.5 Controlar permissões e propriedades de arquivos

Por ser um sistema multiusuário, o Linux precisa de alguma forma de rastrear quem é o proprietário de cada arquivo e se um usuário tem ou não permissão para executar ações em um arquivo. Isso serve para garantir a privacidade dos usuários que desejam manter o conteúdo de seus arquivos em sigilo, bem como para permitir colaboração, tornando certos arquivos acessíveis a diversos usuários.

Isso é feito por meio de um sistema de permissões em três níveis. Cada arquivo em disco pertence a um usuário e a um grupo de usuários e tem três conjuntos de permissões: um para seu proprietário, um para o grupo que possui o arquivo e um para todos os outros.

---

#### Bits de modo de acesso

<table border="1">
<thead>
    <tr>
        <th>SUID</th>
        <th>SGID</th>
        <th>Stick</th>
        <th>r</th>
        <th>w</th>
        <th>x</th>
        <th>r</th>
        <th>w</th>
        <th>x</th>
        <th>r</th>
        <th>w</th>
        <th>x</th>
    </tr>
</thead>
<tr>
    <td style="background-color:rgb(92, 73, 69); font-weight: bold; color: #FFF" align="center">0</td>
    <td style="background-color:rgb(92, 73, 69); font-weight: bold; color: #FFF" align="center">0</td>
    <td style="background-color:rgb(92, 73, 69); font-weight: bold; color: #FFF" align="center">0</td>
    <td style="background-color:rgb(15, 50, 246); font-weight: bold; color: #FFF" align="center">0</td>
    <td style="background-color:rgb(15, 50, 246); font-weight: bold; color: #FFF" align="center">0</td>
    <td style="background-color:rgb(15, 50, 246); font-weight: bold; color: #FFF" align="center">0</td>
    <td style="background-color:rgb(255, 0, 0); font-weight: bold; color: #FFF" align="center">0</td>
    <td style="background-color:rgb(255, 0, 0); font-weight: bold; color: #FFF" align="center">0</td>
    <td style="background-color:rgb(255, 0, 0); font-weight: bold; color: #FFF" align="center">0</td>
    <td style="background-color:rgb(6, 65, 6); font-weight: bold; color: #FFF" align="center">0</td>
    <td style="background-color:rgb(6, 65, 6); font-weight: bold; color: #FFF" align="center">0</td>
    <td style="background-color:rgb(6, 65, 6); font-weight: bold; color: #FFF" align="center">0</td>
</tr>
<tr>
    <td colspan="3" align="center">Atrib. Especiais</td>
    <td colspan="3" align="center">Usuário</td>
    <td colspan="3" align="center">Grupo</td>
    <td colspan="3" align="center">Outros</td>
</tr>
</table>

No `ls -l`, tendo o seguinte retorno:
```
-rw-rw-r--  2 lpi1 suporte       91 Sep 19 10:39  file
```

Temos que:

O primeiro caracter, no caso acima, `-`, que fica entre a segunda coluna (que indica o número de links físicos que apontam para aquele arquivo - no caso o número `2`) entre `lpi1` e `-rw-rw-r--`, significa o tipo do arquivo (não indica permissão):

- `-`: indica arquivo texto normal (podem ser modificados, movidos, copiados e excluídos)
- `d`: diretório: diretório contém outros arquivos ou diretórios e ajuda a organizar o sistema de arquivos. Tecnicamente, os diretórios são um tipo especial de arquivo
- `l`: link simbólico (este “arquivo” é um ponteiro para outro arquivo ou diretório em outro local no sistema de arquivos)
- `b`: dispositivo de bloco (`/dev`): representa um dispositivo virtual ou físico, geralmente discos ou outros tipos de dispositivos de armazenamento, como o primeiro disco rígido, que pode ser representado por `/dev/sda`
- `c`: caracter dispositivo especial (geralmente em `/dev`, terminais como `/dev/ttyS0` ou **portas seriais**).Pode ser virtual ou físico
- `s`: `socket` (canal que passa informação entre 2 programas). 

>[!WARNING]
>
>**Não** altere nenhuma permissão nos dispositivos de bloco, dispositivos de caracteres ou sockets, a menos que saiba muito bem o que está fazendo. Isso pode fazer o sistema parar de funcionar!

Sequencia de permissões do `user`, `group` e `others` (conforme tabela acima)

Sendo: `lpi1` o dono do arquivo **file** e `suporte` é o **grupo**

Portanto, o usuário dono `lpi1` tem permissão de leitura e escrita (`rw`) e os outros usuários (grupo suporte), também tem permissão de leitura e escrita. Os outros somente leitura (`r`). Olhando para a tabela no começo, são os bits ligados que representação o exemplo da saída `ls`

>[!TIP]
>
>O `ls -l diretorio` mostra o conteúdo do diretório `diretorio`. Caso queira ver as informações do diretório propriamente dito, use `-d` ou `--directory`.
```
$ ls -l Another_Directory/
total 0
-rw-r--r-- 1 carol carol 0 Dec 10 17:59 another_file.txt

$ ls -l -d Another_Directory/
drwxrwxr-x 2 carol carol 4096 Dec 10 17:59 Another_Directory/
```

---

#### rwx para arquivos

- `r`: quem tem essa permissao, consegue ler o arquivo (valor octal `4`)
- `w`: quem tem essa permissão, consegue escrever, modificar o arquivo. Consegue inclusive apagar o arquivo. (valor octal `2`)
- `x`: quem tem essa permissão, consegue executar o arquivo (valor octal `1`)
- `-`: o traço aqui representa a falta de permissão.

Assim, por exemplo, um arquivo com permissões `rw-` pode ser **lido** e **escrito**, mas **não** pode ser **executado**.

---

#### rwx para diretórios

- `r`: quem tem essa permissao, consegue listar o conteúdo do diretório. Se não tiver, não consegue nem listar (no caso com `ls`)
- `w`: quem tem essa permissão (usuário ou grupo), consegue criar e remover arquivos dentro do diretório.
- `x`: quem tem essa permissão, consegue acessar o diretório (consegue dar um `cd`). Se não tiver, não consegue acessar o diretório.

Exemplo retratando bem o que foi explicado acima:

A última parte sobre diretórios pode parecer um pouco confusa. Vamos imaginar, por exemplo, que você tem um diretório chamado `Another_Directory`, com as seguintes permissões:
```
$ ls -ld Another_Directory/
d--x--x--x 2 carol carol 4,0K Dec 20 18:46 Another_Directory
```

Imagine também que dentro deste diretório há um script de shell chamado `hello.sh`:
```
-rwxr-xr-x 1 carol carol 33 Dec 20 18:46 hello.sh
```

Se você for a usuária `carol` e tentar listar o conteúdo de `Another_Directory`, receberá uma **mensagem de erro**, pois seu usuário **não** tem permissão de leitura para esse diretório:
```
$ ls -l Another_Directory/
ls: cannot open directory 'Another_Directory/': Permission denied
```

No entanto, a usuária `carol` tem permissões de **execução**, o que significa que ela pode entrar no diretório. Portanto, a usuária carol pode acessar arquivos dentro do diretório, desde que tenha as permissões corretas para o respectivo arquivo. 

Vamos supor que a usuária tem permissões totais (`rwx`) para o script `hello.sh`. Nesse caso, se souber o nome do arquivo completo, ela pode executar o script, embora não possa ler o conteúdo do diretório que o contém:
```
$ sh Another_Directory/hello.sh
Hello LPI World!
```

#### leitura interessante extraída do lpi.org sobre sequencia de verificação de permissão arquivo

Como dissemos antes, as permissões são especificadas em sequência: primeiro para o proprietário do arquivo, depois para o grupo proprietário e, em seguida, para outros usuários. Sempre que alguém tenta realizar uma ação no arquivo, as permissões são verificadas na mesma ordem.

Primeiro, o sistema verifica se o usuário atual possui o arquivo e, se for o caso, ele aplica apenas o primeiro conjunto de permissões. Caso contrário, ele verifica se o usuário atual pertence ao grupo que possui o arquivo. Nesse caso, ele aplica o segundo conjunto de permissões apenas. Em qualquer outro caso, o sistema aplicará o terceiro conjunto de permissões.

Isso significa que, se o usuário atual for o proprietário do arquivo, apenas as permissões do proprietário serão efetivas, mesmo se as permissões do grupo ou outras forem mais permissivas do que as do proprietário.

---

#### chmod (modo simbólico)

`chmod` - altera permissões (apenas o **proprietário** do arquivo ou o **administrador** do sistema (root) pode alterar as permissões em um arquivo)

| Alvo | Operação | Permissão |
|---|---|---|
| u - user (usuário) | + (conceder uma permissão) | r - read (leitura) |
| g - group (grupo) | - (revogar uma permissão) | w - write (escrita) |
| o - others (outros) | = (definir com um valor específico) | x - execute (execução) |
| a - all (todos os acima) |  |  |

>[!NOTE]
>
>`chmod -R`: aplica recursivamente as permissões

>[!WARNING]
>
>Tenha cuidado e pense duas vezes antes de usar a opção `-R`, pois é fácil alterar sem querer as permissões de arquivos e diretórios, especialmente em diretórios com um grande número de arquivos e subdiretórios

Exemplos

Supõe:
```
-rw-rw-r-- 7 lpi1 suporte 91 Sep 19 10:39 file.txt
```

- `chmod g-w file.txt`   =>   `-rw-r--r--`
- `chmod a+x file.txt`   =>   `-rwxrwxr-x`
- `chmod ug+x file.txt` =>  `-rwxrwxr--`

>[!NOTE]
>
>As modificações acima não estão sequenciais, olhar sempre para o `ls` lá no começo, como referência para os comandos acima listados.

O igual (`=`) deixa realmente **igual a**, removendo outros atributos que tenha. Exemplo: Se deixarmos `rw`, caso tenha `rwx`, vai deixar apenas `rw` (removendo o `x`).

Supõe:
```
-rw-rw-r-- 7 lpi1 suporte 91 Sep 19 10:39 file.txt
```

- `chmod o=w file.txt` => `-rw-rw--w-`
- `chmod o=rw file.txt` => `-rw-rw-rw-`
- `chmod o=x file.txt` => `-rw-rw---x`

>[!NOTE]
>
>Esse modo é conhecido como modo simbólico (o outro modo é o **octal** , que é uma representação numérica)

>[!NOTE]
>
>`chmod ug+rw-x,o-rwx text.txt`: é possível combinar separando por vírgula

>[!NOTE]
>`chmod 660 text.txt`: equivalente em octal ao `chmod ug+rw-x,o-rwx text.txt`

---

#### Adendo ao `ls -a`

No `ls -a`, que mostra arquivos ocultos, temos que: Os diretórios `.` e `..`, são especiais. 

- `.`: é um ponteiro para o diretório atual. 
- `..`: é um ponteiro para o diretório pai, aquele que contém o atual. No Linux, cada diretório contém pelo menos esses dois diretórios.

--- 

#### chmod (modo octal)

| r | w | x |
|---|---|---|
| 2² | 2¹ | 2⁰ |
| 4 | 2 | 1 |

<table border="1">
<thead>
    <tr>
        <th>SUID</th>
        <th>SGID</th>
        <th>Stick</th>
        <th>r</th>
        <th>w</th>
        <th>x</th>
        <th>r</th>
        <th>w</th>
        <th>x</th>
        <th>r</th>
        <th>w</th>
        <th>x</th>
    </tr>
</thead>
<tr>
    <td style="background-color:rgb(92, 73, 69); font-weight: bold; color: #FFF" align="center">0</td>
    <td style="background-color:rgb(92, 73, 69); font-weight: bold; color: #FFF" align="center">0</td>
    <td style="background-color:rgb(92, 73, 69); font-weight: bold; color: #FFF" align="center">0</td>
    <td style="background-color:rgb(15, 50, 246); font-weight: bold; color: #FFF" align="center">1</td>
    <td style="background-color:rgb(15, 50, 246); font-weight: bold; color: #FFF" align="center">1</td>
    <td style="background-color:rgb(15, 50, 246); font-weight: bold; color: #FFF" align="center">1</td>
    <td style="background-color:rgb(255, 0, 0); font-weight: bold; color: #FFF" align="center">1</td>
    <td style="background-color:rgb(255, 0, 0); font-weight: bold; color: #FFF" align="center">1</td>
    <td style="background-color:rgb(255, 0, 0); font-weight: bold; color: #FFF" align="center">0</td>
    <td style="background-color:rgb(6, 65, 6); font-weight: bold; color: #FFF" align="center">1</td>
    <td style="background-color:rgb(6, 65, 6); font-weight: bold; color: #FFF" align="center">0</td>
    <td style="background-color:rgb(6, 65, 6); font-weight: bold; color: #FFF" align="center">0</td>
</tr>
<tr>
    <td colspan="3" align="center">Atrib. Especiais</td>
    <td colspan="3" align="center">Usuário</td>
    <td colspan="3" align="center">Grupo</td>
    <td colspan="3" align="center">Outros</td>
</tr>
<tr>
    <td colspan="3" align="center">000 = 0</td>
    <td colspan="3" align="center">111 = 4+2+1 = <strong>7</strong></td>
    <td colspan="3" align="center">110 = 4+2 = <strong>6</strong></td>
    <td colspan="3" align="center">100 = <strong>4</strong></td>
</tr>
<tr>
    <td colspan="3" align="center"></td>
    <td colspan="3" align="center">rwx</td>
    <td colspan="3" align="center">rw-</td>
    <td colspan="3" align="center">r--</td>
</tr>
<tr>
    <td colspan="12" align="center">0764 = <strong>-rwxrw-r--</strong></td>
</tr>
</table>

Supõe o retorno de `ls -l`:
```
-rw-rw-r-- 7 lpi1 suporte 91 Sep 19 10:39 file.txt
```

- `chmod 644 file.txt` => -`rw-r--r--`
- `chmod 775 file.txt` => -`rwxrwxr-x`
- `chmod 774 file.txt` => -`rwxrwxr--`

>[!NOTE]
>
>**Não** está sequencial, olhar sempre para o retorno do comando `ls` acima, como referência para os comandos acima listados.

>[!IMPORTANT]
>
>Lembrando que o que não for especificado no octal, é **removido** caso tenha valor:

Exemplo da seguinte permissão: `-rw-rw--wx`

Se usarmos `chmod 774`, ficará `-rwxrwxr--` (acaba removendo `wx` para `all`)

>[!TIP]
>
>Se o valor de uma permissão for **ímpar**, o arquivo certamente é **executável**!

---

#### stat

- `stat file.txt`: pega as informações no inode e mostra as permissões em modo **simbólico** e **octal**
```
# stat file.txt
  File: file.txt
  Size: 0         	Blocks: 0          IO Block: 4096   regular empty file
Device: fd00h/64768d	Inode: 17380368    Links: 1
Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)
Context: unconfined_u:object_r:systemd_unit_file_t:s0
Access: 2025-02-23 18:31:06.206230868 -0300
Modify: 2025-02-23 18:31:06.206230868 -0300
Change: 2025-02-23 18:31:06.206230868 -0300
 Birth: 2025-02-23 18:31:06.205230863 -0300
```

É possível notar na linha:
```
Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)
```

Resumidamente:

- `Modo octal`: ideal para mudança específica, mais fácil de lembrar e mais rápido de usar quando necessário alterar todas os valores de permissão de uma vez.
- `Modo simbólico`: ideal para inverter valores, sem mexer nos outros valores, mais refinado.

Comandos equivalentes:
- `chmod ug+rw-x,o-rwx text.txt`
- `chmod 660 text.txt`

```
-rw-rw---- 1 carol carol  765 Dec 20 21:25 text.txt
```

---

#### Bits de modos de acesso

São os `SUID`, `GUID` e `Sticky`. São atributos especiais, aqueles que vêm antes das permissões, visto no item anterior.

---

#### SUID

`SUID` (aplica-se a arquivos executáveis normalmente): por exemplo o arquivo `/usr/bin/passwd` (executável para alterar senha dos usuários), possui o atributo `SUID`, para controlar o comportamento de execução por usuários. No caso, `passwd` chama o `/etc/passwd` para atualizar a senha, no entanto, apenas **root** pode alterar o arquivo `/etc/ passwd`. `SUID` **não** tem efeito em diretórios.
```
# ls -l /usr/bin/passwd
-rwsr-xr-x 1 root root 68248 Mar 23  2023 /usr/bin/passwd
```

Apenas usuário `root` que pode alterar `/etc/passwd`
```
# ls -l /etc/passwd
-rw-r--r-- 1 root root 1611 Dec 18 05:45 /etc/passwd
```

Tendo esse atributo, um usuário comum, ao alterar sua senha, ele consegue gravar em `/etc/passwd`. Resumidamente, quando um arquivo com o bit `SUID` é executado, o processo resultante herda os **privilégios do proprietário** (quem criou o script ou executável) do arquivo, em vez de quem o executa.

Pense que um script comum criado por um determinado usuário, funciona de forma contrária à apresentada acima. Independentemente do usuário que for executar um script que outro usuário seja o dono (e que tenha permissão para todos executarem), o script é executado com as permissões do usuário que o executou (e não com as permissões de quem o criou ou é o dono)

Por exemplo, `-rwsr-xr-x 1 root root 59976 Feb  6  2024 /usr/bin/passwd` (no caso é indicado pelo `s` nas permissões do dono, em vez de `x` que normalmente vemos com mais frequencia)

Ainda para fixar a ideia, supõe que o script `exemplo.sh` foi criado pelo usuário `lpi1`, e que tenha permissão de executar para `all`. Se o usuário `lpi2` executar o script, que foi criado pelo usuário `lpi1`, será considerado as permissões que `lpi2` tem no momento. Essa seria uma ação **sem** `SUID`.

Para aplicar, usamos: `chmod u+s exmplo.sh` (vínculo precisa ser com o usuário)

Resumidamente:

- `Sem SUID`: executa com permissão de quem está executando
- `Com SUID`: executa com permissão do dono do arquivo (supõe que outro usuário está executando com as permissões do usuário dono do script)

Para aplicar o `SUID`, use o comando `chmod u+s script.sh`

>[!NOTE]
>
>`SUID` significa `Set User ID`. É uma propriedade do `owner` (lembrar da tabela `user`, `group` e `all`, que são três propriedades para cada um, `read`, `write` e `execute`.)

>[!TIP]
>
>Se o seu terminal exibe cores, como é o caso da maioria atualmente, é fácil ver se essas permissões especiais estão definidas olhando a saída de `ls -l`. Para o sticky bit, o nome do diretório pode ser mostrado em uma fonte preta com fundo azul. O mesmo se aplica aos arquivos com os bits SGID (fundo amarelo) e SUID (fundo vermelho). As cores podem ser diferentes dependendo da distribuição do Linux e das configurações do terminal que você usa.

Exemplo para `SUID`:<br>

<code>
# ls -l /usr/bin/passwd
-rwsr-xr-x 1 root root 68248 Mar 23  2023 <mark style="background-color: red; color: white;">/usr/bin/passwd</mark>
</code><br><br>

>[!IMPORTANT]
>
>`s` significa tem o `x` e `s`. Se tiver `S`, significa que tem só o `s`

`script.sh` apenas com o `SUID` habilitado (não executável)
```
# chmod u+s script.sh 
# ls -l script.sh 
-rwSr--r--. 1 root root 0 Feb 23 19:58 script.sh
```

`script.sh` após se tornar executável e com bit `SUID` habilitado
```
# chmod a+x script.sh 
# ls -l script.sh 
-rwsr-xr-x. 1 root root 0 Feb 23 19:58 script.sh
```

---

#### SGID

`SGID` (aplica-se a arquivos e diretórios): e basicamente se baseia nas permissões do grupo dono de determinado arquivo ou diretório

Para aplicar, use o comando: `chmod g+s script.sh`:

`rw-rwsr-x 1` (O `s` vai para grupo)

<code>
~# ls -l script.sh
-rwxr-sr-x 1 root root 0 Feb 26 22:39 <mark style="background-color: yellow; color: black;">script.sh</mark>
</code><br><br>

>[!IMPORTANT]
>
>Podemos ter arquivo com `SUID` e `SGID`

<code>
# ls -l script.sh
-rwsr-sr-x 1 root root 0 Feb 26 22:39 <mark style="background-color: red; color: white;">script.sh</mark>
</code><br><br>

Exemplo para entendimento:

Caso tenhamos um diretório que o dono seja o usuário `lpi1` e o grupo seja `suporte` com `SGID` habilitado (ou seja, que tenha executado o comando `chmod g+s diretorio1`), como exemplo abaixo:
```
drwxrwsr-x 2 lpi1 suporte    4096 Oct 30 09:15 diretorio1
```

>[!TIP]
>
>Como o usuário `lpi1` não faz parte do grupo `suporte`, ele **NÃO** poderá alterar o `SGID` (que é referente ao grupo), pode ser que tenha que executar o comando de alterar o GUID como `root`.

E entrarmos nesse diretório (`cd diretorio1`), autenticado com usuário `lpi1` e criarmos um arquivo qualquer (`arquivo_teste`), esse arquivo **herdará** o grupo `suporte`.
```
-rw-rw-r-- 1 lpi1 suporte 0 Oct 30 09:16 arquivo_teste
```

Lembrando que **SEM** o `GUID` habilitado, o normal seria criar o arquivo com grupo do **próprio** usuário que está criando:
```
-rw-rw-r-- 1 lpi1 lpi1 0 Oct 30 09:16 arquivo_teste2
```

>[!NOTE]
>
>`SGID` significa `Set GID` ou `Set Group ID`. É uma propriedade do `group` (lembrar da tabela `user`, `group` e `all`, que são três propriedades para cada um, `read`, `write` e `execute`.)

>[!IMPORTANT]
>
>Assim como para `SUID`, para `GUID` temos que `s` significa tem o `x` e `s`. Se tiver `S`, significa que tem só o `s`

`script.sh` apenas com GUID habilitado (não executável)
```
# chmod g+s script.sh 
# ls -l script.sh 
-rw-r-Sr--. 1 root root 0 Feb 23 19:58 script.sh
```

`script.sh` com GUID habilitado e executável
```
# chmod a+x script.sh 
# ls -l script.sh 
-rwxr-sr-x. 1 root root 0 Feb 23 19:58 script.sh
```

---

#### Sticky

`Sticky`: faz com que o arquivo só possa ser apagado ou renomeado por quem o criou. Dentro de um diretório é a mesma coisa, arquivos criados dentro dele, somente quem os criou que consegue apagar ou renomeá-los. (também conhecido como sinalizador de exclusão restrito)

>[!WARNING]
>
>O sticky bit se aplica apenas a diretórios. Não tem efeito em arquivos normais.

Exemplo clássico é o `/tmp`
```
drwxrwxrwt 100 root root      24576 Oct 30 09:24 tmp
```

No exemplo acima, é representado pelo `t` no `others` (em `/tmp` já é por padrão)

Dentro do `/tmp`, apenas quem criou que consegue excluir ou renomear, independentemente das permissões que os arquivos tenham (se tiver o `t`, só quem criou que apaga ou renomeia).

Para habilitar o sticky, use `chmod o+t arquivo_teste` (sempre vai ser no `o` de `others`)
```
-rw-rw-r-T 1 lpi1 lpi1    0 Oct 30 09:46 arquivo_teste
```

>[!IMPORTANT]
>
>`t`: significa que tem o `x` e `t`. Se for `T` significa que tem apenas o `t`. O mesmo ocorre quando temos apenas `s` do `SUID` ou `SGID`, como já vimos anteriormente.

- `t`: tem o `x` e o `t`
- `T`: tem só o `t`

---

#### Modo octal para SUID, SGID e Sticky

Segue o mesmo formato de `read` (`r`), `write` (`w`) e `execute` (`x`)

| SUID | SGID | Stick |
|---|---|---|
| 2² | 2¹ | 2⁰ |
| 4 | 2 | 1 |

<table border="1">
<thead>
    <tr>
        <th>SUID</th>
        <th>SGID</th>
        <th>Stick</th>
        <th>r</th>
        <th>w</th>
        <th>x</th>
        <th>r</th>
        <th>w</th>
        <th>x</th>
        <th>r</th>
        <th>w</th>
        <th>x</th>
    </tr>
</thead>
<tr>
    <td style="background-color:rgb(92, 73, 69); font-weight: bold; color: #FFF" align="center">1</td>
    <td style="background-color:rgb(92, 73, 69); font-weight: bold; color: #FFF" align="center">1</td>
    <td style="background-color:rgb(92, 73, 69); font-weight: bold; color: #FFF" align="center">0</td>
    <td style="background-color:rgb(15, 50, 246); font-weight: bold; color: #FFF" align="center">1</td>
    <td style="background-color:rgb(15, 50, 246); font-weight: bold; color: #FFF" align="center">1</td>
    <td style="background-color:rgb(15, 50, 246); font-weight: bold; color: #FFF" align="center">1</td>
    <td style="background-color:rgb(255, 0, 0); font-weight: bold; color: #FFF" align="center">1</td>
    <td style="background-color:rgb(255, 0, 0); font-weight: bold; color: #FFF" align="center">1</td>
    <td style="background-color:rgb(255, 0, 0); font-weight: bold; color: #FFF" align="center">1</td>
    <td style="background-color:rgb(6, 65, 6); font-weight: bold; color: #FFF" align="center">1</td>
    <td style="background-color:rgb(6, 65, 6); font-weight: bold; color: #FFF" align="center">0</td>
    <td style="background-color:rgb(6, 65, 6); font-weight: bold; color: #FFF" align="center">0</td>
</tr>
<tr>
    <td colspan="3" align="center">Atrib. Especiais</td>
    <td colspan="3" align="center">Usuário</td>
    <td colspan="3" align="center">Grupo</td>
    <td colspan="3" align="center">Outros</td>
</tr>
<tr>
    <td colspan="3" align="center">110 = 6</td>
    <td colspan="3" align="center">111 = 4+2+1 = <strong>7</strong></td>
    <td colspan="3" align="center">111 = 4+2+1 = <strong>7</strong></td>
    <td colspan="3" align="center">100 = <strong>4</strong></td>
</tr>
<tr>
    <td colspan="3" align="center"></td>
    <td colspan="3" align="center">rwx</td>
    <td colspan="3" align="center">rwx</td>
    <td colspan="3" align="center">r--</td>
</tr>
<tr>
    <td colspan="12" align="center">6774 = <strong>-rwsrwsr--</strong></td>
</tr>
</table>

Por exemplo, `110`, seria = `6`, pois teríamos `SUID` ligado (=`1`), `SGID` ligado (=`1`) e `Stick` desligado (=`0`)

Quando usarmos `chmod`, podemos definir `6774` (`chmod 6774 arquivo_teste`), que significaria que teríamos `rwsrwsr--`

>[!NOTE]
>
>O `chmod` **ignora** a configuração de `SUID`, `SGID` e `Stick` se omitir o primeiro dígito (na verdade considera como `zero`). Exemplo se usar `chmod 774`, vai estar usando `0774`

---

#### Mais um exemplo de chmod octal com SUID, SGID e Sticky

- `chmod 5664 arquivo`, vai retornar

```
-rwSrw-r-T 1 rodrigo rodrigo    0 Oct 30 09:46 arquivo 
```

Que no caso é `SUID` com `4` + `Sticky` com `1`, ficando igual a `5`

A parte do `user`: `Read` com `4` + `Write` com `2`, ficando igual a `6`)

Em `group`: fica `Read` com `4` + `Write` com `2`, sendo igual a `6`)

Por fim, `others`: que tem `Read` com `4` e os demais zerados, ficando igual a `4`)

Logo, conclue-se que o valor `5664` para uso no `chmod`

>[!TIP]
>
>Sempre é interessante utilizar o `stat` para ver as duas versões (simbólica e octal).

---

#### umask

`umask`: mostra a máscara padrão do momento para criação de arquivos e diretórios. Ela que define, de acordo com seu valor inicial, quais permissões serão atribuídas aos arquivos e aos diretórios criados. Se executar somente `umask`, mostra a máscara padrão usada no momento.

Exemplo de `umask 0002` (ignora o 1º zero)

- para **arquivos** ficaria `666`-`002` = `664` (`rw-rw-r--`)
- para **diretórios** ficaria `777`-`002`=`775` (`rwxrwxr-x`)

Se mudarmos o umask para `022` (com o comando `umask 022`), temos:

- **arquivos** `666`-`022` = `644` (`rw-r--r--`)
- **diretórios** `777`-`022` = `755` (`rwxr-xr-x`)

>[!NOTE]
>
>Cada usuário pode ter uma `umask` diferente (`root` por exemplo, o padrão é `022`)

>[!TIP]
>
>`umask -S`: mostra a máscara em modo simbólico (exemplo `u=rwx,g=rwx,o=rx`, que é igual a `775` em octal). `775` por padrão, **só para diretórios**, uma vez que eles **precisam** de permissão de execução, pois como são diretórios, sem permissão de execução não é possível acessá-los

Aleḿ de alterar umask com o comando `umask 007`, podemos usar diretamente no modo simbólico, como em `umask u=rwx,g=rwx,o=` (o que geraria arquivos com permissão `660` e diretórios com `770`)

>[!WARNING]
>
>Nem sempre realizar a subtração da máscara por `666` (arquivos) ou `777` (diretórios) vai dar certo.

Por exemplo a máscara `367`. Se apenas subtraírmos para achar a permissão para arquivos (`666`), ficaria algo estranho como `30-1`. Em máscaras assim, devemos seguir os passos:

1. Sempre pense em base octal quando for trabalhar com máscara. Teremos que passar cada dígito para binário (usando 3 espaços).

Exemplo:

| 6 | 6 | 6 |
|---|---|---|
| 1 1 0 | 1 1 0 | 1 1 0 |

2. Depois faça o mesmo com a máscara que estamos testando: `367`

| 3 | 6 | 7 |
|---|---|---|
| 0 1 1 | 1 1 0 | 1 1 1 |
| 4 2 1 | 4 2 1 | 4 2 1 |

Adicionamos uma linha no final, para já começar a pensar com a permissão final, seguindo mesmo modelo octal para `chmod`

3. use a fórmula: `!(umask) and permissão_padrao` (`permissão_padrão` é `666` ou `777`).

Basicamente é fazer uma operação `AND` com a negação da máscara e a permissão desejada (arquivo ou diretório)

```
!(011 110 111) AND 110 110 110

Representação em Decimal:
!(367) AND 666
```

4. Continuando, aplicando a fórmula, temos:
```
100 001 000 AND 110 110 110
```

Temos como resultado:
```
100 000 000
```

Volte de binário para octal:
```
400
```

Achado o resultado, aplique o modo octal igual foi feito com `chmod` (`read` = `4`, `write` = `2` e `execute` = `1`):

| 4 | 0 | 0 |
|---|---|---|
| 4 2 1 | 4 2 1 | 4 2 1 |
| r - - | - - - | - - - |
| user | group | others |

Assim descobrimos a permissão para a máscara `367`, a qual a máscara padrão será `400` ou `r-- --- ---` (somente leitura para o usuário)

---

#### Passo a passo sequencia dos comandos:

Criando arquivo com máscara `022`:
```
# touch file1
# stat file1 
  File: file1
  Size: 0         	Blocks: 0          IO Block: 4096   regular empty file
Device: fd00h/64768d	Inode: 33736983    Links: 1
Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)
Context: unconfined_u:object_r:admin_home_t:s0
Access: 2025-02-23 20:51:51.111005946 -0300
Modify: 2025-02-23 20:51:51.111005946 -0300
Change: 2025-02-23 20:51:51.111005946 -0300
 Birth: 2025-02-23 20:51:51.111005946 -0300
```

Agora definindo máscara `367` e criando arquivo:
```
# umask 367
# umask
0367
```

```
# touch file2
# stat file2
  File: file2
  Size: 0         	Blocks: 0          IO Block: 4096   regular empty file
Device: fd00h/64768d	Inode: 33736987    Links: 1
Access: (0400/-r--------)  Uid: (    0/    root)   Gid: (    0/    root)
Context: unconfined_u:object_r:admin_home_t:s0
Access: 2025-02-23 20:52:16.465147475 -0300
Modify: 2025-02-23 20:52:16.465147475 -0300
Change: 2025-02-23 20:52:16.465147475 -0300
 Birth: 2025-02-23 20:52:16.465147475 -0300
```

>[!NOTE]
>
>Para diretório, basta realizar o mesmo processo, mas usar o valor `777`.

| 7 | 7 | 7 |
|---|---|---|
| 1 1 1 | 1 1 1 | 1 1 1 |

Realizando a fórmula (lembrar que `367` é `011 110 111` em binário):
```
!(011 110 111) AND 111 111 111
```

Negando a máscara:
```
100 001 000 AND 111 111 111
```

Resulta em: `100 001 000`, que é igual a `410` em decimal, tendo a permissão `dr-- --x ---`. Vejamos a sequência passo a passo:

```
# umask 367
# mkdir dir_teste
# ls -ld dir_teste/
dr----x---. 2 root root 6 Feb 23 20:01 dir_teste/
```

Ou usando o comando `stat dir_teste`:
```
# stat dir_teste/
  File: dir_teste/
  Size: 6         	Blocks: 0          IO Block: 4096   directory
Device: fd00h/64768d	Inode: 50346100    Links: 2
Access: (0410/dr----x---)  Uid: (    0/    root)   Gid: (    0/    root)
Context: unconfined_u:object_r:admin_home_t:s0
Access: 2025-02-23 20:01:10.409144511 -0300
Modify: 2025-02-23 20:01:10.409144511 -0300
Change: 2025-02-23 20:01:10.409144511 -0300
 Birth: 2025-02-23 20:01:10.409144511 -0300
```

#### tabela para conversão

Em vez de fazer toda a fórmula apresentada acima, podemos também nos basear na seguinte tabela:

| Valor | Permissão Arquivos | Permissão Diretórios  |
|---|---|---|
| 0 | `rw-` | `rwx` |
| 1 | `rw-` | `rwx` |
| 2 | `r--` | `r-x` |
| 3 | `r--` | `r--` |
| 4 | `-w-` | `-wx` |
| 5 | `-w-` | `-w-` |
| 6 | `---` | `--x` |
| 7 | `---` | `---` |

Exemplo: `007` corresponde a `rwxrwx---`, assim como `367` corresponde a `400` para arquivos e `410` para diretórios

---

#### chown

`chown` (vem de change owner): mudar o `dono`/`grupo` de um arquivo (precisa ser **root**, pois pense: um usuário **não** pode atribuir para outro usuário). Se mesmo assim o usuário tentar, receberá uma mensagem de erro `Operation not allowed` ou `Operation now permitted`

Supondo que temos a seguinte condição:
```
-rwxrwxr-x 1 lpi1 lpi1 0 Mar 30 13:30 aula.txt
```

- `chown lpi2 aula.txt`: muda o dono de `lpi1` para `lpi2`
- `chown lpi2:suporte`: muda o dono para `lpi2` e o grupo para `suporte`
- `chown lpi2.suporte`: faz o mesmo (pode usar tanto `:` como `.`)
- `chown :suporte`: muda apenas o grupo, para `suporte`
- `chown .suporte`: faz o mesmo que o anterior (relembrando que pode usar tanto `:` como `.`)

Por fim, o arquivo `aula.txt` ficará dessa forma:
```
-rwxrwxr-x 1 lpi1 suporte 0 Mar 30 13:30 aula.txt
```

>[!IMPORTANT]
>
>Lembre-se de que o usuário que possui um arquivo **não** precisa pertencer ao grupo que possui o arquivo. No exemplo acima, o usuário `lpi1` **não** precisa ser um membro do grupo `suporte`

Para diretórios, se usar `chown lpi2 diretorio2`, vai mudar apenas no `diretório2` (nos arquivos internamente dele **não** mudará)
```
# ls -ld diretorio2/
dr----x---. 2 lpi1 suporte 32 Feb 23 21:39 diretorio2/

# ls -l
total 0
-r--------. 1 lpi1    suporte 0 Feb 23 21:39 file1
-r--------. 1 rodrigo rodrigo 0 Feb 23 21:39 file2
```

Para mudar internamente (recursivamente), usa a opção `-R` ou `--recursive`
```
# chown -R root diretorio2/
# ls -ld diretorio2/
dr----x---. 2 root suporte 32 Feb 23 21:39 diretorio2/
#  ls -l diretorio2/
total 0
-r--------. 1 root suporte 0 Feb 23 21:39 file1
-r--------. 1 root rodrigo 0 Feb 23 21:39 file2
# 
```

---

#### chgroup

`chgrp`: usado **apenas** para mudar o grupo

- `chgrp suporte aula.txt`: muda para o grupo `suporte` o arquivo `aula.txt`

>[!NOTE]
>
>`-R` faz recursivamente (igual `chown` e `chmod`).

Exemplo de uso:

- `chgrp suporte Aula.txt`: atribui o grupo `suporte` para o arquivo `Aula.txt`
```
# ls -l Aula.txt 
-rw-r--r--. 1 root root 0 Feb 23 21:52 Aula.txt

# chgrp suporte Aula.txt 


# ls -l Aula.txt
-rw-r--r--. 1 root suporte 0 Feb 23 21:52 Aula.txt
```

---

#### Consultando os grupos

Antes de alterar a propriedade de um arquivo, pode ser útil saber quais grupos existem no sistema, quais usuários são membros de um grupo e a quais grupos um usuário pertence

- `getent group`: retorna a lista de grupos no sistema (mesmo efeito de `cat /etc/group`)

Para saber a quais grupos o usuário pertence, use o comando:
- `groups rodrigo`: retorna os grupos que o usuário `rodrigo` pertence:
```
# groups rodrigo
rodrigo : rodrigo adm cdrom sudo dip plugdev users lpadmin sambashare docker libvirt tftp
```

Para fazer o inverso (ver quais usuários pertencem a um grupo), use `groupmems`. O parâmetro `-g` especifica o grupo, e `-l` lista todos os seus membros:
```
# groupmems -g docker -l
rodrigo 
```

---

#### exercícios interessantes retirados da lpi.org

1. Experimente o seguinte em um terminal: crie um arquivo vazio chamado `emptyfile` com o comando `touch emptyfile`. Agora “zere” as permissões do arquivo com `chmod 000 emptyfile`. O que acontecerá se você mudar as permissões de `emptyfile` passando apenas **um** valor de `chmod` para o modo **octal**, como em `chmod 4 emptyfile`? E se usarmos **dois**, como em `chmod 44 emptyfile`? O que aprendemos sobre a maneira como chmod interpreta o valor numérico?

Lembre-se de que “zeramos” as permissões de `emptyfile`. Assim, seu estado inicial seria:
```
---------- 1 carol carol    0 Dec 11 10:55 emptyfile
```

Agora, vamos tentar o **primeiro comando**, `chmod 4 emptyfile`:
```
$ chmod 4 emptyfile
$ ls -l emptyfile
-------r-- 1 carol carol 0 Dec 11 10:55 emptyfile
```

Viu só? As permissões de **outros** (`others`) foram alteradas. E se usássemos **dois** dígitos, como em `chmod 44 emptyfile`?
```
$ chmod 44 emptyfile
$ ls -l emptyfile
----r--r-- 1 carol carol 0 Dec 11 10:55 emptyfile
```

Agora, as permissões de **grupo** (`group`) e **outros** (`others`) foram afetadas. A partir disso, concluímos que no modo **octal** o `chmod` lê o valor “de trás pra frente”, do dígito menos significativo (**outros**, ou `others`) para o mais sigbificativo (**usuário**, `user`). Se você passar **um** dígito, modifica as permissões de **outros** (`others`). Com **dois** dígitos, modificamos **grupo** (`group`) e **outros** (`others`), com **três** modificamos **usuário** (`user`), **grupo** (`group`) e **outros** (`others`) e com **quatro** dígitos modificamos **usuário**, **grupo**, **outros** e as **permissões especiais**.

---

2. Considere as permissões do diretório temporário em um sistema Linux, `/tmp`:
```
$ ls -l /tmp
drwxrwxrwt  19 root root  16K Dec 21 18:58 tmp
```

Usuário, grupo e outros têm permissões totais. Mas um usuário regular pode excluir qualquer arquivo dentro deste diretório? Por quê?

`/tmp` é o que chamamos um diretório escrito por todos, ou seja, qualquer usuário pode escrever nele. Mas não queremos que um usuário modifique arquivos criados por outros, por isso o **sticky bit** foi definido (como indicado pelo `t` nas permissões de outros). Graças a isso, um usuário pode excluir arquivos em `/tmp`, mas **somente** se tiver criado esses arquivos.

---

### 104.6 Criar e alterar links simbólicos e hardlinks

No Linux temos dois tipos de links, o **simbólico** (`soft`) e os **físicos** (`hard`)

- `ln`: cria tanto `hard` como `soft link`. 

---

#### hardlink

Com `ls -li` ou `--inode`, podemos ver o `inode` do arquivo (lembrando que um arquivo pode ter **vários** `inodes`, e geralmente um arquivo aponta para um `inode`)

O `hard link`, cria um **novo nome** que aponta para o mesmo `inode`

Vejamos o arquivo `script.sh`, possui um `inode` dele (no caso, `33736983`):
```
# ls -li script.sh 
33736983 -rw-r--r--. 1 root root 0 Feb 23 22:55 script.sh
```

Para **criar** um `hard link`, usamos o comando: `ln script.sh Link-Hard`

Depois de criar, dê um `ls -li` em `script.sh` e em `Link-Hard`, e notará que os inodes são os mesmos (são dois arquivos que apontam para o mesmo lugar):
```
# ln script.sh Link-Hard
# ls -li script.sh Link-Hard 
33736983 -rw-r--r--. 2 root root 0 Feb 23 22:55 Link-Hard
33736983 -rw-r--r--. 2 root root 0 Feb 23 22:55 script.sh
```

Repare ainda que ambos possuem a mesma permissão (`-rw-r--r--`), e caso mude a permissão de um deles, irá mudar de ambos:
```
# ls -li script.sh Link-Hard 
33736983 -rw-r--r--. 2 root root 0 Feb 23 22:55 Link-Hard
33736983 -rw-r--r--. 2 root root 0 Feb 23 22:55 script.sh

# chmod 777 Link-Hard 

# ls -li script.sh Link-Hard 
33736983 -rwxrwxrwx. 2 root root 0 Feb 23 22:55 Link-Hard
33736983 -rwxrwxrwx. 2 root root 0 Feb 23 22:55 script.sh
```

Do mesmo modo caso altere o conteúdo de um deles, vai refletir no outro também (repare também que ambos permanecem com o mesmo tamanho):
```
# echo "teste" > Link-Hard

# cat Link-Hard 
teste

# cat script.sh 
teste

# ls -li script.sh Link-Hard 
33736983 -rwxrwxrwx. 2 root root 6 Feb 23 22:39 Link-Hard
33736983 -rwxrwxrwx. 2 root root 6 Feb 23 22:39 script.sh
```

Inclusive, mesmo excluíndo o arquivo `script.sh`, ainda teremos o arquivo `Link-Hard`, pois o arquivo em sí é apenas uma referência ao `inode` onde o arquivo aponta.
```
# rm script.sh 
rm: remove regular file 'script.sh'? y

# ls -l
total 8
-rwxrwxrwx. 1 root root    6 Feb 23 22:39 Link-Hard

# cat Link-Hard 
teste
```

Se observar com um `ls -l`, perceberá que a maioria dos arquivos possuem um único link de referência ao seu respectivo `inode`. Perceba também que diretórios possuem 2 links (ou referências para o mesmo `inode`)

Esse dois apontamentos, um é do próprio diretório e o outro é o ponto (`.`), que fica dentro do diretório, que aponta para ele mesmo.

Executando `ls -ldi /dir`, temos:
```
606222 drwxr-x--x 2 rodrigo rodrigo 4096 Oct 30 15:46 dir/
```

E caso execute `ls -ldi /dir/.`, teremos:
```
606222 drwxr-x--x 2 rodrigo rodrigo 4096 Oct 30 15:46 dir/.
```

Repare que eles têm os mesmo `inode`, ficando **dois** apontamentos.

---

#### Observações sobre hard link:

- **DEVEM** estar na **mesma** partição (não pode criar link apontando para outra partição, senão terá o erro: `Invalid cross-device link`). Pois é feito por meio de `inodes`, e cada partição tem a sua distribuição de `inodes`.
```
# ln script.sh /mnt/montagem/link-hard
ln: failed to create hard link '/mnt/montagem/link-hard' => 'script.sh': Invalid cross-device link
```

- **NÃO** é possível criar `hard links` para diretórios (se não recebe o erro: `hard link not allowed for directory`)
```
# mkdir diretorio1
# ln diretorio1 link-hard
ln: diretorio1: hard link not allowed for directory
```

>[!NOTE]
>
>Como os links físicos são tratados como arquivos regulares, eles podem ser excluídos com `rm` e renomeados ou movidos no sistema de arquivos com `mv`. E como um link rígido aponta para o mesmo `inode` do destino, ele pode ser movido livremente, sem medo de “quebrar” o link.

>[!NOTE]
>
>Mas qual é o original e qual é o link? **Não dá pra dizer**, já que, na prática, eles são a mesma coisa.

---

#### softlink

Link simbólico (`soft link`) é um **novo** arquivo que vai apontar para outro arquivo. (**não** é uma referencia ao `inode`, é simplesmente um arquivo que vai apontar para o arquivo **ORIGINAL**)

Para criar usa a opção `-s` ou `--symbolic` do `ln`

Vejamos um exemplo:
```
ln -s script.sh link_simbolico
```

Se der um `ls -l`, podemos ver o apontamento do link simbólico com os caracteres `->`
```
524717 lrwxrwxrwx 1 rodrigo rodrigo 9 Oct 30 16:07 link-simbolico -> script.sh
524711 -rw-r----- 1 rodrigo rodrigo 0 Oct 30 15:55 script.sh
```

>[!NOTE]
>
>Repare que os `inodes` são diferentes, o que caracteriza como um **novo** arquivo. Assim como a referência de apontamento (essa informação fica entre as `permissões` e `usuário`) que permanece = `1` (com `hard link`, esse número vai incrementando de acordo com a quantidade de novos links físicos - `hard link`)

>[!NOTE]
>
>Ainda nas permissões, repare que  o arquivo `link-simbolico` tem uma flag `l`, indicando que é um `link simbólico`, e sempre terá permissão `777` (`lrwxrwxrwx`) mas, na prática, as **permissões de acesso** para eles **são as mesmas** do destino

>[!IMPORTANT]
>
>Se **excluirmos** o arquivo para o qual o link aponta (**chamado destino**), o link **ainda existirá**, mas vai “para de funcionar”, pois passará a apontar para “nada”

Link simbólico funciona como um atalho, e podemos indicar `cross-device link`, ou seja, podemos apontar para outra partição (diferentemente do `hard link`).
```
# ln -s /mnt/montagem/file.txt link_particao

# ls -l
total 1

lrwxrwxrwx. 1 root root   22 Feb 23 23:09 link_particao -> /mnt/montagem/file.txt

# file link_particao 
link_particao: symbolic link to /mnt/montagem/file.txt
```

Repare no final do exemplo acima, é bem interessante usar o `file` no link simbólico, para saber onde ele aponta (além do uso do `ls -l` que também permite ver o local que aponta)

O tamanho do link simbólico é o tamanho dos caracteres do arquivo que ele aponta (no caso abaixo, `/tmp/test` possui 9 caracteres)
```
524727 lrwxrwxrwx 1 rodrigo rodrigo 9 Oct 30 16:24 simbolico -> /tmp/test
```

>[!IMPORTANT]
>
>Lembrar sempre de usar o **caminho absoluto** quando usar `soft links`, pois se usar o **caminho relativo**, se o arquivo for movido de lugar, acaba quebrando o link

É possível ainda criar link simbólico para diretórios, como por exemplo: `ln -s /var link-simbolico-var`
```
# ln -s /var link-simbolico-var

# ls -l
total 1
lrwxrwxrwx. 1 root root    4 Feb 23 23:46 link-simbolico-var -> /var
```

se fizermos um `cd link-simbolico-var`, e dermos um `ls`, iremos ver o conteúdo de `/var`
```
# ls -l link-simbolico-var/
total 16
drwxr-xr-x.  2 root root   19 Feb  5 15:56 account
drwxr-xr-x.  2 root root    6 Jun 25  2024 adm
drwxr-xr-x. 17 root root 4096 Feb  6 08:36 cache
drwxr-xr-x.  2 root root    6 Jan 17 00:31 crash
drwxr-xr-x.  3 root root   18 Feb  5 15:56 db
drwxr-xr-x.  2 root root    6 Jun 25  2024 empty
drwxr-xr-x.  2 root root    6 Jun 25  2024 ftp
drwxr-xr-x.  2 root root    6 Jun 25  2024 games
drwxr-xr-x.  3 root root   18 Jan 29 09:51 kerberos
drwxr-xr-x. 53 root root 4096 Feb  6 08:36 lib
drwxr-xr-x.  2 root root    6 Jun 25  2024 local
lrwxrwxrwx.  1 root root   11 Feb  5 15:54 lock -> ../run/lock
drwxr-xr-x. 13 root root 4096 Feb 23 00:00 log
lrwxrwxrwx.  1 root root   10 Jun 25  2024 mail -> spool/mail
drwxr-xr-x.  2 root root    6 Jun 25  2024 nis
drwxr-xr-x.  2 root root    6 Jun 25  2024 opt
drwxr-xr-x.  2 root root    6 Jun 25  2024 preserve
lrwxrwxrwx.  1 root root    6 Feb  5 15:54 run -> ../run
drwxr-xr-x.  9 root root   94 Feb  5 15:56 spool
drwxrwxrwt. 14 root root 4096 Feb 28 00:00 tmp
drwxr-xr-x.  2 root root    6 Jun 25  2024 yp
```

#### Exercícios interessantes da lpi.org

1. Explique a diferença entre um link físico para um arquivo e uma cópia desse arquivo.

Um link físico é apenas outro nome para um arquivo. Mesmo que pareça uma duplicata do arquivo original, para todos os efeitos, o link e o original são iguais, pois apontam para os mesmos dados no disco. As alterações feitas no conteúdo do link serão refletidas no original e vice-versa. Uma cópia é uma entidade completamente independente, ocupando um lugar diferente no disco. As alterações na cópia não serão refletidas no original e vice-versa.

2. Imagine que você tem, em seu diretório `~/Documents`, um arquivo chamado `clients.txt` contendo alguns nomes de clientes e um diretório chamado `somedir`. Dentro dele, existe um arquivo diferente, também chamado `clients.txt`, contendo nomes diferentes. Para replicar essa estrutura, use os seguintes comandos:
```
$ cd ~/Documents
$ echo "John, Michael, Bob" > clients.txt
$ mkdir somedir
$ echo "Bill, Luke, Karl" > somedir/clients.txt
```

Em seguida você cria um link dentro de somedir chamado `partners.txt` apontando para esse arquivo, com os comandos:
```
$ cd somedir/
$ ln -s clients.txt partners.txt
```

Assim, a estrutura do diretório é:
```
Documents
|-- clients.txt
`-- somedir
    |-- clients.txt
    `-- partners.txt -> clients.txt
```

Agora, você move `partners.txt` de `somedir` para `~/Documents`, e lista seu conteúdo.
```
$ cd ~/Documents/
$ mv somedir/partners.txt .
$ less partners.txt
```

O link ainda funciona? Se sim, qual arquivo terá seu conteúdo listado? Por quê?

Isto é quase uma “pegadinha”, mas o link funcionará e o arquivo listado será o que está em `~/Documents`, contendo os nomes `John`, `Michael`, `Bob`.

Lembre-se de que, como não especificamos o caminho completo para o alvo `clients.txt` ao criar o link simbólico `partners.txt`, o local do destino será interpretado como sendo relativo ao local do link, que neste caso é o diretório atual.

Quando o link é movido de `~/Documents/somedir` para `~/Documents`, ele deveria parar de funcionar, já que o destino não estava mais no mesmo diretório do link. Porém, coincidentemente existe um arquivo chamado `clients.txt` em `~/Documents`, de forma que o link apontará para esse arquivo em vez do destino original dentro de `~/somedir`.

Para evitar isso, sempre especifique o caminho completo para o destino ao criar um link simbólico.

3. Considere os arquivos a seguir:
```
-rw-r--r-- 1 carol carol 19 Jun 24 11:12 clients.txt
lrwxrwxrwx 1 carol carol 11 Jun 24 11:13 partners.txt -> clients.txt
```

Quais são as permissões de acesso de `partners.txt`? Por quê?

As permissões de acesso de `partners.txt` são `rw-r—​r--`, já que os links sempre herdam as mesmas permissões de acesso do alvo.

---

### 104.7 Encontrar arquivos de sistema e conhecer sua localização correta

- `FHS` - *FileSystem Hierarchy Standard* (Hierarquia Padrão do Sistema de Arquivos). É um projeto da Linux Foundation para padronizar a estrutura de diretórios e o conteúdo dos diretórios nos sistemas Linux. A conformidade com o padrão não é obrigatória, mas a maioria das distribuições o segue
- É um padrão de localização de arquivos utilizado pela maioria das distribuições Linux, isso simplifica muito a interoperação e administração do sistema.

>[!NOTE]
>
>Para saber mais sobre a organização dos sistemas de arquivos pode consultar a especificação do FHS 3.0 specification, disponível em vários formatos em: http://refspecs.linuxfoundation.org/fhs.shtml

---

#### Diretório Obrigatórios em /

| Diretório | Finalidade | Exemplo |
|----|----|----|
| `/` | é o diretório raiz, o primeiro da hierarquia. Todos os outros diretórios ficam dentro dele. Um sistema de arquivos muitas vezes é comparado a uma “árvore”; nesse caso, este seria o “tronco” ao qual todos os galhos se conectam. |
| `/bin` | programas críticos, todos usuários podem utilizar | `cp`, `ls`, `kill`, `rm` |
| `/sbin` | Programas críticos, voltados para **SysAdmin** (binários do sistema) | `fdisk`, `fsck`, `mkfs`, `quotaon` |
| `/etc` | Arquivos de configuração do sistema (da instalação do linux), se necessário, os programas podem criar subdiretórios sob `/etc` para armazenar diversos arquivos de configuração | `passwd`, `inittab`, `profile` |
| `/lib` | Bibliotecas compartilhadas necessárias para inicializar o sistema operacional e executar binários que estão em `/bin` e `/sbin` (e módulos do kernel) |
| `/mnt` e `/media` | Pontos de montagem de media como pen drives, leitores de CD e DVD-ROM, disquetes e cartões de memória, além de discos externos | `/mnt/dvd`, `/media/cdrom` |
| `/proc` e `/sys` | Informações de Hardware e Processos (sistema de arquivos virtual contendo dados relacionados a processos em execução) | `interrupts`, `cpu` |
| `/dev` | Dispositivos e Arquivos especiais, que podem ser dispositivos físicos conectados ao sistema ou virtuais fornecidos pelo kernel | `sda`, `sr0`, `tty` |

---

#### Diretórios que podem ser montados em partições específicas

| Diretório | Finalidade | Exemplo |
|----|----|----|
| `/root` | Diretório padrão do usuário `root` |
| `/boot` | Arquivos de configuração do `bootloader`, `imagens de kernel` e `initrd` |
| `/tmp` | Arquivos temporários |
| `/home` | Diretórios e Arquivos dos usuários (exceção é do superusuário `root`, que fica em `/root`) |
| `/var` | Arquivos dinâmicos como `logs`, `fila de impressão`, arquivos temporários, cache de navegador, etc | `/var/log`, `/var/mail` |
| `/usr` | Instalação de programas do Linux. Normalmente programas **não críticos** (dados de usuários de apenas leitura, incluindo dados utilizados por certos utilitários e aplicações secundárias) | `/usr/bin`, `/usr/lib`, `usr/sbin` |
| `/opt` | Instalações de Aplicações em Geral (pacotes de software opcionais) | editor de texto (de terceiros) |
| `/srv` | dados de serviços fornecidos pelo sistema  | as páginas fornecidas por um servidor web poderiam ser armazenadas em `/srv/www` |

---

#### Explorando /usr

| Diretório | Finalidade | Exemplo |
|----|----|----|
| `/usr/local` | Arquivos que o **sysadmin** instala localmente  |
| `/usr/X11R6` | Arquivos referentes à interface gráfica |
| `/usr/bin` | comandos **não essenciais**. Todos os usuários (`/bin` são os essenciais/críticos) | `head`, `du`, `dpkg`, `nice` |
| `/usr/sbin` | comandos **não essenciais**. **Sysadmin** (`/sbin` são os essenciais/críticos) | `edquota`, `xfs_info`, `useradd` |
| `/usr/lib` | bibliotecas de programas |
| `/usr/share/man` | Fontes do `man` |

---

#### /tmp

>[!NOTE]
>
>A versão 3.0 do *Filesystem Hierarchy Standard* (FHS) define locais padrão para os arquivos temporários nos sistemas Linux. Cada local tem uma finalidade e um comportamento diferentes, e é recomendável que os desenvolvedores sigam as convenções definidas pelo FHS ao gravar dados temporários no disco.

De acordo com o `FHS`, não se deve pressupor que os arquivos escritos aqui serão preservados entre as invocações de um programa. A recomendação é que esse diretório seja limpo (todos os arquivos apagados) durante a inicialização do sistema, embora isso não seja obrigatório.

Os arquivos temporários são arquivos usados pelos programas para armazenar dados que serão necessários apenas por um curto período de tempo — por exemplo, dados de processos em execução, logs de falhas, arquivos de rascunho de um salvamento automático, arquivos intermediários usados durante uma conversão, arquivos de cache e assim por diante.

---

#### /var/tmp

Outro local para arquivos temporários, mas este **não deve** ser limpo durante a inicialização do sistema, ou seja, os arquivos armazenados aqui geralmente persistem entre as reinicializações.

---

#### /run

Este diretório contém arquivos variáveis de tempo de execução usados pelos processos ativos, como os arquivos identificadores de processo (`.pid`). Os programas que precisam de mais de um arquivo de tempo de execução podem criar subdiretórios aqui. Este local deve ser limpo durante a inicialização do sistema. Antigamente essa finalidade pertencia a `/var/run` e, em alguns sistemas, `/var/run` pode ser um link simbólico para `/run`.
```
~$ ls -ld /var/run
lrwxrwxrwx 1 root root 4 Aug 18  2024 /var/run -> /run
```

>[!NOTE]
>
>Observe que nada impede o programa de criar arquivos temporários em outro local do sistema, mas é recomendável respeitar as convenções definidas pelo FHS.

---

#### find

Conteúdo já visto no tópico [103.3 Gerenciamento básico de arquivos](#find), caso queira consultar. No entanto iremos revisar nesse tópico.

- `find`: comando mais completo para buscas no linux.
- `find local_busca -name arquivo`: busca pelo nome do arquivo no local desejado

---

#### busca por nome

- `find /home -name Aula3`: busca por nome (`-name`) do arquivo, no caso `Aula3` em `/home`
- `find /home -name Aula*`: tudo que tiver com Aula+qualquer (busca recursiva)

---

#### busca por usuário

- `find /home -user lpi2`: busca todos os arquivos que o dono seja o usuário `lpi2` em `/home`

---

#### busca por tamanho

- `find /home -size +50M` (pode usar `G`, como em `+4G` maiores que `4 GB`): busca arquivos que tenham mais de `50 MB` em `/home` (pode usar menos: `-10K`: arquivos com menos de `10KB`)

>[!TIP]
>
>Pode combinar (tamanho e usuário):
- `find /home -size +5M -user lpi1`: arquivo com mais de 5 MB e que usuário dono seja lpi1

*Em termos de performance, o `find` é pior, pois agrega mais filtros de pesquisa. Os demais são mais rápidos, pois são mais direcionados (são mais simples).

Podemos ainda usar os seguintes padrões de busca por **atributos**:

- `-user USERNAME`: Encontra arquivos de que o usuário `USERNAME` é proprietário.
- `-group GROUPNAME`: Encontra arquivos de que o grupo `GROUPNAME` é proprietário.
- `-readable`: Encontra arquivos que podem ser lidos pelo usuário atual.
- `-writable`: Encontra arquivos que podem ser gravados pelo usuário atual.
- `-executable`: Encontra arquivos que podem ser executados pelo usuário atual. No caso dos diretórios, ele encontrará quaisquer diretórios em que o usuário pode entrar (permissão `x`).
- `-perm NNNN`: Encontra quaisquer arquivos que tenham exatamente a permissão `NNNN`. Por exemplo, `-perm 0664` corresponde a quaisquer arquivos que o usuário e grupo podem ler e gravar e que outros podem ler (ou `rw-rw-r--`).

Adicione um `-` antes de `NNNN` para procurar por arquivos que tenham pelo menos a permissão especificada. Por exemplo, `-perm -644` encontraria arquivos que tenham permissões de ao menos `644` (`rw-r—​r--`). Isso inclui arquivos com `664` (`rw-rw-r--`) ou mesmo `775` (`rwxrwx-r-x`).

- `-empty`: Encontra arquivos e diretórios vazios.
- `-size N`: Encontra qualsquer arquivos de tamanho `N`, onde `N` por padrão é um número de blocos de `512` bytes. Podemos adicionar sufixos a `N` para as outras unidades: `Nc` conta o tamanho em bytes, `Nk` em kibibytes (KiB, múltiplos de 1024 bytes), `NM` em mebibytes (MiB, múltiplos de 1024 * 1024) e `NG` para gibibytes (GiB, múltiplos de 1024 * 1024 * 1024).

Aqui também, podemos usar os prefixos `+` ou `-` (que aqui significam **maior que** e **menor que**) para buscar por tamanhos relativos. Por exemplo, `-size -10M` corresponderia a qualquer arquivo **menor de 10 MiB**.

Assim, para pesquisar arquivos em seu diretório inicial que contenham o padrão `report` (**sem** distinção entre **maiúsculas** e **minúsculas**) em qualquer parte do nome, tenham permissões `0644`, foram acessados há 10 dias e cujo tamanho é de pelo menos 1 Mib, usaríamos
```
$ find ~ -iname "*report*" -perm 0644 -atime 10 -size +1M
```

Podemos também realizar busca por **tempo**:

Além da busca por atributos, também é possível realizar buscas por data e hora, encontrando arquivos que foram acessados, tiveram seus atributos alterados ou foram modificados durante um determinado período de tempo. Os parâmetros são:

- `-amin N`, `-cmin N`, `-mmin N`: corresponde a arquivos que foram acessados, tiveram atributos alterados ou foram modificados (respectivamente) `N` minutos atrás.
- `-atime N`, `-ctime N`, `-mtime N`: corresponde a arquivos que foram acessados, tiveram atributos alterados ou foram modificados `N`*`24` horas atrás.

Para `-cmin N` e `-ctime N`, qualquer alteração de atributo é levada em conta, incluindo mudanças nas permissões, leitura ou gravação no arquivo. Isso torna esses parâmetros especialmente poderosos, uma vez que praticamente qualquer operação envolvendo o arquivo fará com que ele corresponda aos parâmetros da busca.

O exemplo a seguir corresponderia a qualquer arquivo no diretório atual que foi modificado há menos de 24 horas e é maior que 100 MiB:
```
$ find . -mtime -1 -size +100M
```

---

#### Exemplo interessante de find extraído da lpi.org
```
$ find . -name '*.jpg*'
./pixel_3a_seethrough_1.jpg
./Pentaro.jpg.zip
./Mate3.jpg
./Expert.jpg
```
Significa “qualquer coisa .jpg qualquer coisa”

>[!TIP]
>
>Lembre-se de que o parâmetro `-name` diferencia maiúsculas de minúsculas. Se quiser fazer uma pesquisa que não diferencia maiúsculas de minúsculas, use `-iname`.

>[!TIP]
>
>Por padrão, o `find` começa no ponto de partida e vai descendo pelos subdiretórios (e subdiretórios desses subdiretórios) encontrados. Para restringir esse comportamento, use os parâmetros `-maxdepth N`, onde `N` é o número máximo de níveis.

Para pesquisar apenas no diretório atual, usaríamos `-maxdepth 1`. Suponha que você tem a seguinte estrutura de diretório:
```
directory
├── clients.txt
├── partners.txt -> clients.txt
└── somedir
    ├── anotherdir
    └── clients.txt
```

Para pesquisar dentro de `somedir`, você precisará usar `-maxdepth 2` (o diretório atual `+1` nível abaixo). Para pesquisar dentro de `anotherdir`, `-maxdepth 3` seria necessário (o diretório atual `+2` níveis abaixo). O parâmetro `-mindepth N` faz o contrário, pesquisando apenas em diretórios no mínimo `N` níveis abaixo.

O parâmetro `-mount` pode ser usado para evitar que o `find` mergulhe em sistemas de arquivos montados. Também é possível restringir a pesquisa a tipos específicos de sistemas de arquivos usando o parâmetro `-fstype`. Assim, `find /mnt -fstype exfat -iname "*report*"` buscaria somente dentro de sistemas de arquivos `exFAT` montados sob `/mnt`.

---

#### locate

`locate`: baseado em uma database interno, que procura pelo arquivo nesse database (não faz uma varredura no disco todo). Retorna os arquivos de acordo com a `string` definida na busca

- `locate rpm`: busca por arquivos que contenham a palavra `rpm` (no **começo**, **meio** ou **fim**)

>[!NOTE]
>
>Lembrando que a busca é feita dentro da banco de dados dele (o que o torna mais rápido que o `find`). Essa banco de dados necessita ser atualizada de tempos em tempos, normalmente quando inicia o computador, ou é agendado. Nem sempre pode estar atualizado.

Se criar um novo arquivo e buscá-lo pelo locate, ele não vai encontrar, pois não atualizou na base de dados. Para forçar a atualização, use:

- `updatedb` (como root). O `updatedb` usa as configurações de `/etc/updatedb.conf` (local do banco de dados: `var/lib/mlocate.db`)

---

#### Controlando o comportamento de updatedb


O comportamento do `updatedb` pode ser controlado pelo arquivo `/etc/updatedb.conf`. Trata-se de um arquivo de texto no qual cada linha controla uma variável. As linhas em branco são ignoradas e as linhas que começam com o caractere `#` são tratadas como comentários.

- `PRUNEFS=`: quaisquer tipos de sistemas de arquivos indicados após este parâmetro **não** serão analisados pelo `updatedb`. A lista de tipos deve ser separada por espaços e os tipos em si não diferenciam maiúsculas de minúsculas, de forma que `NFS` e `nfs` são a mesma coisa.
- `PRUNENAMES=`: Lista de nomes de diretórios separados por espaços que não deverá ser analisada pelo `updatedb`.
- `PRUNEPATHS=`: lista de nomes de caminhos que devem ser ignorados pelo `updatedb`. Os nomes de caminhos devem ser separados por espaços e especificados da mesma maneira como seriam mostrados pelo `updatedb` (por exemplo, `/var/spool` `/media`)
- `PRUNE_BIND_MOUNTS=`: esta é uma simples variável de `yes` ou `no`. Se definida como `yes`, as `bind mounts` (montagens de ligação: diretórios montados em outros locais com o comando `mount --bind`) serão ignoradas.

O parâmetro `-e` ou `--existing`, fará com que o `locate` verifique se o arquivo ainda existe antes de mostrá-lo na saída (obviamente, isso não fará com que os arquivos criados após a última atualização do banco de dados apareçam, para atualizar precisaria executar o comando `updatedb`)

>[!NOTE]
>
>`-i` ou `--ignore-case` elimita o **case sensitive**

>[!NOTE]
>
>`-c` tem o mesmo efeito que `wc -l`. Que no caso seria contar o número de arquivos que correspondem a um determinado padrão em vez de mostrar o caminho completo, por exemplo para contar o número de arquivos .jpg em um sistema:
```
$ locate -c .jpg
1174
```

>[!NOTE]
>
>Para LPI, memorizar: `locate` > `updatedb` > `/etc/updatedb.conf`

>[!IMPORTANT]
>
>Com `locate`, estamos procurando por **padrões**, e não por **extensões** de arquivo.

Exemplo:
```
$ locate jpg
/home/carol/Downloads/Expert.jpg
/home/carol/Downloads/Hotbit.jpg
/home/carol/Downloads/Mate1.jpg
/home/carol/Downloads/Mate2.jpg
/home/carol/Downloads/Mate3.jpg
/home/carol/Downloads/Pentaro.jpg
/home/carol/Downloads/Sala.jpg
/home/carol/Downloads/pixel_3a_seethrough_1.jpg
/home/carol/Downloads/jpg_specs.doc
```

Quando buscamos pelo padrão `jpg`, o `locate` mostra qualquer coisa que contenha esse padrão, não importa o que venha antes ou depois. Você pode ver um exemplo disso no arquivo `jpg_specs.doc` na lista acima: ele contém o padrão, mas sua extensão **não** é `jpg`.

Em princípio, o padrão **diferencia** maiúsculas de minúsculas. Isso significa que arquivos contendo `.JPG` **não** seriam mostrados, pois o padrão está em letras minúsculas. Para evitar isso, passe o parâmetro `-i` para `locate`. Repetindo nosso exemplo anterior:
```
$ locate -i .jpg
/home/carol/Downloads/Expert.jpg
/home/carol/Downloads/Hotbit.jpg
/home/carol/Downloads/Mate1.jpg
/home/carol/Downloads/Mate1_old.JPG
/home/carol/Downloads/Mate2.jpg
/home/carol/Downloads/Mate3.jpg
/home/carol/Downloads/Pentaro.jpg
/home/carol/Downloads/Sala.jpg
/home/carol/Downloads/pixel_3a_seethrough_1.jpg
```

Observe que o arquivo `Mate1_old.JPG`, destacado em negrito acima, não estava presente na listagem anterior.

Para passar **vários** padrões para `locate`, basta separá-los com espaços. O exemplo abaixo faria uma busca sem distinção entre maiúsculas e minúsculas por quaisquer arquivos que correspondam aos padrões `zip` e `jpg`:
```
$ locate -i zip jpg
/home/carol/Downloads/Expert.jpg
/home/carol/Downloads/Hotbit.jpg
/home/carol/Downloads/Mate1.jpg
/home/carol/Downloads/Mate1_old.JPG
/home/carol/Downloads/Mate2.jpg
/home/carol/Downloads/Mate3.jpg
/home/carol/Downloads/OPENMSXPIHAT.zip
/home/carol/Downloads/Pentaro.jpg
/home/carol/Downloads/Sala.jpg
/home/carol/Downloads/gbs-control-master.zip
/home/carol/Downloads/lineage-16.0-20190711-MOD-quark.zip
/home/carol/Downloads/pixel_3a_seethrough_1.jpg
/home/carol/Downloads/jpg_specs.doc
```

Ao usar múltiplos padrões, você pode solicitar ao locate que exiba apenas os arquivos que correspondam a todos eles. Isso é feito com a opção `-A` ou `--all`. O exemplo a seguir mostraria qualquer arquivo que corresponda aos padrões `.jpg` e `.zip`:
```
$ locate -A .jpg .zip
/home/carol/Downloads/Pentaro.jpg.zip
```

---

#### whereis

`whereis`: mais específico que o `locate` (não usa base de dados), mais ágil pois busca onde tem os **executáveis**, as **libs**, os **manuais** e as **fontes** (**NÃO** busca no sistema todo!) Por exemplo, **NÃO** busca onde estão os arquivos dos usuários (`/home`)

>[!NOTE]
>
>`whereis` busca apenas a referência no começo do arquivo!

- `whereis rpm`: retorna apenas se o arquivo se chamar `rpm`+`alguma_coisa`

>[!TIP]
>
>Bastante usado para saber onde está localizado determinado comando.

- `whereis ls`: retorna local onde está o comando ls.
```
$ whereis ls
ls: /usr/bin/ls /usr/share/man/man1/ls.1.gz
```

Podemos filtrar rapidamente os resultados usando opções de linha de comando como:

- `-b`: para limitá-los apenas aos **binários**:
```
$ whereis -b ls
ls: /usr/bin/ls
```
- `-m`: para limitá-los apenas a **páginas de manual**:
```
~$ whereis -m ls
ls: /usr/share/man/man1/ls.1.gz
```
- `-s`: para limitá-los apenas ao **código-fonte** (source code).

---

#### which

`which`: procura somente nos diretório listados em `PATH` da sessão atual, e retorna somente a primeira ocorrência que encontrar na listagem de diretórios dentro de `PATH` (o `which` para no diretório que encontrar, e **não** olha os demais).

O `which` é um comando muito útil que mostra o caminho completo para um executável. Por exemplo, se você quiser localizar o executável para `bash`, pode usar:
```
$ which bash
/usr/bin/bash
```

>[!NOTE]
>
>Para consultar o `PATH`, use o comando: `env | grep PATH` ou `echo $PATH`

- `which rpm`, retorna:
```
/usr/bin/rpm
```

Assim como `which ls`, retorna:
```
/usr/bin/ls
```

>[!TIP]
>
>Ideal para uso em *scripts*, pois retorna apenas **um** resultado.

>[!NOTE]
>
>Caso `-a` for adicionado, o comando mostrará **todos** os nomes de caminho que correspondem ao executável
```
$ which tar
/usr/bin/tar

$ which -a tar
/usr/bin/tar
/bin/tar
```

---

#### type

`type`: mostra o tipo de arquivo que está olhando (*Display information about command type*)

- `type ls`: retorna que `ls` é um alias para `'ls --color=auto'`
```
$ type ls
ls is aliased to `ls --color=auto'
```

- `type cd` retorna:
```
cd is a shell builtin
```

- `type tar` retorna:
```
tar is /usr/bin/tar
```

- `type fsck` retorna:
```
fsck is /usr/sbin/fsck
```

[!NOTE]
>
>`-a` funciona da mesma maneira que em `which`, mostrando todos os nomes de caminho que correspondem ao executável
```
$ type ls
ls is aliased to `ls --color=auto'


$ type -a ls
ls is aliased to `ls --color=auto'
ls is /usr/bin/ls
ls is /bin/ls
```

E o parâmetro `-t` mostra o tipo de arquivo do comando que pode ser `alias`, `keyword`, `function`, `builtin` ou `file`. Por exemplo:
```
$ type -t locate
file

$ type -t ll
alias

$ type -t type
type is a built-in shell command
```

#### Exercicios interessantes da lpi.org

1. Qual é o diretório temporário que deve ser limpo durante o processo de inicialização?

O diretório é `/run` ou, em certos sistemas, `/var/run`.

2. Usando o `find`, pesquise apenas no diretório atual por arquivos que são graváveis pelo usuário, foram modificados nos últimos 10 dias e são maiores que 4 GB.

Para isso, precisamos dos parâmetros `-writable`, `-mtime` e `-size`:
```
find . -writable -mtime -10 -size 4G
```

3. Usando `locate`, encontre todos os arquivos contendo os padrões **report** e **updated**, **update** ou **updating** em seus nomes.

Como locate precisa encontrar todos os padrões correspondentes, use a opção `-A`:
```
locate -A "report" "updat"
```

4. Qual variável precisa ser adicionada a `/etc/updatedb.conf` para que `updatedb` ignore sistemas de arquivos `ntfs`?

A variável é `PRUNEFS=` seguida pelo tipo do sistema de arquivos: `PRUNEFS=ntfs`

5. Um administrador de sistema deseja montar um disco interno (`/dev/sdc1`). De acordo com o **FHS**, em qual diretório este disco deve ser montado?

Na prática, o disco pode ser montado em qualquer lugar. Porém, o FHS recomenda que montagens temporárias sejam feitas em `/mnt`

6. Quando `locate` é usado, os resultados são puxados de um banco de dados gerado por `updatedb`. No entanto, este banco de dados pode estar desatualizado, fazendo com que o `locate` mostre arquivos que não existem mais. Como fazer com que `locate` mostre apenas arquivos existentes em sua saída?

Adicione o parâmetro `-e` ou `--existing` a `locate`, como em `locate -e PATTERN`.

7. Encontre qualquer arquivo no diretório ou subdiretórios atuais até **2** níveis abaixo, **excluindo** sistemas de arquivos montados, que contenham o padrão **Status** ou **statute** em seus nomes.

Lembre-se de que para `-maxdepth` também devemos levar em conta o **diretório atual**, de forma que queremos **três níveis** (o atual, mais 2 níveis para baixo):
```
find . -maxdepth 3  -mount -iname "*statu*"
```

8. Limitando a pesquisa aos sistemas de arquivos `ext4`, encontre quaisquer arquivos sob `/mnt` que tenham no mínimo permissões de execução para o grupo, sejam legíveis para o usuário atual e tenham tido qualquer atributo alterado nas últimas 2 horas.

Use o parâmetro `-fstype` de `mount` para limitar a pesquisa a tipos específicos de sistemas de arquivos. Um arquivo legível pelo usuário atual teria ao menos `4` no primeiro dígito de permissões, e um executável pelo grupo teria ao menos `1` no segundo dígito. Como não estamos preocupados com as permissões de outros, podemos usar `0` no terceiro dígito. Use `-cmin N` para filtrar alterações recentes de atributos, lembrando que `N` é especificado em **minutos**. Assim:
```
find /mnt -fstype ext4 -perm -410 -cmin -120
```

9. Encontre arquivos vazios que foram criados há mais de **30 dias** e estão pelo menos **dois** níveis abaixo do diretório atual.

O parâmetro `-mindepth N` pode ser usado para limitar a pesquisa a pelo menos `N` níveis abaixo, mas é necessário incluir o diretório atual na contagem. Use `-empty` para procurar por arquivos vazios e `-mtime N` para ver a data e hora de modificação. Assim:
```
find . -empty -mtime +30 -mindepth 3
```

10. Considere que os usuários `carol` e `john` fazem parte do grupo `mkt`. Encontre no diretório pessoal de `john` quaisquer arquivos que também possam ser lidos por `carol`.

Considerando que os dois são membros do mesmo grupo, precisamos de pelo menos um `r` (`4`) nas permissões de grupo e não estamos preocupados com os outros. Assim:
```
find /home/john -perm -040
```

#### aula extra - uso do find com xargs

Já foi falado de `xargs` no tópico [103.4](#xargs)

Basicamente `xargs` pega a saída de um comando (geralmente com mais de uma saída) e executa outro comando com essa saída.

Supondo que temos os arquivos `teste1`, `teste2` e `teste3`, e se executarmos um `find` para encontrá-los:
```
$ find ./ -name "teste[0-9]"
./teste2
./teste1
./teste3
```

Se quisermos executar um `ls -l` em cada arquivo encotrado, teremos que usar o `xargs` (aqui poderia usar `rm`, `tar`, etc):
```
$ find ./ -name "teste*" | xargs ls -l
-rw-rw-r-- 1 rodrigo rodrigo  0 Mar  9 09:48 ./teste1
-rw-rw-r-- 1 rodrigo rodrigo  0 Mar  9 09:48 ./teste2
-rw-rw-r-- 1 rodrigo rodrigo  0 Mar  9 09:48 ./teste3
```

>[!NOTE]
>
>`find ./ -name "*"` é igual a `find ./`

É importante observar, que enquanto não temos arquivos com espaço em branco em seu nome, vai funcionar, mas se tivermos arquivos com espaço em branco em seu nome, teremos um erro. Crie os arquivos `teste novo 1`, `teste novo 2` e `teste novo 3`, e execute novamente `find ./ -name "teste*" | xargs ls -l`:
```
$ find ./ -name "teste*" | xargs ls -l
ls: cannot access './teste': No such file or directory
ls: cannot access 'novo': No such file or directory
ls: cannot access '3': No such file or directory
ls: cannot access './teste': No such file or directory
ls: cannot access 'novo': No such file or directory
ls: cannot access '1': No such file or directory
ls: cannot access './teste': No such file or directory
ls: cannot access 'novo': No such file or directory
ls: cannot access '2': No such file or directory
-rw-rw-r-- 1 rodrigo rodrigo 0 Mar 8 08:14 ./teste1
-rw-rw-r-- 1 rodrigo rodrigo 0 Mar  8 11:48 ./teste2
-rw-rw-r-- 1 rodrigo rodrigo 0 Mar  8 11:48 ./teste3
```

Repare que separou `teste`, `novo` e `1` e nos demais. Isso ocorre devido ao `xargs` delimitar o fim de sua leitura da entrada padrão, delimitando por espaços em branco (**blanks**) ou novas linhas (**newlines**), vide *DESCRIPTION* do `man` do `xargs`

Para em vez de considerar espaços em branco e quebra de linha, usamos a opção `-0` ou `-null` para que o xargs considere caracteres `null`. Entretanto ainda não será suficiente, pois se observarmos a saída do `find` com o `cat -A`, veremos que por padrão, no linux o final da linha termina com `$` (devido ao padrão de codificação do Linux):
```
$ find ./ -name "teste*" | cat -A
./teste novo 3$
./teste2$
./teste novo 1$
./teste1$
./teste novo 2$
./teste3$
```

Logo, teremos que trocar `$` por um `null`. É importante observar que a saída padrão do comando `find` é `-print` (quando usa o `find`, implicitamente está usando `-print`, logo tanto faz colocar `-print` ou não). Teremos que usar `-print0` para trocar a quebra de linha ser `null`
```
$ find ./ -name "teste*" -print0 | cat -A
./teste novo 3^@./teste2^@./teste novo 1^@./teste1^@./teste novo 2^@./teste3^@
```

Assim, dessa forma, utilizando `-print0` no comando `find`, é possível usar o `xargs` com a opção `-0` ou `--null`
```
$ find ./ -name "teste*" -print0 | xargs -0 ls -l
-rw-rw-r-- 1 rodrigo rodrigo 0 Mar 8 08:14  ./teste1
-rw-rw-r-- 1 rodrigo rodrigo 0 Mar  8 11:48  ./teste2
-rw-rw-r-- 1 rodrigo rodrigo 0 Mar  8 11:48  ./teste3
-rw-rw-r-- 1 rodrigo rodrigo 0 Mar 8 08:11 './teste novo 1'
-rw-rw-r-- 1 rodrigo rodrigo 0 Mar 8 08:11 './teste novo 2'
-rw-rw-r-- 1 rodrigo rodrigo 0 Mar 8 08:11 './teste novo 3'
```

>[!NOTE]
>
>`^@` indica que termina com caracter `null`

---

## 102-500 - Parte 2 da LPI

### 105.1 Personalizar e trabalhar no ambiente shell

Relembrando:
- `env` ou `printenv`: imprime uma lista de todas as variáveis de ambiente

- `printenv` ainda pode ser usado de forma semelhante ao comando `echo`:<br>

    $ echo $PWD
    /home/user2
    $ printenv PWD
    /home/user2
Note, entretanto, que com `printenv` o nome da variável não é precedido por `$`.

- `echo $TESTE`: lê o valor da variável TESTE
- `TESTE=valor1`: define um valor para a variável TESTE
- `env | grep TESTE`: não encontra nada da variável TESTE pois ela não foi exportada, está localmente apenas
- `set | grep TESTE`: mostra tanto as locais de ambiente, como as exportadas de usuário.

>[!NOTE]
>
>Para remover variáveis definidas (locais ou globais), usamos o comando  `unset`:

    $ echo $reptile
    tortoise
    $ unset reptile
    $ echo $reptile
    $

>[!NOTE]
>
>`unset` deve ser seguido somente pelo nome da variável (não precedido pelo símbolo `$`)

Se tivermos um script que lê essa variável TESTE, ao executá-lo ele não irá ler, pois quando é executado um script ele cria abre em uma nova sessão do shell/bash (processo filho do shell atual), logo essa variável teria que estar exportada.

É possível contornar isso com o comando **source**. Ele faz com que seja executado no mesmo shell da sessão atual, dessa forma retornando o valor de TESTE.

Outra forma é utilizar o ponto (.): `. script.sh` (faz rodar/executar localmente o script, sem chamar outra sessão de bash) (**NÃO** confundir com `./script.sh`)

Para criarmos variáveis imutáveis, basta a deixarmos como **readonly** (somente leitura).<br>
Ex. `readonly reptile=tortoise`<br>
Ou transformá-las depois de criá-las:<br>

    reptile=tortoise
    readonly reptile

Agora, se tentarmos alterar o valor de  `reptile`, o Bash se recusará:

    $ reptile=lizard
    -bash: distro: readonly variable

>[!NOTE]
>
>Para listar todas as variáveis somente leitura da sessão atual, digite `readonly` ou `readonly -p` no terminal

Para que uma variável local do shell se torne uma variável de ambiente, usamos o comando  `export`:

    $ export reptile

Com  `export reptile`, transformamos nossa variável local em uma variável de ambiente para que os shells filhos possam reconhecê-la e usá-la:

    $ bash
    $ echo $reptile
    tortoise

Da mesma maneira,  `export`  pode ser usado para definir e exportar uma variável de uma só vez:

    $ export amphibian=frog

Agora podemos abrir uma nova instância do Bash e referenciar com sucesso a nova variável:

    $ bash
    $ echo $amphibian
    frog

>[!NOTE]
>
>Com `export -n <VARIABLE-NAME>`, a variável será novamente transformada em variável local do shell.

- `export` ou `export -p`: lista todas as variáveis de ambiente existentes. (`declare -x` é equivalente a `export`)

Comando `alias`: cria alias para os comandos (sinônimos de comandos)

`alias dt="date +%H:%M"`: cria um alias chamado **dt** que vai executar o comando date mostrando apenas hora e minuto (se deslogar, perde a configuração, é apenas temporário)

Se digitar somente `alias`, é mostrado os alias cadastrados no bash atual.

- `unalias alias_criado`: remove o alias criado

Podemos escapar um alias com  `\`:

    $ alias where?='echo $PWD'
    $ where?
    /home/user2
    $ \where?
    -bash: where?: command not found

O escape de um alias é útil quando um alias tem o mesmo nome de um comando regular. Nesse caso, o alias tem precedência sobre o comando original, que, no entanto, ainda pode ser acessado escapando-se o alias.

Da mesma forma, podemos colocar um alias dentro de outro alias:

    $ where?
    /home/user2
    $ alias my_home=where?
    $ my_home
    /home/user2

Além disso, também é possível colocar uma função dentro de um alias, como será demonstrado mais adiante.

#### Expansão e avaliação de aspas em aliases

Ao se usar aspas com variáveis de ambiente, as aspas simples tornam a **expansão dinâmica**:

    $ alias where?='echo $PWD'
    $ where?
    /home/user2
    $ cd Music
    $ where?
    /home/user2/Music

No entanto, com aspas duplas, a expansão é feita **estaticamente**:

    $ alias where?="echo $PWD"
    $ where?
    /home/user2
    $ cd Music
    $ where?
    /home/user2

#### Persistência de aliases: scripts de inicialização

Como no caso das variáveis, para que nossos aliases se tornem persistentes devemos colocá-los em scripts de inicialização que são originados quando o sistema é iniciado. Como já sabemos, um bom arquivo para os usuários colocarem seus aliases pessoais é  `~/.bashrc`. Já deve haver alguns aliases por lá (a maioria deles comentados e prontos para uso, bastando remover o  `#`  inicial):

    $ grep alias .bashrc
    # enable color support of ls and also add handy aliases
        alias ls='ls --color=auto'
        #alias dir='dir --color=
        #alias vdir='vdir --color=
        #alias grep='grep --color=
        #alias fgrep='fgrep --color'
        #alias egrep='egrep --color=
    # some more ls aliases
    #ll='ls -al'
    #alias la='ls -A'
    #alias l='ls -CF'
    # ~/.bash_aliases, instead of adding them here directly.
    if [ -f ~/.bash_aliases ]; then
       . ~/.bash_aliases

Como podemos ver nas últimas três linhas, é possível ter nosso próprio arquivo dedicado aos aliases — `~/.bash_aliases` — para o  `.bashrc`  abrir e executar a cada inicialização do sistema. Ao escolher essa opção, criamos e preenchemos esse arquivo:

    ###########
    # .bash_aliases:
    # a file to be populated by the user's personal aliases (and sourced by ~/.bashrc).
    ###########
    alias git_info='which git;git --version'
    alias greet='echo Hello world!'
    alias ll='ls -al'
    alias where?='echo $PWD

**function**: usado para criar uma rotina de comandos.

Ex. Criando uma função e a chamando no final<br> 
```
$ function funcao1 {
>    date;
>   uptime;
>    uname -a
>    echo "Fim funcao";
>}

$ funcao1
```
Para visualizar a função é só digitar `set`

>[!NOTE]
>
>É possível começar uma função digitando tudo em uma linha ou omitindo a palavra `function`. Ex. `funcao3 () {date; uptime; }`

Como no caso das variáveis e aliases, se quisermos que as funções sejam persistentes durante as reinicializações do sistema, temos de colocá-las em scripts de inicialização do shell, como  `/etc/bash.bashrc`  (global) ou  `~/.bashrc`  (local).

>[!WARNING]
>
>Depois de adicionar aliases ou funções para qualquer arquivo de script de inicialização, é preciso executar  `.`  ou  `source`  nesses arquivos para que as alterações tenham efeito (caso você não queira fazer logout e login novamente ou reinicializar o sistema).

#### Variáveis integradas especiais do Bash

O  _Bourne Again Shell_  vem com um conjunto de variáveis especiais que são particularmente úteis para funções e scripts. Elas são especiais porque só podem ser referenciadas — e não atribuídas. Eis uma lista das mais relevantes:

- `$?`: a referência desta variável se expande para o resultado do último comando executado. Um valor de  `0`  significa sucesso:

    $ ps aux | grep bash
    user2      420  0.0  0.4  21156  5012 pts/0    Ss   17:10   0:00 -bash
    user2      640  0.0  0.0  12784   936 pts/0    S+   18:04   0:00 grep bash
    $ echo $?
    0

Um valor diferente de  `0`  significa erro:

    user1@debian:~$ ps aux |rep bash
    -bash: rep: command not found
    user1@debian:~$ echo $?
    127

- `$$`: expande-se para o PID do shell (ID do processo):

    $ ps aux | grep bash
    user2      420  0.0  0.4  21156  5012 pts/0    Ss   17:10   0:00 -bash
    user2      640  0.0  0.0  12784   936 pts/0    S+   18:04   0:00 grep bash
    $ echo $$
    420

- `$!`: expande-se para o PID do último trabalho em segundo plano:

    $ ps aux | grep bash &
    [1] 663
    $ user2      420  0.0  0.4  21156  5012 pts/0    Ss+  17:10   0:00 -bash
    user2      663  0.0  0.0  12784   972 pts/0    S    18:08   0:00 grep bash
    ^C
    [1]+  Done                   ps aux | grep bash
    $ echo $!
    663

>[NOTE]
>
>Lembre-se, o e comercial (`&`) é usado para iniciar processos em segundo plano.

#### Parâmetros posicionais  `$0`  a  `$9`

Expandem-se para os parâmetros ou argumentos que estão sendo passados para a função (alias ou script) — `$0`  se expande para o nome do script ou shell.

Um _parâmetro posicional_ é um parâmetro denotado por um ou mais dígitos diferentes do dígito único `0`. Por exemplo, a variável `$1` corresponde ao primeiro argumento dado ao script (parâmetro posicional um), `$2` corresponde ao segundo argumento e assim por diante. Se a posição de um parâmetro for maior que nove, ele deve ser referenciado com chaves, como em `${10}`, `${11}` etc.

Vamos criar uma função para demonstrar os parâmetros posicionais — note  `PS2`  (`>`) indicando novas linhas após as quebras de linha:

    $ special_vars() {
    > echo $0
    > echo $1
    > echo $2
    > echo $3
    }

Agora, vamos invocar a função (`special_vars`) passando três parâmetros para ela (`debian`,  `ubuntu`,  `zorin`):

    $ special_vars debian ubuntu zorin
    -bash
    debian
    ubuntu
    zorin

Tudo funcionou como esperado.

>[!WARNING]
>
>Embora seja tecnicamente possível passar parâmetros posicionais para aliases, não é lá muito prático, já que — com aliases — os parâmetros posicionais são sempre passados no final:

    $ alias great_editor='echo $1 is a great text editor'
    $ great_editor emacs
    is a great text editor emacs

#### Outras variáveis integradas especiais do Bash incluem:

- `$#`: expande-se para o número de argumentos passados para o comando.
- `$@`,  `$*`: expandem-se para os argumentos passados para o comando.
-`$_`:  expande-se para o último parâmetro ou o nome do script (dentre outras coisas; consulte  `man bash`  para saber mais!):

Para configuração/customização do ambiente shell, usamos os seguintes arquivos:
- `/etc/profile`: usado para quando um usuário faz o procedimento de login, seja por interface gráfica ou por terminal.
- `/etc/bash.bashrc`: aplicado quando se abre uma nova sessão de bash/shell (sempre que ver `algo.bashrc`, está ligado a um novo shell/bash e `algo.profile` é um novo login)

Por exemplo, caso adicionar uma variável no final do arquivo **/etc/profile**, chamada **ETCPROFILE=Valor1** e tentarmos com o **echo** ver o valor dessa variável, não será retornado nada. No entanto se for mudado para qualquer outro terminal (com CTRL+ALT+F1) e efetuar o login, e exibir a variável com o comando **echo**, a variável aparecerá. 
Isso deixa claro que **profile** está ligado com login realmente, no caso quando qualquer usuário fizer login.

Ainda no **/etc/profile** que é possível incluir um alias, uma função, para que seja comum a todos que se logarem no sistema.

É possível notar que ao se fazer o mesmo teste, agora com **/etc/bash.bashrc**, é possível perceber que a variável apenas irá aparecer quando for aberto um novo shell (e **NÃO** no shell atual) ou um novo login, que automaticamente irá abrir um novo shell.

Dentro de **/etc/profile.d/** há scripts que são carregados ao fazer login. Lembrando que o que foi visto é de definição geral, para todos os usuários.

Para configurações individuais de login (correspondente ao **/etc/profile**), geralmente em **/home** de cada usuário, temos os arquivos, nessa ordem, e logo que um é encontrado e executado, os outros são ignorados:
- `~/.bash_profile`
- `~/.bash_login` (caso não exista `~/.bash_profile`)
- `~/.profile` (mais comum)

Já o correspondente ao **/etc/bash.bashrc**, temos o (nova sessão, novo shell):
- **~/.bashrc**

Dentro do **/home** do usuário há ainda um arquivo chamado **.bash_logout** que é executado ao fazer logout do usuário.

- `~/.bash_logout`: se existir, este arquivo específico do Bash faz algumas operações de limpeza ao sair do shell. Isso pode ser conveniente em certos casos, como as sessões remotas.

Em **/etc/inputrc** temos a opção de editar as definições de input do terminal. Por exemplo, o que fará a combinação de Ctrl + alguma tecla específica, como limpar tela, e etc.

>[!WARNING]
>
>Lembre-se, devido à ordem em que os arquivos são executados, os arquivos **locais** têm precedência sobre os **globais**.

Em **/etc/skel** (de esqueleto): toda vez que criar um usuário, a base de arquivos básicos do usuário será pega daqui, arquivos esses que irão fazer parte do usuário. (será pego desse "esqueleto" de arquivos).<br>
Se criarmos um arquivo qualquer, como **touch teste-skel**, quando criarmos um novo usuário, esse arquivo ficará disponível no **/home** do novo usuário. Isso se torna interessante quando é necessário colocar alguma configuração específica para todo usuário durante sua criação.

Principais Variáveis de Ambiente
É importante conhecer a função de algumas variáveis de ambiente existentes no sistema, as principais são:

- **DISPLAY**: Indica às aplicações gráficas onde as janelas deverão ser exibidas. Será estudado no Tópico 106
- **HISTFILE**: Arquivo do histórico de comandos
- **HISTFILESIZE**: Quantidade de linhas/comandos armazenados no arquivo de histórico
- **HOME**: Indica o diretório do usuário atual
- **LANG**: Definição do idioma
- **LOGNAME** e **USER**: Nome do usuário atual
- **PATH**: Diretórios em que o Linux irá procurar por arquivos executáveis
- **PS1**: Aparência do prompt do shell.
- **PWD**: Diretório atual
- **OLDPWD**: Diretório anterior

Outro comando interessante e que alguns alunos já reportaram ter caído nos exames é o **chsh**.

O **chsh** serve simplesmente para alterar o shell utilizado pelo usuário. Por exemplo:
```
1.  $ chsh
2.  Senha:
3.  Mudando o shell de login para ricardo
4.  Informe o novo valor ou pressione ENTER para aceitar o padrão
5.    Shell de Login  [/bin/sh]:  /bin/bash
```

Ainda sobre terminais, podemos dizer se estiver usando uma interface gráfica, muito provavelmente estará em uso de algum emulador de terminal na GUI, ou um shell **pts**, como gnome-terminal ou konsole (são mais ricos em recursos e fáceis de usar).<br>
Agora se estiver lidando com console do sistema, ou tty, trata-se de um terminal baseado em texto.<br>
Pode-se alternar, como já vimos, com as teclas Ctrl+Alt+F1-F6, sendo o F7 normalmente a sssão que leva à interface gráfica.

>[!NOTE]
>
>**tty** significa teletypewritter (teletipo); **pts** é a abreviação de pseudo terminal slave (pseudo terminal escravo). Para saber mais: **man tty** e **man pts**

#### Lançando shells com o bash
Após fazer o login, digite **bash** em um terminal para abrir um novo shell. Tecnicamente, este shell é um processo filho do shell atual.

Ao iniciar o processo filho bash, podemos especificar diversas opções para definir que tipo de shell queremos iniciar. Eis algumas opções importantes de invocação no bash:

- **bash -l** ou **bash --login**: invoca um shell de login.
- **bash -i**: invoca um shell interativo.
- **bash --noprofile**: com shells de login, ignora o arquivo de inicialização do sistema /etc/profile e os arquivos de inicialização em nível de usuário ~/.bash_profile, ~/.bash_login e ~/.profile.
- **bash --norc**: com shells interativos, ignora tanto o arquivo de inicialização do sistema /etc/bash.bashrc quanto o arquivo de inicialização em nível de usuário ~/.bashrc.
- **bash --rcfile** <file>: com shells interativos, considera <file> como arquivo de inicialização, ignorando os arquivos de inicialização do sistema /etc/bash.bashrc e em nível de usuário ~/.bashrc

#### #### Iniciando shells com  `su`  e  `sudo`

- `su`: muda o ID de user ou o torna superusuário
- `su - user2`, `su -l user2` ou `su --login user2`: iniciam um shell de login interativo com **user2**
- `su user2`: inicia um shell sem login interativo como **user2**
- `su - root` ou `su -`: inicia um shell de login interativo como **root**
- `su root` ou `su` inicia um shell interativo sem login como `root`

`sudo`: executa comandos como outro usuário (incluindo o superusuário). Como este comando é usado principalmente para obter privilégios de root temporariamente, o usuário que o emprega deve estar no arquivo  `sudoers`. Para adicionar usuários a  `sudoers`, precisamos nos tornar  `root`  e então executar:

    # usermod -aG sudo user2

Assim como o  `su`, o  `sudo`  permite invocar shells de login e sem login:
-   `sudo su - user2`,  `sudo su -l user2`  ou  `sudo su --login user2`  iniciam um shell de login interativo como  `user2`.   
-   `sudo su user2`  inicia um shell sem login interativo como  `user2`.
-   `sudo -u user2 -s`  inicia um shell sem login interativo como  `user2`.
-   `sudo su - root`  ou  `sudo su -`  inicia um shell de login interativo como  `root`.
-   `sudo -i`  inicia um shell de login interativo como  `root`.
-   `sudo -i <algum_comando>`  inicia um shell de login interativo como  `root`, executa o comando e retorna ao usuário original.
-   `sudo su root`  ou  `sudo su`  inicia um shell sem login interativo como  `root`.
-   `sudo -s`  ou  `sudo -u root -s`  iniciam um shell sem login como  `root`.

Ao usar `su` ou `sudo`, é importante considerar o contexto particular antes de iniciar um novo shell: Precisamos ou não do ambiente do usuário de destino? Se a resposta for sim, usaríamos as opções que invocam shells de login; se não, as que invocam shells sem login.

- `echo $0`: mostra qual tipo de shell está sendo usado no momento

#### Ver a quantidade de shells

`ps aux | grep bash`: supondo a seguinte saída<br>

    user2@debian:~$ **ps aux | grep bash**
    user2       5270  0.1  0.1  25532  5664 pts/0    Ss   23:03   0:00 bash
    user2       5411  0.3  0.1  25608  5268 tty1     S+   23:03   0:00 -bash
    user2       5452  0.0  0.0  16760   940 pts/0    S+   23:04   0:00 grep --color=auto bash
    
A usuária `user2` em `debian` se logou em uma sessão GUI (ou X Window System) e abriu _gnome-terminal_, depois pressionou Ctrl+Alt+F1 para entrar em uma sessão de terminal `tty`. Finalmente, ela retornou à sessão GUI pressionando Ctrl+Alt+F7 e digitou o comando `ps aux | grep bash`. Assim, a saída mostra um shell sem login interativo por meio do emulador de terminal (`pts/0`) e um shell de login interativo por meio do terminal baseado em texto (`tty1`). Note também como o último campo de cada linha (o comando) é `bash` para o primeiro e `-bash` para o último.

- `-bash`  ou  `-su`: Interativo de login
- `bash`  or  `/bin/bash`: Interativo sem login
- `<nome_do_script>`: Não-interativo sem login (scripts)

#### Variáveis

Pode conter letras (`a-z, A-Z`), números (`0-9`) e sublinhados (`_`). E não deve começar com um número para não confundir o Bash. Não deve conter espaços (nem mesmo entre aspas), por convenção, os sublinhados são usados no lugar dos espaços.

No que diz respeito à referência ou valor das variáveis, também é importante considerar uma série de regras. As variáveis podem conter quaisquer caracteres alfanuméricos (`a-z`,`A-Z`,`0-9`), além da maioria dos outros caracteres (`?`,`!`,`*`,`.`,`/`, etc.). Os valores das variáveis devem ser postos entre aspas se contiverem espaços simples.

Os valores das variáveis também devem ser postos entre aspas se contiverem caracteres como os usados para redirecionamento/canalização (`<`,`>`) ou o símbolo de barra vertical (`|`). A única coisa que o comando a seguir faz é criar um arquivo vazio chamado  `zorin`:

    $ distro=>zorin
    $ echo $distro
    
    $ ls zorin
    zorin

Mas quando usamos as aspas, a coisa funciona:

    $ distro=">zorin"
    $ echo $distro
    >zorin

No entanto, aspas simples e duplas nem sempre são intercambiáveis. Dependendo do que estamos fazendo com uma variável (atribuindo ou referenciando), o uso de uma ou de outra tem implicações e produzirá resultados diferentes. No contexto da atribuição de variáveis, as **aspas simples** consideram  _literalmente_  todos os caracteres do valor da variável, enquanto as **aspas duplas** permitem a substituição de variáveis:

    $ lizard=uromastyx
    $ animal='My $lizard'
    $ echo $animal
    My $lizard
    $ animal="My $lizard"
    $ echo $animal
    My uromastyx

Por outro lado, ao referenciar uma variável cujo valor inclui alguns espaços iniciais (ou extras) — às vezes combinados com asteriscos — é obrigatório usar aspas duplas após o comando  `echo`  para evitar  _divisão de campos_  e  _expansão de nome de caminho_:

    $ lizard="   genus   |   uromastyx"
    $ echo $lizard
    genus | uromastyx
    $ echo "$lizard"
       genus   |   uromastyx

Se a referência da variável contiver um ponto de exclamação no final, este deve ser o último caractere da string (caso contrário, o Bash pensará que estamos nos referindo a um evento de  `history`):

    $ distro=zorin.?/!os
    -bash: !os: event not found
    $ distro=zorin.?/!
    $ echo $distro
    zorin.?/!

Todas as barras invertidas devem ser escapadas com outra barra invertida. Aliás, se uma barra invertida for o último caractere na string e não o escaparmos, o Bash interpretará que queremos uma quebra de linha e criará uma nova linha:

    $ distro=zorinos\
    >
    $ distro=zorinos\\
    $ echo $distro
    zorinos\

- `env -i bash`: inicia um bash removendo a maioria das variáveis (além de funções e aliases)

    $ env -i bash

Agora, a maioria das nossas variáveis de ambiente se foi:

    $ echo $USER
    $

Restam apenas algumas:

    $ env
    LS_COLORS=
    PWD=/home/user2
    SHLVL=1
    _=/usr/bin/printenv

`PS1`

Essa variável armazena o valor do prompt do Bash. No trecho de código a seguir (igualmente de  `/etc/profile`), a declaração  `if`  testa a identidade do usuário e lhe atribui um prompt bastante personalizado (  `#`  para  `root`  ou  `$`  para usuários regulares):

    if [ "`id -u`" -eq 0 ]; then
      PS1='# '
    else
      PS1='$ '
    fi

>[!NOTE]
>
>O  `id`  de  `root`  é  `0`. Entre como  `root`  e teste você mesmo com  `id -u`.

Eis algumas outras variáveis de prompt:
- `PS2`: normalmente definido como  `>`  e usado como prompt de continuação para comandos longos de muitas linhas.
- `PS3`: usado como prompt para o comando  `select`.
- `PS4`: normalmente definido como  `+`  e usado para depuração.
- `SHELL`: esta variável armazena o caminho absoluto do shell atual:

    $ echo $SHELL
    /bin/bash

- `USER`: armazena o nome do usuário atual:

    $ echo $USER
    carol

- `echo $DISPLAY` retorna `reptilium:0:2`, que quer dizer: a máquina **reptilium** tem um servidor X rodando e estamos usando a **segunda** tela do sistema

### 105.2 Editar e escrever scripts simples

Ao criar um `script.sh` (script = sequencia de comandos) comum, como por exemplo:

    clear
    echo "===== Primeiro Script======"
    echo ""
    uptime
    free -m
    echo ""
    echo "Fim Script"

Podemos executá-lo usando apenas o comando source ou ponto (.)<br>
Quando um script é executado, os comandos nele contidos não são executados diretamente na sessão atual, mas sim por um novo processo do Bash, chamado _sub-shell_. Isso evita que o script sobrescreva as variáveis de ambiente da sessão atual e faça modificações indesejadas nela. Se o objetivo é executar o conteúdo do script na sessão atual do shell, ele deve ser executado com `source script.sh` ou `. script.sh` (note que há um espaço entre o ponto e o nome do script).

    $ source script.sh
    $ . script.sh

Isso inclusive faz com que seja executado no bash atual, sem mudar para um processo filho.

Se tentar executar usando `./script.sh` ou o caminho absoluto dele, vai dar erro de permissão, pois o arquivo não tem permissão de execução. Precisaria executar `chmod u+x script`, para dar permissão de execução para o arquivo (nesse caso, permissão para o usuário dono do arquivo).

- `exec script.sh`: executa o script e fecha a sessão atual (nem dá pra ver o resultado, pois já fecha em seguida)
- `bash script.sh`: também executa o script sem o bit de execução.

>[!WARNING]
>
>Um script que executa ações restritas pode ter sua permissão SUID ativada e, portanto, os usuários comuns também podem executar o script com privilégios de root. Nesse caso, é muito importante garantir que nenhum usuário além do root tenha permissão para escrever no arquivo. Caso contrário, um usuário comum poderá modificar o arquivo para realizar operações arbitrárias e potencialmente prejudiciais.

Caso queira direcionar algum outro interpretador, usa-se o she-bang, que no caso é indicar no começo do arquivo: `#!/bin/bash`

>[!TIP]
>
>O Bash chama qualquer comando indicado após o `#!` como interpretador do arquivo de script. Pode ser útil, por exemplo, empregar o shebang para outras linguagens de script, como _Python_ (`#!/usr/bin/python`), _Perl_ (`#!/usr/bin/perl`) ou _awk_ (`#!/usr/bin/awk`).

#### Parâmetro em shell script

- `$*`: imprime todos os argumentos passados para o script.
- `$@`: todos os argumentos passados para o script. Se usado com aspas duplas, como em  `"$@"`, todos os argumentos serão colocados entre aspas duplas.
- `$0`: imprime o nome do arquivo que está sendo executado
- `$#`: imprime a quantidade de parâmetros utilizados
- `$1`, `$2`, etc: imprime os parâmetros sequencialmente conforme entrada
- `$!`: PID do último programa executado.
- `$$`: PID do shell atual.
- `$?`: código de status de saída numérico do último comando concluído. Para processos POSIX padrão, um valor numérico de  `0`  indica que o último comando foi executado com sucesso, o que também se aplica a scripts do shell.
```
echo "O meu script se chama $0"
echo ""
echo "Esse script recebeu $# parâmetros, que são, $1 e $2"
```

#### Receber uma variável com read

É possível, ao usuário digitar, receber um valor de variável durante a execução de um script, usando o read:

```
echo -n "Digite um valor: "
read VAR1
echo "O valor digitado foi $VAR1"
```
- `echo -n`: não quebra linha

echo "Do you want to continue (y/n)?"
read ANSWER

O valor retornado será armazenado na variável  `ANSWER`. Se o nome da variável não for fornecido, o nome da variável  `REPLY`  será usado por padrão. Também é possível usar o comando  `read`  para ler mais de uma variável simultaneamente:

    echo "Type your first name and last name:"
    read NAME SURNAME

Neste caso, cada termo separado por espaços será atribuído às variáveis  `NAME`  e  `SURNAME`  respectivamente. Se o número de termos dados for maior que o número de variáveis, os termos excedentes serão armazenados na última variável. O próprio  `read`  pode exibir a mensagem para o usuário com a opção  `-p`, tornando o comando  `echo`  redundante nesse caso:

    read -p "Type your first name and last name:" NAME SURNAME

#### Declarando variáveis

A declaração de variáveis **NÃO** usa cifrão (`$`), já no uso da variável, **TEM QUE USAR**. Exemplo:<br>

    echo ""
    VAR1=`cat /etc/passwd|wc -l`
    VAR2=$(date +%H)
    echo ""
    echo "O arquivo /etc/passwd possui $VAR1 linhas. A hora atual é $VAR2."

*Podemos colocar execução de comandos utilizando crase (\`) ou com a sitaxe `$()`
**A notação de crase é conhecida como **backtick**

##### Comprimento de uma variável
O comprimento de uma variável, ou seja, a quantidade de caracteres que ela contém, é retornado acrescentando-se um hash  `#`  antes do nome da variável. Esse recurso, no entanto, requer o uso da sintaxe das chaves para indicar a variável:

    $ OS=$(uname -o)
    $ echo $OS
    GNU/Linux
    $ echo ${#OS}
    9

##### Arrays (matriz unidimensionais)

O Bash também apresenta variáveis de matriz (array) unidimensionais, de forma que um conjunto de elementos relacionados pode ser armazenado com um único nome de variável. Cada elemento de uma matriz possui um índice numérico, que deve ser usado para escrever e ler valores no elemento correspondente. Ao contrário das variáveis comuns, as matrizes devem ser declaradas com o comando interno do Bash  `declare`. Por exemplo, para declarar uma variável chamada  `SIZES`  como uma matriz:

    $ declare -a SIZES

As matrizes também podem ser declaradas implicitamente quando preenchidas a partir de uma lista predefinida de itens, usando a notação de parênteses:

    $ SIZES=( 1048576 1073741824 )
    $ set | grep SIZES
    SIZES=([0]="1048576"   [1]="1073741824")

No exemplo, os dois grandes valores inteiros foram armazenados na matriz  `SIZES`. Os elementos da matriz devem ser referenciados usando chaves e colchetes, caso contrário o Bash não alterará nem exibirá o elemento corretamente. Como os índices da matriz começam em 0, o conteúdo do primeiro elemento está em  `${SIZES[0]}`, o segundo em  `${SIZES[1]}`  e assim por diante:

    $ echo ${SIZES[0]}
    1048576
    $ echo ${SIZES[1]}
    1073741824

Diferente da leitura, a alteração do conteúdo de um elemento da matriz é realizada sem as chaves (por exemplo,  `SIZES[0]=1048576`). Como no caso das variáveis comuns, o comprimento de um elemento em uma matriz é retornado com o caractere hash (por exemplo,  `${#SIZES[0]}`  para o comprimento do primeiro elemento da matriz  `SIZES`). O número total de elementos em uma matriz é retornado se  `@`  ou  `*`  forem usados como o índice:

    $ echo ${#SIZES[@]}
    2
    $ echo ${#SIZES[*]}
    2

As matrizes também podem ser declaradas usando-se, como elementos iniciais, a saída de um comando, por meio da substituição de comando. O exemplo a seguir mostra como criar uma matriz do Bash cujos elementos são os sistemas de arquivos suportados pelo sistema atual:

    $ FS=( $(cut -f 2 < /proc/filesystems) )

O comando  `cut -f 2 < /proc/filesystems`  exibe todos os sistemas de arquivos atualmente suportados pelo kernel em execução (listados na segunda coluna do arquivo  `/proc/filesystems`), de forma que a matriz  `FS`  agora contém um elemento para cada sistema de arquivos suportado. Qualquer conteúdo de texto pode ser usado para inicializar uma matriz, já que, por padrão, quaisquer termos delimitados por caracteres de  _espaço_,  _tabulação_  ou  _nova linha_  **se tornarão um elemento de matriz**.

>[!TIP]
>
>O Bash trata cada caractere do  `$IFS`  (_Input Field Separator_  ou separador de campos) de uma variável de ambiente como um delimitador. Para alterar o delimitador de campo apenas para caracteres de nova linha, por exemplo, a variável IFS deve ser redefinida com o comando  `IFS=$'\n'`.

#### Instruções condicionais (if e case)

Vejamos um exemplo:

    if [ -f /etc/bash.bashrc ]; then
	    .	/etc/bash.bashrc
	fi
ou

    if test -f /etc/bash.bashrc ; then
	    .	/etc/bash.bashrc
	fi
Ambas as instruções produzem o mesmo efeito. Para que a instrução aninhada no `if` execute, ela deve ser **verdadeira**, no caso o que estiver entre os colchetes, ou após a instrução `test`. <br>Nesse exemplo é testado se o arquivo `/etc/bash.bashrc` existe e é um arquivo regular.

- `-f`: testa se arquivo existe e é um arquivo regular;
- `-e`: testa apenas se arquivo existe;
- `-s`: verifica se o tamanho do arquivo é maior que 0 (zero)
- `-z`: verifica se o tamanho da string é zero (usado com variáveis)
- `-n`: verifica se o tamanho da string é diferente de zero (nonzero)

Vejamos outro exemplo

    if [ "`id -u`" -eq 0]; then
	    PS1='# '
	else
		PS1='$ '
	fi

Nesse caso verificar, por meio do comando `id -u`, se o retorno é igual a 0 (zero), caso seja, retorna `#`, senão `$`. No caso testa se o usuário é root. Lembrando que id 0 é do root. Lembrando também que podemos executar comandos com a crase e por meio do cifrão abrindo e fechando parênteses `$()`

O comando  `test`  avalia as expressões usando duas sintaxes diferentes: as expressões de teste podem ser dadas como um argumento para o comando  `test`  ou podem ser postas entre colchetes, caso em que o comando  `test`  é dado implicitamente. Assim, o teste para avaliar se  `/etc`  é um diretório válido pode ser escrito como  `test -d /etc`  ou como  `[ -d /etc]`:

    $ test -d /etc
    $ echo $?
    0
    $ [ -d /etc ]
    $ echo $?
    0

O comando `test` pode ser executado no terminal diretamente. Vejamos alguns exemplos:

- `test LPI1 = LPI1`: precisamo ver no **return code**. Basta executar `echo $?` (**0** é igual sucesso, **1** ou outro número informa que não é verdadeiro)
- `test LPI1 = LPI2`: return code será **1**
- `test -f /etc/profile`: testa se o arquivo `/etc/profile` existe. (**0** = existe, **1** = não existe)
- `test 10 -gt 20`: se 10 é maior que (**greater than**) 20 (retorna **1**, pois 10 não é maior que 20)

Supõe que a variável $VAR guarde um caminho para um arquivo ou diretório. Podemos ter as seguintes opções:

- `-a "$VAR"`: avalia se o caminho em  `VAR`  existe no sistema de arquivos e é um arquivo.
- `-b "$VAR"`: avalia se o caminho em  `VAR`  é um arquivo de bloco especial.
- `-c "$VAR"`: avalia se o caminho em  `VAR`  é um arquivo de caractere especial.
- `-d "$VAR"`: avalia se o caminho em  `VAR`  é um diretório.
- `-e "$VAR"`: avalia se o caminho em  `VAR`  existe no sistema de arquivos.
- `-f "$VAR"`: avalia se o caminho em  `VAR`  existe e é um arquivo regular.
- `-g "$VAR"`: avalia se o caminho em  `VAR`  tem permissão SGID.
- `-h "$VAR"`: avalia se o caminho em  `VAR`  é um link simbólico.
- `-L "$VAR"`: avalia se o caminho em  `VAR`  é um link simbólico (como  `-h`).
- `-k "$VAR"`: avalia se o caminho em  `VAR`  tem a permissão  _sticky bit_.
- `-p "$VAR"`: avalia se o caminho em  `VAR`  é um arquivo  _pipe_.
- `-r "$VAR"`: avalia se o caminho em  `VAR`  é legível pelo usuário atual.
- `-s "$VAR"`: avalia se o caminho em  `VAR`  existe e não está vazio.
- `-S "$VAR"`: avalia se o caminho em  `VAR`  é um arquivo de socket.
- `-t "$VAR"`: avalia se o caminho em  `VAR`  está aberto em um terminal.
- `-u "$VAR"`: avalia se o caminho em  `VAR`  tem permissão SUID.
- `-w "$VAR"`: avalia se o caminho em  `VAR`  é gravável pelo usuário atual.
- `-x "$VAR"`: avalia se o caminho em  `VAR`  é executável pelo usuário atual.
- `-O "$VAR"`: avalia se o caminho em  `VAR`  é de propriedade do usuário atual.
- `-G "$VAR"`: avalia se o caminho em  `VAR`  pertence ao grupo efetivo do usuário atual.
- `-N "$VAR"`: avalia se o caminho em  `VAR`  foi modificado desde o último acesso.
- `"$VAR1" -nt "$VAR2"`: avalia se o caminho em  `VAR1`  é mais recente que o caminho em  `VAR2`, de acordo com as datas de modificação respectivas.
- `"$VAR1" -ot "$VAR2"`: avalia se o caminho em  `VAR1`  é mais antigo que  `VAR2`.
- `"$VAR1" -ef "$VAR2"`: esta expressão avalia como True (Verdadeiro) se o caminho em  `VAR1`  é um link físico para  `VAR2`.

##### Também existem testes para variáveis de texto arbitrárias, descritos a seguir:

- `-z "$TXT"`: avalia se a variável  `TXT`  está vazia (tamanho zero).
- `-n "$TXT"`  ou  `test "$TXT"`: avalia se a variável  `TXT`  não está vazia.
- `"$TXT1" = "$TXT2"`  ou  `"$TXT1" == "$TXT2"`: avalia se  `TXT1`  e  `TXT2`  são iguais.
- `"$TXT1" != "$TXT2"`: avalia se  `TXT1`  e  `TXT2`  não são iguais.
- `"$TXT1" < "$TXT2"`: avalia se  `TXT1`  vem antes de  `TXT2`, em ordem alfabética.
- `"$TXT1" > "$TXT2"`: avalia se  `TXT1`  vem depois de  `TXT2`, em ordem alfabética.

- `$NUM1 -lt $NUM2`: avalia se  `NUM1`  é menor que  `NUM2`.
- `$NUM1 -gt $NUM2`: avalia se  `NUM1`  é maior que  `NUM2`.
- `$NUM1 -le $NUM2`: avalia se  `NUM1`  é menor ou igual a  `NUM2`.
- `$NUM1 -ge $NUM2`: avalia se  `NUM1`  é maior ou igual a  `NUM2`.
- `$NUM1 -eq $NUM2`: avalia se  `NUM1`  é igual a  `NUM2`.
- `$NUM1 -ne $NUM2`: avalia se  `NUM1`  não é igual a  `NUM2`.

Todos os testes podem receber os seguintes modificadores:

`! EXPR`

Avalia se a expressão  `EXPR`  é falsa.

`EXPR1 -a EXPR2`

Avalia se tanto  `EXPR1`  quanto  `EXPR2`  são verdadeiras.

`EXPR1 -o EXPR2`

Avalia se ao menos uma das duas expressões é verdadeira.



Outro exemplo interessante:<br>

    if [ "$BASH" ] && [ "$BASH" != "/bin/sh" ]; then
	    #executa rotina
	fi
No caso acima, verifica se a variável `$BASH` está declarada **e** se a variável `$BASH` é diferente de `/bin/sh`, então vai para a rotina.

Vejamos um exemplo que verifica se o diretório `/etc/profile.d` existe:<br>

    if [ -d /etc/profile.d ]; then
	    # executa rotina
	fi

Abaixo, outro exemplo um pouco mais complexo:

    if [ -z "${debian_chroot:-}"] && [ -r /etc/debian_chroot ]; then
	    debian_chroot=$(cat /etc/debian_chroot)
	fi
O `-z` significa se o tamanho (length) da string é zero e o `-r` quer dizer se o arquivo existe e se está com permissão de somente leitura.

##### Case
Exemplo1:<br>

    read VAR1
    case $VAR1 in
	    0)
		    echo "O valor digitado foi 0"
	    ;;
	    1|2|3|4|5)
		    echo "O valor digitado foi entre 1 e 5"
		    sleep 3
	    ;;
	    *)
		    echo "O valor digitado foi maior que 5"
	esac

Exemplo 2:<br>

    #!/bin/bash
    
    DISTRO=$1
    
    echo -n "Distribution $DISTRO uses "
    case "$DISTRO" in
    	debian | ubuntu | mint)
        echo -n "the DEB"
      ;;
    	centos | fedora | opensuse )
        echo -n "the RPM"
      ;;
    	*)
        echo -n "an unknown"
      ;;
    esac
    echo " package format."

Cada lista de padrões e comandos associados deve terminar com  `;;`,  `;&`, ou  `;;&`. O último padrão, um asterisco, será usado se não for encontrada uma correspondência para nenhum outro padrão anterior. A instrução  `esac`  (_case_  de trás pra frente) conclui a construção  `case`. Supondo que o script de amostra anterior se chame  `script.sh`  e seja executado com  `opensuse`  como primeiro argumento, a seguinte saída será gerada:

    $ ./script.sh opensuse
    Distribution opensuse uses the RPM package format.
>[!TIP]
>
>
> O Bash tem uma opção chamada `nocasematch` que ativa a correspondência de padrões sem distinção entre maiúsculas e minúsculas para a construção `case` e outros comandos condicionais. O comando interno `shopt` alterna os valores das configurações que controlam comportamentos opcionais do shell: `shopt -s` habilita (_set_) a opção fornecida e `shopt -u` desabilita (_unset_) a opção fornecida. Portanto, colocar `shopt -s nocasematch` antes da construção case permite encontrar padrões sem diferenciar maiúsculas de minúsculas. As opções modificadas por `shopt` afetarão apenas a sessão atual, de forma que as opções modificadas dentro de scripts em execução em um sub-shell — o que é a maneira padrão de executar um script — não afetarão as opções da sessão pai.

#### Loops

- `seq`: faz uma sequencia de acordo com o número que coloque.<br>
Ex.<br>
    $ seq 5
    1
    2
    3
    4
    5

- `expr`: faz conta aritmética<br>
Ex.<br>

    $ expr 1 + 2
    3

    $ expr 1 - 2
    -1

##### for

	read VAR1
    for i in 1 2 3 4 5
    do
	    j=`expr $i + $VAR1`
		echo "$i + $VAR1 = $j
	done

>[!TIP]
>
>O comando `expr` pode ser substituído por `$(())`, de forma que o exemplo anterior no laço `for` poderia ser reescrito como `j=$(( $i + $VAR1 ))`

>[!TIP]
>
>É possível escrever potenciação com o operador duplo asterisco (`**`). Ex.<br>

    $ echo $( (5**2 ) )
    25

Exemplo1:<br>

Usando o `seq`:

    read VAR1
    for i in `seq $1` # $1 = parâmetro 1
    do
	    j=`expr $i + $VAR1`
		echo "$i + $VAR1 = $j
		sleep 1
	done

Exemplo2:<br>

    #!/bin/bash
    
    SEQ=( 1 1 2 3 5 8 13 )
    
    for (( IDX = 0; IDX < ${#SEQ[*]}; IDX++ ))
    do
    	echo -n "${SEQ[$IDX]} is "
    	if [ $(( ${SEQ[$IDX]} % 2 )) -ne 0 ]
    	then
    		echo "odd."
    	else
    		echo "even."
      fi
    done

Este script gera exatamente a mesma saída do exemplo anterior. No entanto, em vez de usar a variável  `NUM`  para armazenar um item por vez, a variável  `IDX`  é empregada para rastrear o índice da matriz atual em ordem crescente, começando de 0 e continuando a adicionar enquanto esse número permanecer abaixo do número de itens na matriz  `SEQ`. O item em si é recuperado de sua posição na matriz com  `${SEQ[$IDX]}`.



##### while

    while [ $VAR1 -le $1 ] #enquanto o teste = Verdadeiro, faça...
    do
	    echo "O valor atual do \$VAR1 é: $VAR1"
	    VAR1=`expr $VAR1 + 1`
	    sleep 1
	done

##### until

    until [ $VAR1 = 0 ] #até que isso seja verdadeiro, faça...chegando no 0, não executa o looping
    do
	    echo "O valor atual do \$VAR1 é: $VAR1"
	    VAR1=`expr $VAR1 - 1`
	    sleep 1
	done

#### Execução sequencial de comandos

Ex. `cat teste | wc -l`: executa o primeiro comando e a saída do mesmo serve de entrada para o próximo comando, no caso `wc`.

Ex. `date ; ls -l ; teste2 ; echo Exemplo`: executa todos, mesmo que dê erro

Ex. `ls -ls teste && echo Exemplo`: só executa o segundo comando, se o primeiro der sucesso (caso exista o arquivo teste, senão seria erro, caso ele não exista - ou seja, o status de saída igual a `0`)

Ex. `ls -ls teste || echo Exemplo`: só executa o segundo comando, se o primeiro falhar. Executando o primeiro já encerra a execução.

Ex. `ls -ls teste || echo Exemplo || date`: é sequencial, na hora que chegar em um que executou com sucesso, ele para.

Exemplo de uso de `||`
Imagine uma checagem de um arquivo muito importante, caso ele desaparece, tenha qualquer problema, mudança de permissão, etc, avise o usuário administrador ou root sobre isso:

    ls -l arquivo_importante || mail -s "arquivo não existe mais" root < .
Se executar o comando acima e der sucesso, não faz nada. Mas se der erro, executa o segundo comando, no caso, enviar um email avisando que o arquivo não existe mais.

###$$ Saída do script (echo e printf)

Mesmo quando a finalidade de um script envolve apenas operações orientadas a arquivos, é importante exibir mensagens relacionadas ao progresso na saída padrão, para que o usuário seja informado sobre quaisquer problemas e possa, eventualmente, usar essas mensagens para gerar logs de operação.

O comando interno do Bash  `echo`  é comumente usado para exibir strings de texto simples, mas ele também oferece alguns recursos estendidos. Com a opção  `-e`, o comando  `echo`  é capaz de exibir caracteres especiais usando sequências de escape (uma sequência de barra invertida designando um caractere especial). Por exemplo:

    #!/bin/bash
    
    # Get the operating system's generic name
    OS=$(uname -o)
    
    # Get the amount of free memory in bytes
    FREE=$(( 1000 * `sed -nre '2s/[^[:digit:]]//gp' < /proc/meminfo` ))
    
    echo -e "Operating system:\t$OS"
    echo -e "Unallocated RAM:\t$(( $FREE / 1024**2 )) MB"

Embora o uso de aspas seja opcional ao se usar  `echo`  sem opções, é necessário adicioná-las ao incluir a opção  `-e`; caso contrário, os caracteres especiais podem não ser lidos corretamente. No script anterior, ambos os comandos  `echo`  usam o caractere de tabulação  `\t`  para alinhar o texto, resultando na seguinte saída:

    Operating system:       GNU/Linux
    Unallocated RAM:        1491 MB

O caractere de nova linha  `\n`  pode ser usado para separar as linhas da saída, de forma que exatamente a mesma saída é obtida combinando-se os dois comandos  `echo`  em um só:

    echo -e "Operating system:\t$OS\nUnallocated RAM:\t$(( $FREE / 1024**2 )) MB"

Embora adequado para exibir a maioria das mensagens de texto, o comando  `echo`  pode não ser o melhor para padrões de texto mais específicos. O comando interno do Bash  `printf`  oferece mais controle sobre a exibição das variáveis. O comando  `printf`  usa o primeiro argumento como formato da saída, onde os marcadores serão substituídos pelos argumentos seguintes na ordem em que aparecem na linha de comando. Assim, a mensagem do exemplo anterior poderia ser gerada com o seguinte comando  `printf`:

    printf "Operating system:\t%s\nUnallocated RAM:\t%d MB\n" $OS $(( $FREE / 1024**2 ))

O espaço reservado  `%s`  destina-se ao conteúdo de texto (será substituído pela variável  `$OS`) e o espaço reservado  `%d`  destina-se a números inteiros (será substituído pelo número resultante de megabytes livres na RAM). O  `printf`  não acrescenta um caractere de nova linha no final do texto, então o caractere de nova linha  `\n`  deve ser posto ao fim do padrão, se necessário. Todo o padrão deve ser interpretado como um único argumento e, portanto, deve ser posto entre aspas.

>[!TIP]
>
> O formato de substituição do espaço reservado realizada por  `printf`  pode ser personalizado com o mesmo formato usado pela função  `printf`  da linguagem de programação C. A referência completa para a função  `printf`  pode ser encontrada em sua página de manual, acessada com o comando  `man 3 printf`.

Com  `printf`, as variáveis são postas fora do padrão de texto, o que torna possível armazenar o padrão de texto em uma variável separada:

    MSG='Operating system:\t%s\nUnallocated RAM:\t%d MB\n'
    printf "$MSG" $OS $(( $FREE / 1024**2 ))

Este método é particularmente útil para exibir formatos de saída distintos, dependendo dos requisitos do usuário. Fica mais fácil, por exemplo, produzir um script que use um padrão de texto distinto se o usuário precisar de uma lista CSV (valores separados por vírgula) em vez de uma mensagem de saída padrão.
cho $TESTE`: lê o valor da variável TESTE
- `TESTE=valor1`: define um valor para a variável TESTE
- `env | grep TESTE`: não encontra nada da variável TESTE pois ela não foi exportada, está localmente apenas
- `set | grep TESTE`: mostra tanto as locais de ambiente, como as exportadas de usuário.

Se tivermos um script que lê essa variável TESTE, ao executá-lo ele não irá ler, pois quando é executado um script ele cria abre em uma nova sessão do shell/bash (processo filho do shell atual), logo essa variável teria que estar exportada.

É possível contornar isso com o comando **source**. Ele faz com que seja executado no mesmo shell da sessão atual, dessa forma retornando o valor de TESTE.

Outra forma é utilizar o ponto (.): `. script.sh` (faz rodar/executar localmente o script, sem chamar outra sessão de bash) (**NÃO** confundir com `./script.sh`)

Comando alias: cria alias para os comandos (sinônimos de comandos)

`alias dt="date +%H:%M"`: cria um alias chamado **dt** que vai executar o comando date mostrando apenas hora e minuto (se deslogar, perde a configuração, é apenas temporário)

Se digitar somente **alias**, é mostrado os alias cadastrados no bash atual.

**function**: usado para criar uma rotina de comandos.

Ex. Criando uma função e a chamando no final<br> 
```
$ function funcao1 {
>    date;
>   uptime;
>    uname -a
>    echo "Fim funcao";
>}

$ funcao1
```
Para visualizar a função é só digitar `set`

>[!NOTE]
>
>É possível começar uma função digitando tudo em uma linha ou omitindo a palavra `function`. Ex. `funcao3 () {date; uptime; }`

Para configuração/customização do ambiente shell, usamos os seguintes arquivos:
- `/etc/profile`: usado para quando um usuário faz o procedimento de login, seja por interface gráfica ou por terminal.
- `/etc/bash.bashrc`: aplicado quando se abre uma nova sessão de bash/shell (sempre que ver `algo.bashrc`, está ligado a um novo shell/bash e `algo.profile` é um novo login)

Por exemplo, caso adicionar uma variável no final do arquivo **/etc/profile**, chamada E**TCPROFILE=Valor1** e tentarmos com o **echo** ver o valor dessa variável, não será retornado nada. No entanto se for mudado para qualquer outro terminal (com CTRL+ALT+F1) e efetuar o login, e exibir a variável com o comando **echo**, a variável aparecerá. 
Isso deixa claro que **profile** está ligado com login realmente, no caso quando qualquer usuário fizer login.

Ainda no **/etc/profile** que é possível incluir um alias, uma função, para que seja comum a todos que se logarem no sistema.

É possível notar que ao se fazer o mesmo teste, agora com **/etc/bash.bashrc**, é possível perceber que a variável apenas irá aparecer quando for aberto um novo shell (e **NÃO** no shell atual) ou um novo login, que automaticamente irá abrir um novo shell.

Dentro de **/etc/profile.d/** há scripts que são carregados ao fazer login. Lembrando que o que foi visto é de definição geral, para todos os usuários.

Para configurações individuais de login (correspondente ao **/etc/profile**), geralmente em **/home** de cada usuário, temos os arquivos, nessa ordem, e logo que um é encontrado e executado, os outros são ignorados:
- `~/.bash_profile`
- `~/.bash_login` (caso não exista `~/.bash_profile`)
- `~/.profile` (mais comum)

Já o correspondente ao **/etc/bash.bashrc**, temos o (nova sessão, novo shell):
- **~/.bashrc**

Dentro do **/home** do usuário há ainda um arquivo chamado **.bash_logout** que é executado ao fazer logout do usuário.

- `~/.bash_logout`: se existir, este arquivo específico do Bash faz algumas operações de limpeza ao sair do shell. Isso pode ser conveniente em certos casos, como as sessões remotas.

Em **/etc/inputrc** temos a opção de editar as definições de input do terminal. Por exemplo, o que fará a combinação de Ctrl + alguma tecla específica, como limpar tela, e etc.

>[!WARNING]
>
>Lembre-se, devido à ordem em que os arquivos são executados, os arquivos **locais** têm precedência sobre os **globais**.

Em **/etc/skel** (de esqueleto): toda vez que criar um usuário, a base de arquivos básicos do usuário será pega daqui, arquivos esses que irão fazer parte do usuário. (será pego desse "esqueleto" de arquivos).<br>
Se criarmos um arquivo qualquer, como **touch teste-skel**, quando criarmos um novo usuário, esse arquivo ficará disponível no **/home** do novo usuário. Isso se torna interessante quando é necessário colocar alguma configuração específica para todo usuário durante sua criação.

Principais Variáveis de Ambiente
É importante conhecer a função de algumas variáveis de ambiente existentes no sistema, as principais são:

- **DISPLAY**: Indica às aplicações gráficas onde as janelas deverão ser exibidas. Será estudado no Tópico 106
- **HISTFILE**: Arquivo do histórico de comandos
- **HISTFILESIZE**: Quantidade de linhas/comandos armazenados no arquivo de histórico
- **HOME**: Indica o diretório do usuário atual
- **LANG**: Definição do idioma
- **LOGNAME** e **USER**: Nome do usuário atual
- **PATH**: Diretórios em que o Linux irá procurar por arquivos executáveis
- **PS1**: Aparência do prompt do shell.
- **PWD**: Diretório atual
- **OLDPWD**: Diretório anterior

Outro comando interessante e que alguns alunos já reportaram ter caído nos exames é o **chsh**.

O **chsh** serve simplesmente para alterar o shell utilizado pelo usuário. Por exemplo:
```
1.  $ chsh
2.  Senha:
3.  Mudando o shell de login para ricardo
4.  Informe o novo valor ou pressione ENTER para aceitar o padrão
5.    Shell de Login  [/bin/sh]:  /bin/bash
```

Ainda sobre terminais, podemos dizer se estiver usando uma interface gráfica, muito provavelmente estará em uso de algum emulador de terminal na GUI, ou um shell **pts**, como gnome-terminal ou konsole (são mais ricos em recursos e fáceis de usar).<br>
Agora se estiver lidando com console do sistema, ou tty, trata-se de um terminal baseado em texto.<br>
Pode-se alternar, como já vimos, com as teclas Ctrl+Alt+F1-F6, sendo o F7 normalmente a sssão que leva à interface gráfica.

>[!NOTE]
>
>**tty** significa teletypewritter (teletipo); **pts** é a abreviação de pseudo terminal slave (pseudo terminal escravo). Para saber mais: **man tty** e **man pts**

#### Lançando shells com o bash
Após fazer o login, digite **bash** em um terminal para abrir um novo shell. Tecnicamente, este shell é um processo filho do shell atual.

Ao iniciar o processo filho bash, podemos especificar diversas opções para definir que tipo de shell queremos iniciar. Eis algumas opções importantes de invocação no bash:

- **bash -l** ou **bash --login**: invoca um shell de login.
- **bash -i**: invoca um shell interativo.
- **bash --noprofile**: com shells de login, ignora o arquivo de inicialização do sistema /etc/profile e os arquivos de inicialização em nível de usuário ~/.bash_profile, ~/.bash_login e ~/.profile.
- **bash --norc**: com shells interativos, ignora tanto o arquivo de inicialização do sistema /etc/bash.bashrc quanto o arquivo de inicialização em nível de usuário ~/.bashrc.
- **bash --rcfile** <file>: com shells interativos, considera <file> como arquivo de inicialização, ignorando os arquivos de inicialização do sistema /etc/bash.bashrc e em nível de usuário ~/.bashrc

#### #### Iniciando shells com  `su`  e  `sudo`

- `su`: muda o ID de user ou o torna superusuário
- `su - user2`, `su -l user2` ou `su --login user2`: iniciam um shell de login interativo com **user2**
- `su user2`: inicia um shell sem login interativo como **user2**
- `su - root` ou `su -`: inicia um shell de login interativo como **root**
- `su root` ou `su` inicia um shell interativo sem login como `root`

`sudo`: executa comandos como outro usuário (incluindo o superusuário). Como este comando é usado principalmente para obter privilégios de root temporariamente, o usuário que o emprega deve estar no arquivo  `sudoers`. Para adicionar usuários a  `sudoers`, precisamos nos tornar  `root`  e então executar:

    # usermod -aG sudo user2

Assim como o  `su`, o  `sudo`  permite invocar shells de login e sem login:
-   `sudo su - user2`,  `sudo su -l user2`  ou  `sudo su --login user2`  iniciam um shell de login interativo como  `user2`.   
-   `sudo su user2`  inicia um shell sem login interativo como  `user2`.
-   `sudo -u user2 -s`  inicia um shell sem login interativo como  `user2`.
-   `sudo su - root`  ou  `sudo su -`  inicia um shell de login interativo como  `root`.
-   `sudo -i`  inicia um shell de login interativo como  `root`.
-   `sudo -i <algum_comando>`  inicia um shell de login interativo como  `root`, executa o comando e retorna ao usuário original.
-   `sudo su root`  ou  `sudo su`  inicia um shell sem login interativo como  `root`.
-   `sudo -s`  ou  `sudo -u root -s`  iniciam um shell sem login como  `root`.

Ao usar `su` ou `sudo`, é importante considerar o contexto particular antes de iniciar um novo shell: Precisamos ou não do ambiente do usuário de destino? Se a resposta for sim, usaríamos as opções que invocam shells de login; se não, as que invocam shells sem login.

- `echo $0`: mostra qual tipo de shell está sendo usado no momento

#### Ver a quantidade de shells

`ps aux | grep bash`: supondo a seguinte saída<br>

    user2@debian:~$ **ps aux | grep bash**
    user2       5270  0.1  0.1  25532  5664 pts/0    Ss   23:03   0:00 bash
    user2       5411  0.3  0.1  25608  5268 tty1     S+   23:03   0:00 -bash
    user2       5452  0.0  0.0  16760   940 pts/0    S+   23:04   0:00 grep --color=auto bash
    
A usuária `user2` em `debian` se logou em uma sessão GUI (ou X Window System) e abriu _gnome-terminal_, depois pressionou Ctrl+Alt+F1 para entrar em uma sessão de terminal `tty`. Finalmente, ela retornou à sessão GUI pressionando Ctrl+Alt+F7 e digitou o comando `ps aux | grep bash`. Assim, a saída mostra um shell sem login interativo por meio do emulador de terminal (`pts/0`) e um shell de login interativo por meio do terminal baseado em texto (`tty1`). Note também como o último campo de cada linha (o comando) é `bash` para o primeiro e `-bash` para o último.

- `-bash`  ou  `-su`: Interativo de login
- `bash`  or  `/bin/bash`: Interativo sem login
- `<nome_do_script>`: Não-interativo sem login (scripts)

### 106.1 Instalar e configurar o X11

Em cima do X ou X11, que roda os gerenciadores de janela, como gnome, kde, xfce, etc.
Display Manager: aquela tela de login inicial.<br>
O servidor X funciona como um modelo cliente-servidor. Os apps que são executados são clientes do servidor X, que provê as disponibilidades gráficas. Assim como a calculadora, que também é um cliente do servidor X.

Normalmente as configurações ficam em `/etc/X11/xorg.conf` (por padrão já nem vem mais com as distros, tendo em vista que tudo já vem muito bem configurado.). No entanto, para explorar, teria que criar o arquivo `xorg.conf` manualmente.

Trecho LPI: [Tradicionalmente, o principal arquivo de configuração usado para configurar um servidor X é o arquivo `/etc/X11/xorg.conf`. Nas distribuições Linux modernas, o servidor X configura a si mesmo em tempo de execução quando é iniciado e, portanto, nenhum arquivo `xorg.conf` pode existir.]

O arquivo  `xorg.conf`  é dividido em estrofes separadas chamadas  _seções_. Cada seção começa com o termo  `Section`  e, após este termo está o  _nome da seção_, que se refere à configuração de um componente. Cada  `Section`  é encerrada por uma  `EndSection`  correspondente. Um arquivo  `xorg.conf`  típico contém as seguintes seções:

- `InputDevice`: usada para configurar um modelo específico de teclado ou mouse.
- `InputClass`: InputClass Nas distribuições Linux modernas, esta seção é tipicamente encontrada em um arquivo de configuração à parte, localizado em  `/etc/X11/xorg.conf.d/`.  `InputClass`  é usada para configurar uma classe de dispositivos de hardware como teclados e mouses, e não um componente específico de hardware. Veja abaixo um exemplo de arquivo  `/etc/X11/xorg.conf.d/00- keyboard.conf`:

    Section "InputClass"
            Identifier "system-keyboard"
            MatchIsKeyboard "on"
            Option "XkbLayout" "us"
            Option "XkbModel" "pc105"
    EndSection

A opção de  `XkbLayout`  determina a disposição das teclas de um teclado, como Dvorak, canhoto ou destro, QWERTY e idioma. A opção de  `XkbModel`  é usada para definir o tipo de teclado utilizado. Há uma tabela de modelos, layouts e suas descrições em  `xkeyboard-config(7)`. Os arquivos associados aos layouts de teclado podem ser encontrados em  `/usr/share/X11/xkb`. Um layout de teclado grego politônico em um computador Chromebook apareceria desta maneira:

    Section "InputClass"
            Identifier "system-keyboard"
            MatchIsKeyboard "on"
            Option "XkbLayout" "gr(polytonic)"
            Option "XkbModel" "chromebook"
    EndSection

Alternativamente, o layout de um teclado pode ser modificado durante uma sessão X em execução com o comando  `setxkbmap`. Eis um exemplo desse comando para configurar o layout grego politônico em um computador Chromebook:

    $ setxkbmap -model chromebook -layout "gr(polytonic)"

Essa configuração só permanecerá ativa enquanto a sessão X estiver em uso. Para que essas alterações se tornem permanentes, modifique o arquivo  `/etc/X11/xorg.conf.d/00-keyboard.conf`  de forma a incluir as configurações necessárias.

>[!NOTE]
>
>O comando  `setxkbmap`  utiliza a X Keyboard Extension (XKB). Este é um exemplo da funcionalidade aditiva do X Window System por meio do uso de extensões.

As distribuições Linux modernas fornecem o comando  `localectl`  através do  `systemd`, que também pode ser usado para modificar um layout de teclado e cria automaticamente o arquivo de configuração  `/etc/X11/xorg.conf.d/00-keyboard.conf`. Novamente, eis um exemplo de configuração de um teclado grego politônico em um Chromebook, desta vez com o comando  `localectl`:

    $ localectl --no-convert set-x11-keymap "gr(polytonic)" chromebook

A opção  `--no-convert`  é usada aqui para impedir que o  `localectl`  modifique o mapa do teclado no console do hospedeiro.

- `Monitor`: a seção  `Monitor`  descreve o monitor físico utilizado e onde está conectado. Eis um exemplo de configuração que mostra um monitor de hardware conectado à segunda porta de vídeo e usado como monitor principal.

    Section "Monitor"
            Identifier  "DP2"
            Option      "Primary" "true"
    EndSection

- `Device`: a seção  `Device`  descreve a placa de vídeo física utilizada. A seção também contém o módulo do kernel usado como driver para a placa de vídeo, junto com sua localização física na placa-mãe.

    Section "Device"
            Identifier  "Device0"
            Driver      "i915"
            BusID       "PCI:0:2:0"
    EndSection

- `Screen`: a seção  `Screen`  reúne as seções  `Monitor`  e  `Device`. Um exemplo de seção  `Screen`  seria semelhante ao seguinte:

    Section "Screen"
            Identifier "Screen0"
            Device     "Device0"
            Monitor    "DP2"
    EndSection

-`ServerLayout`: a seção  `ServerLayout`  agrupa todas as seções como mouse, teclado e telas em uma única interface do X Window System.

    Section "ServerLayout"
    	Identifier   "Layout-1"
    	Screen       "Screen0" 0 0
    	InputDevice  "mouse1"  "CorePointer"
    	InputDevice  "system-keyboard"  "CoreKeyboard"
    EndSection

>[!NOTE]
>
>Nem todas as seções estão presentes em um arquivo de configuração. Nos casos em que uma seção está ausente, os valores padrão são fornecidos pela instância do servidor X em execução.

Os arquivos de configuração específicos ao usuário também residem em `/etc/X11/xorg.conf.d/`. Os arquivos de configuração fornecidos pela distribuição localizam-se em `/usr/share/X11/xorg.conf.d/`. Os arquivos de configuração localizados em `/etc/X11/xorg.conf.d/` são analisados antes do arquivo `/etc/X11/xorg.conf` se ele existir no sistema.

O comando  `xdpyinfo`  é usado em um computador para exibir informações sobre uma instância do servidor X em execução. Veja abaixo um exemplo de saída do comando (determinar quais extensões Xorg estão disponíveis em um sistema):

    $ xdpyinfo
    name of display:    :0
    version number:    11.0
    vendor string:    The X.Org Foundation
    vendor release number:    12004000
    X.Org version: 1.20.4
    maximum request size:  16777212 bytes
    motion buffer size:  256
    bitmap unit, bit order, padding:    32, LSBFirst, 32
    image byte order:    LSBFirst
    number of supported pixmap formats:    7
    supported pixmap formats:
        depth 1, bits_per_pixel 1, scanline_pad 32
        depth 4, bits_per_pixel 8, scanline_pad 32
        depth 8, bits_per_pixel 8, scanline_pad 32
        depth 15, bits_per_pixel 16, scanline_pad 32
        depth 16, bits_per_pixel 16, scanline_pad 32
        depth 24, bits_per_pixel 32, scanline_pad 32
        depth 32, bits_per_pixel 32, scanline_pad 32
    keycode range:    minimum 8, maximum 255
    focus:  None
    **number of extensions:    25
        BIG-REQUESTS
        Composite
        DAMAGE
        DOUBLE-BUFFER
        DRI3
        GLX
        Generic Event Extension
        MIT-SCREEN-SAVER
        MIT-SHM
        Present
        RANDR
        RECORD
        RENDER
        SECURITY
        SHAPE
        SYNC
        X-Resource
        XC-MISC
        XFIXES
        XFree86-VidModeExtension
        XINERAMA
        XInputExtension
        XKEYBOARD
        XTEST
        XVideo
    default screen number:    0
    number of screens:    1
    
    screen #0:
      dimensions:    3840x1080 pixels (1016x286 millimeters)
      resolution:    96x96 dots per inch
      depths (7):    24, 1, 4, 8, 15, 16, 32**
      root window id:    0x39e
      depth of root window:    24 planes
      number of colormaps:    minimum 1, maximum 1
      default colormap:    0x25
      default number of colormap cells:    256
      preallocated pixels:    black 0, white 16777215
      options:    backing-store WHEN MAPPED, save-unders NO
      largest cursor:    3840x1080
      current input event mask:    0xda0033
        KeyPressMask             KeyReleaseMask           EnterWindowMask
        LeaveWindowMask          StructureNotifyMask      SubstructureNotifyMask
        SubstructureRedirectMask PropertyChangeMask       ColormapChangeMask
      number of visuals:    270
    ...

As partes mais relevantes da saída estão em negrito, como o nome da tela (que é idêntico ao conteúdo da variável de ambiente  `DISPLAY`), as informações de versão do servidor X em uso, o número e a listagem das extensões do Xorg em uso e mais informações sobre a tela em si.

Com `ps axu | grep X`, podemos ver o processo `/usr/lib/xorg/Xorg`, que roda no terminal **tty7**. E para gerar o `xorg.conf`, é necessário parar esse processo, logo terá que mudar para o **tty1** (`Ctrl+Alt+F1`), acessar como root e parar o processo **Xorg**.

É necessário mudar para o modo de multiusuários, mas sem interface gráfica, por meio do comando: `# systemctl isolate multi-user.target`. Confirme com `ps axu | grep X`, e verá que o servidor X não está mais rodando.

Agora resta executar o comando `Xorg -configure` (ubuntu 16.04) que irá gerar um arquivo `xorg.conf` em `/root`. Copie esse arquivo para `/etc/x11/xorg.conf`. Rode `startx` para subir o servidor X (mas sem a tela de login), para sair basta fazer um logout. Volte para a interface gráfica padrão executando o comando `systemctl default`. O `xorg.conf` é separado por seções, com identificadores e opções, para mouse, teclado, telas, fontes (que podem ser remotas inclusive), etc.

Vejamos algumas:

- **Module**: carregamento dinâmico de módulos.

Exemplo:  

    _Section "Module"  
    Load "glx"  
    Load "dbe"  
    Load "extmod"  
    EndSection  

_ **Files**: caminhos para alguns arquivos e diretórios utilizados pelo servidor X, como módulos mas principalmente as  **fontes**.

Exemplos:

    _Section "Files"  
    ModulePath "/usr/lib/xorg/modules"  
    FontPath "/usr/share/fonts/X11/misc"  
    FontPath "/usr/share/fonts/X11/Type1"  
    FontPath "/usr/share/fonts/X11/100dpi"  
    FontPath "/usr/share/fonts/X11/75dpi"  
    FontPath "built-ins"  
    FontPath "unix:/7100"  
    FontPath "tcp/fonts.server.com:7100"  
    EndSection_
  
- **InputDevice**: contêm configurações referentes aos dispositivos de entrada, principalmente  **mouse** e  **teclado**.  _Identifier_ e  _Driver_  são parâmetros obrigatórios utilizados para especificar o dispositivo. Além disso parâmetros  _Option_ podem ser adicionados para implementar configurações específicas

Exemplo:

    _Section "InputDevice"  
    Identifier "Keyboard0"  
    Driver "kbd"  
    Option "XkbModel" "pc105"  
    Option "XkbLayout" "us"  
    Option "AutoRepeat" "500 200"  
    EndSection_

      _Section "InputDevice"  
    Identifier "Mouse0"  
    Driver "mouse"  
    Option "Protocol" "auto"  
    Option "Device" "/dev/input/mice"  
    Option "Emulate3Buttons" "no"  
    Option "ZAxisMapping" "4 5"  
    EndSection_

  
- **Device**: seção utilizada principalmente para configuração da  **placa de vídeo**. Semelhante ao InputDevice, tem os parâmetros  _Identifier_ e  _Driver_ como obrigatórios.

Exemplo:

    _Section "Device"  
    Identifier "VideoCard0"  
    Driver "nv"  
    VendorName "nVidia"  
    BoardName "GeForce 6100"  
    VideoRam 131072  
    EndSection_

  
- **Monitor**: configurações específicas do monitor utilizado, como  _HorizSync_ e  _VertRefresh_.

Exemplo:

    _Section "Monitor"  
    Identifier "Monitor0"  
    VendorName "Monitor Vendor"  
    ModelName "Monitor Model"  
    HorizSync 30.0 - 83.0  
    VertRefresh 55.0 - 75.0  
    EndSection_

  
- **Screen**: a seção screen é uma combinação entre o monitor e a placa de vídeo, dizendo ao X quais os modos que ele pode trabalhar. Na sub-seção  **Display**, são informados por exemplo as  **resoluções** suportadas,  **color depth** (bits por pixel), e etc.

    _Section "Screen"  
    Identifier "Screen0"  
    Device "Card0"  
    Monitor "Monitor0"  
    SubSection "Display"  
    Viewport 0 0  
    Depth 1  
    EndSubSection  
    SubSection "Display"  
    Viewport 0 0  
    Depth 4  
    EndSubSection  
    SubSection "Display"  
    Depth 24  
    Modes "1920x1080" "1280x1024" "1024x768"  
    EndSubSection  
    SubSection "Display"  
    Depth 8  
    Modes "1024x768" "800x600" "640x480"  
    EndSubSection  
    EndSection_

  
- **ServerLayout**: esta seção agrega as outras definições da configuração do X, associando principalmente as informações do Screen e InputDevices.

Exemplo:

    _Section "ServerLayout"  
    Identifier "X.org Configured"  
    Screen 0 "Screen0" 0 0  
    InputDevice "Mouse0" "CorePointer"  
    InputDevice "Keyboard0" "CoreKeyboard"  
    EndSection_

#### Uso da variável $DISPLAY

`$Display` mostra, normalmente, a seguinte informação:<br>

    :0.0

    hostname:displaynumber.screennumber

O nome de exibição também informa a um aplicativo gráfico onde ele deve ser renderizado e em qual hospedeiro (no caso de uma conexão X remota).

O  `hostname`  refere-se ao nome do sistema que exibirá o aplicativo. Se o nome de exibição não contiver o nome do hospedeiro, o host local será pressuposto.

O  `displaynumber`  faz referência à coleção de “telas” que estão em uso, seja uma única tela de laptop ou diversas telas em uma estação de trabalho. Cada sessão do servidor X em execução recebe um número de exibição começando em  `0`.

O  `screennumber`  padrão é  `0`. Esse pode ser o caso se apenas uma tela física ou diversas telas físicas estiverem configuradas para funcionar como uma só tela. Quando todas as telas de uma configuração de múltiplos monitores são combinadas em uma única tela lógica, as janelas do aplicativo podem ser movidas livremente entre as telas. Em situações em que cada tela é configurada para funcionar independentemente uma da outra, cada tela abrigará as janelas dos aplicativos que forem abertos dentro delas e as janelas não podem ser movidas de uma tela para outra. A cada tela independente será atribuído seu próprio número. Se houver apenas uma tela lógica em uso, o ponto e o número da tela serão omitidos.

Para iniciar um aplicativo em uma tela específica, atribua o número da tela à variável de ambiente  `DISPLAY`  antes de iniciar o aplicativo: $

    $ DISPLAY=:0.1 firefox &

Esse comando iniciaria o navegador Firefox na tela à direita do diagrama acima. Alguns kits de ferramentas também oferecem opções de linha de comando para instruir um aplicativo a ser executado em uma tela especificada. Procure por  `--screen`  end  `--display`  na página do manual de  `gtk-options(7)`  para ver um exemplo..

O nome de exibição de uma sessão X em execução é armazenado na variável de ambiente  `DISPLAY`:

    $ echo $DISPLAY
    :0

A saída detalha o seguinte:

1.  O servidor X em uso está no sistema local, portanto não há nada impresso à esquerda dos dois pontos.
    
2.  A sessão atual do servidor X é a primeira indicada por  `0`  imediatamente após os dois pontos.
    
3.  Há apenas uma tela lógica em uso, portanto um número de tela não é visível.

Quando não há nada antes dos dois pontos (`:`), considera-se que o valor é `localhost`. Para executar algum app em outro computador, precisa-se mudar o valor da variável de ambiente DISPLAY:<br>

    export DISPLAY="192.168.0.100:0.0"

No host que irá receber a abertura do programa escolhido, é preciso liberá-lo para essa conexão. Por meio do comando `xhost` é possível verificar quem que está autorizado a permitir essa conexão. Para liberar o acesso, digite o comando:<br>

    xhost +192.168.0.99

Digite `xhost` novamente para confirmar que realmente foi liberado. Para liberar completamente o controle de acesso, digite `xhost +` (comando para restringir novamente é: `xhost -`)

Ainda assim não será possível realizar a tarefa, pois o **Display Manager** está bloqueando. No caso, seria o **lightdm**. Se olhar no processo Xorg (`ps axu | grep X`), é possível notar que **lightdm** está rodando com a opção `-nolisten tcp`, e é necessário mudar essa opção (isso para distros baseadas no Debian/Ubuntu).

Vá até `/usr/share/lightdm/lightdm.conf.d`, e edite o arquivo `50-xserver-command.conf`e adicione `xserver-allow-tcp=true` no final do arquivo. Reinicie o `lightdm: systemctl restart lightdm`. Se olhar no processo Xorg **NÃO** terá mais o `-nolisten tcp`

Agora do computador que irá executar o comando para abertura de algum app, execute **xcalc** ou qualquer outro aplicativo para abrir no outro computador.<br>
*O processamento todo está sendo feito pelo PC que abriu a aplicação, no caso o PC de origem. O de destino apenas está gerando a parte gráfica.

#### X11 e o Desktop Environment

Desktop Environment: é um **conjunto de aplicações**, com a finalidade de prover uma interface gráfica amigável ao usuário.<br>
Exemplos: KDE, GNOME, MATE, Cinnamon, LXDE, Xfce

##### Gerenciador de Janelas (Window Manager)

- Controla a criação e fechamento das janelas no ambiente, além do posicionamento e aparência
- São clientes X
- Podem ser parte integrada de um DE ou independentes
- Exemplos: mutter (GNOME), KWin (DKE), Muffin (Cinnamon), Xfwm (XFCE), enligntenment, window maker, Openbox, etc
*É requisito ter um **Window Manager** dentro do **Desktop Environment**

- `update-alternatives --display x-window-manager`: verifica qual é o gerenciador de janelas, ou com o comando:
- `ls -l /etc/alternatives/ | grep window`

##### Interface Gráfica (GUI)

Quando falamos qual interface gráfica você usa? E respondemos KDE, GNOME, etc. Na realidade tecnicamente estamos falando de **Desktop Environment (DE)**.

Já a Interface Gráfica em que o usuário interage, que é o que é usado pelo usuário, é chamado de, por exemplo, do KDE é o KDE Plasma. Do GNOME, é o GNOME Shell, etc

Portanto, a interface gráfica é um dos muitos componentes dentro do DE.

Se estiver usando o GNOME, faça o teste:

- `ps axu | grep gnome`: lista diversas aplicações, como gnome-settings, gnome-software, etc. Essas são aplicações que fazem parte do DE. Uma delas vai ser o `gnome-shell`, que no caso é a interface gráfica.
 
##### Display Managers (DM)

- Interface para realização do login
- Exemplos: GDM (GNOME), LightDM (XFCE), XDM, LXDM
*Geralmente termina em DM (Display Manager)

##### Wayland

É uma alternativa ao X11, criado pelo xorg.

- Protocolo que especifica a comunicação entre o servidor gráfico (Compositor Wayland) e os clientes
- Criado com a intenção de substituir o X, com uma arquitetura diferente visado melhor performance geral
- Atualmente utilizando por padrão no Fedora com GNOME, mas é uma opção em todos os DE
- Projeto em Desenvolvimento

#### Comandos e Arquivos

Em `/usr/share/X11/xorg.conf.d` ficam alguns arquivos de configuração de aplicativos ligados ao hardware, como GPUs, com padrão Section e EndSection

Todos os usuário terão em seu diretório padrão o arquivo `.xsession-errors`, que é um arquivo de log para guardar os erros que ocorrem relacionados à interface gráfica

O acesso remoto que foi feito usando **xhost**, pode ser feito usando o `xauth list`, pegando o magic cookie do computador que quer executar os aplicativos, e adicionando esse magic coockie no computador que irá realizar o acesso, usando o comando:

- `xauth add 192.168.0.100 MIT-MAGIC-COOKIE-1 hash_gerada`

### 106.2 Desktops gráficos

Desktops Environments: GNOME, KDE, MATE, Cinnamon, XFCE, LXDE

- **GNOME**: forte associação ao Projeto GNU, usa biblioteca gráfica **GTK**, Window Manager: mutter.
- **KDE**: pode ser usado em Linux, FreeBSD, Solaris, Windows e Mac OS X, usa biblioteca gráfica **Qt**, Window Manager: KWin
- **MATE**: derivado do GNOME 2, utiliza biblioteca GTK, Window Manager: marco
- **Xfce**: pretende ser rápido e leve, utiliza biblioteca GTK, Window Manager: xfwm

*O **LXDE** é um ambiente de desktop adaptado para baixo consumo de recursos, sendo assim uma boa escolha para instalação em equipamentos mais antigos ou computadores de placa única. Embora não ofereça todas as capabilidades dos ambientes de trabalho mais pesados, o LXDE inclui todos os recursos básicos esperados de uma interface gráfica de usuário moderna

#### Protocolos para acesso remoto a Desktops

- **XDMCP** (X Display Manager Control Protocol)
	- Protocolo nativo do X
	- Implementado pelo Display Manager
	- Não implementa segurança/criptografia
	- Não faz compressão (ocupa bastante banda  )

Para conexão remota utilizando XDMCP, configure o arquivo `/etc/lightdm/lightdm.conf` de maneira que habilite o XDMCPServer:<br>

    [XDMCPServer]
    enable=true

Em outro terminal, execute: `Xorg -terminate -query 192.168.0.100 :1`

- **VNC** (Virtual Networking Computing)
	- utiliza o protocolo RFB (Remote Framebuffer Protocol)
	- Não é totalmente seguro, mas as senhas são criptografadas
	- É possível executar muitos servidores VNC na mesma máquina, mas cada servidor VNC precisa de uma porta TCP exclusiva na interface de rede que aceite solicitações de sessão de entrada. Por convenção, o primeiro servidor VNC deve usar a porta TCP 5900, o segundo deve usar 5901 e assim por diante

- **SPICE** (Simple Protocol for Independent Computing Environment)
	- solução open source completa para acesso remoto
	- solução mais segura

- **RDP** (Remote Desktop Protocol): é usado sobretudo para acessar remotamente a área de trabalho de um sistema operacional _Microsoft Windows_ por meio da porta de rede TCP 3389
	- utilizado para o Microsoft Terminal Service

### 106.3 Acessibilidade

Acessibilidade também é chamada de **AccessX**. Pode ser alterado com a linha de comando: `xkbset`

Locais para acesso: O módulo de configurações de acessibilidade é chamado de _Acesso universal_ na área de trabalho do Gnome, enquanto que no KDE ele está em _Configurações do sistema_, _Personalização_, _Acessibilidade_. Outros ambientes de desktop, como o _Xfce_, também o chamam de _Acessibilidade_ em seu gerenciador de configurações gráficas. Porém, de maneira geral eles oferecem um conjunto reduzido de funcionalidades em comparação com o Gnome e o KDE.

- `sticky keys` (teclas de aderência): é para quem não consegue apertar mais de uma tecla ao mesmo tempo (Ex. shift + A ou S, etc). Se habilitar, basta apertar a tecla do atalho e a outra sequencial (sem necessidade de segurar) - (O KDE também oferece a opção de _Teclas de bloqueio_: se habilitada, as teclas Alt, Ctrl e Shift permanecerão “apertadas” se o usuário as pressionar duas vezes, semelhante ao comportamento da tecla Caps lock) - (o recurso de teclas de aderência será ativado pressionando-se a tecla Shift cinco vezes consecutivas. Para ativar o recurso de teclas lentas, a tecla Shift deve ser mantida pressionada por oito segundos consecutivos)
- `slow keys`(teclas lentas): usado por quem tem problema motor, as teclas lentas exigem que o usuário mantenha a tecla pressionada por um período de tempo especificado antes de ela ser aceita
- `bouce keys`(teclas de repercussão): serve para inibir pressionamentos de tecla não intencionais adicionando um tempo de latência entre eles (se precisar digitar a mesma tecla, precisa aguardar o delay)
- `mouse emulation`: para usar o mouse com o teclado numérico da direita. (Ex. 8=cima, 2=baixo, 6=direita e 4=esquerda, 5=pressionar - clique esquerdo)
- `Preferências do mouse  na janela de configuração do sistema`: se o usuário não conseguir pressionar um ou mais botões do mouse, os cliques podem ser simulados usando diferentes técnicas. Na seção  _Assistência de clique_  do  _Acesso Universal_  do Gnome, a opção  _Clique secundário simulado_  simula um clique com o botão direito se o usuário pressionar e segurar o botão esquerdo do mouse. Com a opção  _Clique flutuante_  habilitada, um evento de clique será disparado quando o usuário segurar o mouse sem movê-lo. No KDE, o aplicativo  _KMouseTool_  fornece esses mesmos recursos para facilitar as ações com o mouse.
- `GOK (Gnome On-board Keyboard)`: teclado virtual On-board
- `KMag`: screen magnifier (ampliador de tela - LUPA)
- `Orca e emacspeak`: leitor de tela, sendo o Orca o principal
- `BRLTTY`: app do Linux para entender e usar o [Braille Display](https://www.google.com/search?q=braille+display&oq=brai&gs_lcrp=EgZjaHJvbWUqBggAEEUYOzIGCAAQRRg7MgYIARBFGDkyBggCEEUYPDIGCAMQRRg8MgYIBBBFGEEyBggFEEUYQTIGCAYQRRhBMgYIBxAuGEDSAQgzODQ5ajBqMagCALACAA&sourceid=chrome&ie=UTF-8)]

#### Reconhecimento de voz

Software capaz de executar comandos através do reconhecimento de voz. Diversos projetos Open Source em desenvolvimento (além dos principais para dispositivos móveis, como Siri, Cortana, etc.
- CMUSphinx
- Simon (KDE)
- Julius

Pergunta interessante na [lpi.org](https://learning.lpi.org/pt/learning-materials/102-500/106/106.3/106.3_01/) citando o Orca<br>
De que forma o aplicativo  _Orca_  pode ajudar usuários com deficiência visual a interagir com o ambiente de trabalho?
O Orca é um leitor de tela que gera uma voz sintetizada que descreve os eventos na tela e lê o texto sob o cursor do mouse. Ele também funciona com dispositivos chamados de  _visores braille atualizáveis_, permitindo ao usuário identificar o texto com padrões táteis.

### 107.1 Administrar contas de usuário, grupos e arquivos de sistema relacionados

Cada usuário tem, obrigatoriamente, seu grupo padrão. E pode estar em vários grupos, ou seja, o mesmo usuário pode estar em vários grupos, facilitando para o administrador de sistemas.

- `/etc/passwd`: principal arquivo que contém todos os usuários do sistema
	- `id` e `gid`: id e id do grupo padrão do usuário (**root SEMPRE será id igual a 0 zero, assim como seu gid**)

Se observar há diversos usuários de sistema, como por exemplo o **daemon**. No Linux, para poder criar um processo ou gerar um arquivo, é preciso ter um usuário, no mínimo. Por isso a necessidade de aplicações terem seu usuário

Normalmente (varia de distro para distro), ids a partir de 1000 são os de usuário, abaixo de 1000 são os de sistema. Lembrando que isso é mais comum, mas pode variar, pois é totalmente configurável.

Por convenção, em `/etc/passwd`, é recomendado sempre utilizar caracteres minúsculos, pois haveria distinção de um usuário chamado rodrigo e Rodrigo, pois é case sensitive. Portanto, é recomendado seguir o padrão.

#### Entendendo cada campo do /etc/passwd
Ordem dos campos:<br>
1. nome do usuário
2. senha do usuário: que armazena em `/etc/shadow`. Antigamente armazenava aqui mesmo
3. id do usuário
4. grupo padrão do usuário: que por padrão usa o mesmo nome do usuário, mas também é configurável e possível alterar
5. descrição: normalmente o nome do usuário, mas isso não é regra.
6. home do usuário: local onde usuário poderá gravar sem restrições, e onde também o usuário cai ao fazer login
7. shell padrão do usuário, que é aberto após login. Quando tem `/bin/false`, significa que **NÃO** é um usuário que irá se logar. Assim como quando tiver `/usr/sbin/nologin`.<br>
*Internamente o Linux sempre trabalha com o `id`.<br>
**Pode-se ter dois usuários com o mesmo id, no entanto o Linux tratará os dois como se fosse um só.<br>
***Pode-se alterar o arquivo `/etc/passwd` diretamente, mas não é recomendado, pois há comandos para isso (e pense que o `/etc/passwd` é ligado com o `/etc/shadow`, e mudar uma coisa em um, geraria inconsistência no outro). Ex. Poderia alterar o id de qualquer usuário para o `id = 0`, e esse usuário se comportaria como root. No entanto não é recomendado.

#### Entendendo cada campo do /etc/shadow

Contém as senhas dos usuário<br>
Ordem dos campos:<br>
1. usuário propriamente dito
2. hash da senha (**quando não** tem senha definida, fica um ponto de exclamação - `!`)

#### Entendendo cada campo do /etc/group

Contém os grupos dos usuário<br>
Ordem dos campos:<br>
1. nome do grupo
2. senha (sim, grupo também pode ter senha, que fica em `/etc/gshadow`)
3. ids do grupo
4. usuários que fazem parte do grupo

#### Entendendo cada campo do /etc/login.defs

Contém as definições de login de cada usuário. No caso, aqui também tem as definições de ids dos usuários (fica próximo da linha 172). Por exemplo:<br>

    # Min/max values for automatic uid selection in useradd
    171 #
    172 UID_MIN                  1000
    173 UID_MAX                 60000

Lembrando que é uma convenção, o Linux, por exemplo, pode ter mais que 60k usuários.

É nesse arquivo também que podemos alterar a variável `DEFAULT_HOME` para `yes` para criar o `/home` dos usuários.

Mais algumas diretivas importantes:<br>

- `UID_MIN`  e  `UID_MAX`: O intervalo de IDs de usuário que podem ser atribuídos a novos usuários comuns.
- `GID_MIN`  e  `GID_MAX`: O intervalo de IDs de grupo que podem ser atribuídos a novos grupos comuns.

- `CREATE_HOME`: Especifica se um diretório pessoal deve ser criado por padrão para novos usuários.
- `USERGROUPS_ENAB`: Especifica se o sistema deve, por padrão, criar um novo grupo para cada nova conta de usuário com o mesmo nome do usuário, e se, ao deletar a conta do usuário, o grupo primário do usuário também deve ser removido, caso não contenha mais membros.

- `MAIL_DIR`: O diretório de spool de email.
- `PASS_MAX_DAYS`: O número máximo de dias que uma senha pode ser usada.
- `PASS_MIN_DAYS`: O número mínimo de dias permitido entre mudanças de senha.
- `PASS_MIN_LEN`: O comprimento mínimo aceitável da senha.
- `PASS_WARN_AGE`: O número de dias de aviso antes que uma senha expire.

>[!TIP]
>
>Ao gerenciar usuários e grupos, sempre verifique este arquivo para visualizar e, eventualmente, alterar o comportamento padrão do sistema, se necessário.

#### 107.1 Gerenciamento de Usuários e Grupos - useradd, userdel, usermod, passwd

Basicamente são:<br>
- `useradd`: adiciona usuário
- `userdel`: exclui usuário
- `usermod`: altera configurações usuário

##### useradd
- `useradd usuário1`: cria o **usuário1**, e em `/etc/passwd`, cria uma linha referente a esse usuário. Algumas distros antigas tinham um bug que não informava o shell a ser utilizado, ficando em branco, e tendo que alterar manualmente (é possível mudar com o comando `chsh`)

Exemplo com várias opções:<br>

    useradd -c "Nome do Usuario" -s /bin/bash -g 1001 -G 1010

- `-c`(`--comment`):  string de texto com o comentário do usuário (geralmente nome completo do usuário
- `-s`(--shell): shell padrão desejado pelo novo usuário
- `-g`(`--gid`): grupo primário (padrão) do novo usuário
- `-G` (`--group`): grupo(s) secundários do novo usuário (outros grupos que o usuário vai pertencer)
- `-e` (`--expiredate`) (YYYY-MM-DD): define um tempo que a conta será desabilitada
- `-f`: cria uma nova conta de usuário definindo o número de dias após a expiração de uma senha durante os quais o usuário deve atualizar a senha (caso contrário, a conta será desabilitada).
- `-k`: cria uma nova conta de usuário copiando os arquivos de esqueleto de um diretório personalizado específico (esta opção só é válida se a opção  `-m`  ou  `--create-home`  for especificada).

Outras opções importantes:
- `-d` (`--home-dir`): definir um `/home` para usuário (não precisa ser o padrão)
- `-m` (`--create-home`): caso no `/etc/user.defs` esteja para não criar `/home` por padrão, pode-se usar essa opção para "forçar" criar o `/home` do usuário (conforme definido no skeleton directory) 
- `-M` (`--no-create-home`): não cria o `/home`
- `-p` (`--password`): define a senha. Mas precisa ser em hash, que pode ser criado por outro comando.
- `-u` (`--uid`): id deseja que o usuário tenha

##### userdel

Supõe que **usuario1** tenha entrada referente a ele em `/etc/passwd`, `/etc/shadow`, `/etc/group` e ele possua um diretório em `/home`, sendo `/home/usuario1`. Se executar:<br>

    userdel usuario1

Será apagado as entradas nos três arquivos, mas **não apagará** a pasta `/home/usuario1`. Para apagar, tem que usar a opção `-r`:
- `-r` (`--remove`): remove o /home do usuário

##### usermod

Basicamente muda o que poderia ser definido com o `useradd`. Supõe que usuario1 não tem comentário, podemos adicionar um comentário com o comando:<br>

    usermod -c "Nome usuario 1" usuario1

Mudar o shell do usuário1:<br>

    usermod -s /sbin/ksh usuario1

`usermod -g suporte usuario1`: muda para **suporte** o grupo padrão do **usuario1** (originalmente, quando criado, o grupo padrão (`-g`) do **usuario1** era **usuario1**. Confirme com um `cat /etc/passwd` para ver o id do grupo do **usuario1**.

Repare na similaridade dos dois comandos a seguir:<br>


`usermod -G devops usuario1`: define o grupo **devops** como grupo secundário do **usuario1**. Repare que em `/etc/passwd`, ainda continuar sendo o grupo padrão o grupo `suporte` (considerando a mudança no comando do parágrafo anterior. No entanto o **usuario1** também pertence agora ao grupo **devosp**.

`usermod -G qateams usuario1`: define o grupo **qateams** como grupo secundário do **usuario1**. Repare que em `/etc/passwd`, ainda continuar sendo o grupo padrão o grupo `suporte` (considerando a mudança no comando do parágrafo anterior. No entanto o **usuario1** também pertence agora ao grupo **qateams**. NO ENTANTO, o usuario1 não faz mais parte do grupo suporte (imagine que o limite de grupos secundários seja 1 grupo por vez), mas podemos podemos manter o grupo secundário com o argumento `-a`, que no caso vai adicionando os grupos. Ficando o comando:<br>

    usermod -G -a qateams usuario1

ou

    usermod -aG qateams usuario1
- `-a` ou `--append`

- `-l` ou `--login`: altera o nome de login da conta de usuário especificada.
- `-L`ou `--lock`:  bloqueia a conta de usuário especificada. Um ponto de exclamação é posto na frente da senha criptografada dentro do arquivo  `/etc/shadow`, desabilitando assim o acesso com senha para esse usuário. (Note: if you wish to lock the account (not only access with a password), you should also set the EXPIRE_DATE to 1).
- `-U`ou `--unlock`: desbloqueia a conta de usuário especificada. Remove o ponto de exclamação na frente da senha criptografada no arquivo  `/etc/shadow`.

>[!TIP]
>
>Lembre que, ao alterar o nome de login de uma conta de usuário, você provavelmente deve renomear o diretório pessoal desse usuário e outros itens relacionados a ele, como arquivos de spool de email. Lembre também que, ao alterar o UID de uma conta de usuário, provavelmente será preciso corrigir a propriedade dos arquivos e diretórios que estejam fora do diretório inicial do usuário (o ID do usuário é alterado automaticamente na caixa de email do usuário e em todos os arquivos pertencentes ao usuário e localizados no diretório inicial do usuário).

##### passwd

Usado para alterar/criar senha para usuários (precisa ser root)

    passwd usuario1 #troca a senha do usuario1
    passwd #troca a senha do usuario root

Lembre-se que ao criar um usuário, no campo referente à senha lá no arquivo `/etc/shadow`, vai ficar com um ponto de exclamação (`!`), indicando que não foi definido uma senha. Após criar uma senha com o comando `passwd`, uma hash entrará no lugar do ponto de exclamação.

    su usuario1 #troca para o usuario1

Mais algumas opções para o uso de `passwd`:<br>

- `-d`: apaga a senha de uma conta de usuário (desabilitando o usuário).
- `-e`:  força a conta de usuário a alterar a senha.
- `-i`:  define o número de dias de inatividade após a expiração de uma senha, durante os quais o usuário deve atualizar a senha (caso contrário, a conta será desabilitada).
- `-l`: bloqueia a conta de usuário (a senha criptografada é prefixada com um ponto de exclamação no arquivo  `/etc/shadow`).
- `-n`: define o tempo de vida mínimo da senha.
- `-S`: exibe informações sobre o status da senha de uma conta de usuário específica.
- `-u`: desbloqueia a conta do usuário (o ponto de exclamação é removido do campo de senha no arquivo  `/etc/shadow`).
- `-x`: define o tempo de vida máximo da senha.
- `-w`: define o número de dias de aviso antes que a senha expire, durante os quais o usuário é advertido de que a senha deve ser alterada.

>[!NOTE]
>
>Os grupos também podem ter uma senha, que pode ser definida usando o comando  `gpasswd`. Os usuários que não são membros de um grupo mas conhecem a senha podem ingressar nele temporariamente usando o comando  `newgrp`.  `gpasswd`  também é usado para adicionar e remover usuários de um grupo e para definir a lista de administradores e membros comuns do grupo.

> [!IMPORTANT] 
>
>Há o comando `adduser`, que na realidade é um script que vai interagindo para criação do usuário. A nível de LPI, focar no `useradd`.

#### 107.1 Gerenciamento de Usuários e Grupos - groupadd, groupdel, groupmod

- `groupadd`: adiciona grupo
- `groupdel`: exclui grupo
- `groupmod`: altera configurações do grupo

##### groupadd

- `groupadd suporte`: cria o grupo **suporte**
- `groupadd -g 2000 dev`: cria o grupo **dev** com id 2000

##### groupdel

- `groupdel suporte`: exclui o grupo suporte

##### groupmod

É possível mudar o id e o nome do grupo. No exemplo abaixo está mudando o nome do grupo de **suporte** para **devops**:

- `groupmod -n devops suporte`(`-n` ou `--new-name`): altera o nome do grupo de suporte para devops
- `groupmod -g 2001 suporte`(`-g` ou `--gid`): altera o id do grupo para 2001

*Não é possível excluir um grupo caso se trate do grupo principal de uma conta de usuário. Portanto, é preciso remover o usuário antes de remover o grupo. Quanto aos usuários, se você excluir um grupo, os arquivos pertencentes a esse grupo permanecerão em seu sistema de arquivos e não serão excluídos ou atribuídos a outro grupo.

##### newgrp

Comando faz com que o usuário atual assuma determinado grupo durante a sessão de login.

- `newgrp suporte`: supõe que está logado com **usuario1**, e que esse usuário também faça parte do grupo **suporte**, além de seu próprio (grupo **usuario1**). Ao executar o comando no começo da frase, ele assume o grupo **suporte** como padrão, e arquivos criados serão do grupo **suporte**.

##### senhas nos grupos

Seria uma situação que o usuário não faz parte de um grupo, se tentar, por exemplo, com o comando: `newgrp devops`, e o usuário não fizer parte do grupo, vai pedir uma senha, e somente será admitido ao grupo se souber a senha.

Primeiramente é necessário criar uma senha para o grupo, com o comando:<br>

    gpasswd nome_grupo

Lembrando que se pode observar os grupos que têm senha olhando o arquivo `/etc/gshadow`

Para acessar o grupo, basta usar o comando `newgrp nome_grupo`

> [!CAUTION]
> 
>Utilizar senha em grupo não é recomendado, e é pouquíssimo ou quase não utilizado.

#### 107.1 Gerenciamento de Usuários e Grupos - id, groups, getent e chage

- `id`: imprime o id do usuário e o id dos grupos pertencentes a esse usuário (usuário atual). Ou pode usar colocando o usuário como parâmetro: `id usuario1`

Sequencialmente seria: 
- **id do usuário**; 
- **id do grupo padrão do usuário**;
- **grupos secundários que esse usuário pertence**.

- `groups`: mesmo conceito que no comando `id`, que irá listar os grupos do usuário logado. Podendo também especificar um usuário. Ex. `groups usuario1`<br>
Ex.<br>

```
    $ groups rodrigo
    rodrigo adm cdrom sudo dip plugdev users lpadmin sambashare
```
`getent`: pega informações de grupos/usuários (esse comando exibe entradas de bancos de dados suportados pelas bibliotecas _Name Service Switch_ (NSS) e requer o nome do banco de dados e uma chave de pesquisa)

- `getent passwd rodrigo`: pega informação do usuário rodrigo em `/etc/passwd` (como se fosse um `cat /etc/passwd | grep rodrigo`)
- `getent group suporte`: pega informações do usuário suporte no `/etc/group`

>[!NOTE]
>
>Lembre-se de que o `getent` só pode acessar os bancos de dados configurados no arquivo `/etc/nsswitch.conf`.

##### chage (change age - alterar idade)

`chage`: mostra as propriedades do usuário: quando a senha vai expirar ou ficar ativa/inativo, número máximo entre dias para alterar senha, última vez que usuário mudou a senha, etc
- `chage -l rodrigo`: mostra propriedades do usuário rodrigo (apenas **root** pode ver as propriedades de todos os usuários, os demais somente suas próprias informações)
- `chage -M 60 rodrigo`: força que o usuário troque de senha a cada 60 dias. Execute `chage -l rodrigo` para saber se aplicou mesmo.
- `chage -d "2024-11-13" rodrigo`: (ou `--lastday`): muda a data que da última vez que o usuário mudou a senha. (isso implica se, por exemplo, foi configurado para trocar a senha a cada x dias. Se for 10 dias, e voltar mais de 10 dias da última troca, vai ter que cadastrar uma nova senha, pois a senha é considerada expirada).
- - `chage -E "2024-12-12" rodrigo`: (ou `--expiredate`): define uma data para a conta expirar. Se expirar, ao logar, vai informar que a conta foi expirada, que é preciso falar com o administrador do sistema
- `chage -E -1 rodrigo`: volta a conta ao normal, em referências ao comando anterior.
- `chage -d0 rodrigo`: força o usuário a trocar senha no próximo login (**root enforced**)
- `-I`: define o número de dias de inatividade após a expiração de uma senha, durante os quais o usuário deve atualizar a senha (caso contrário, a conta será desabilitada).
- `-W`: define o número de dias de aviso antes que a senha expire, durante os quais o usuário é advertido de que a senha deve ser alterada.

>[!NOTE]
>
>A sequencias mostrada no comando `chage`, é a mesma dentro do arquivo `/etc/shadow`. Inclusive a última coluna, é o número de dias, desde 1970. (Nos sistemas mais novos não foi percebido essa informação).

##### Exercícios interessantes no site lpi.org

Comandos aleatórios:<br>
|   |   |
|---|---|
| `usermod -L` | Bloquear a conta de usuário |
| `passwd -u` | Desbloquear a conta de usuário |
| `chage -E` | Definir a data de expiração da conta de usuário |
| `groupdel` | Excluir o grupo  |
| `useradd -s` |Criar uma nova conta de usuário com um shell de login específico |
| `groupadd -g` | Criar um novo grupo com um GID específico |
| `userdel -r` | Remover a conta de usuário e todos os arquivos em seu diretório inicial, o próprio diretório inicial e o spool de email do usuário |
| `usermod -l` | Alterar o nome de login da conta de usuário |
| `groupmod -n` | Alterar o nome do grupo |
| `useradd -m` | Criar uma nova conta de usuário e seu diretório inicial  |

Comandos correspondentes:<br>

|   |   |
|---|---|
| `passwd -n` | `chage -m` |
| `passwd -x` | `chage -M` |
| `passwd -w` | `chage -W` |
| `passwd -i` | `chage -I` |
| `passwd -S` | `chage -l` |

No Linux, podemos usar o comando `passwd -n` (ou `chage -m`) para definir o número mínimo de dias entre as mudanças de senha, o comando `passwd -x` (ou `chage -M`) para definir o número máximo de dias durante os quais uma senha é válida, o comando `passwd -w` (ou `chage -W`) para definir o número de dias de aviso antes que a senha expire, o comando `passwd -i` (ou `chage -I`) para definir o número de dias de inatividade durante os quais o usuário deve alterar a senha e o comando `passwd -S` (ou `chage -l`) para exibir informações breves sobre a senha da conta de usuário.

Comando para bloquear e desbloquear usuários<br>
`usermod --lock` e `passwd -l`. 
Já para desbloqueá-la, os comandos seriam `usermod -U`, `usermod --unlock` e `passwd -u`.

***O comando `usermod` não inclui a opção de remover apenas um grupo; portanto, você precisa especificar todos os grupos secundários aos quais o usuário pertence.

    # usermod -G administrators,web-designers kevin

Questão 6:<br>
Usando o comando  `chage`, primeiro verifique a data de expiração da conta de usuário  `kevin`  e depois altere-a para 31 de dezembro de 2022. Que outro comando pode ser usado para alterar a data de expiração de uma conta de usuário?

    # chage -l kevin | grep "Account expires"
    Account expires		: never
    # chage -E 2022-12-31 kevin
    # chage -l kevin | grep "Account expires"
    Account expires		: dec 31, 2022

O comando  `usermod`  com a opção  `-e`  equivale a  `chage -E`.

Questão 7:<br>
Adicione uma nova conta de usuário chamada  `emma`  com UID 1050 e defina  `administrators`  como seu grupo principal e  `developers`  e  `web-designers`  como seus grupos secundários.

    # useradd -u 1050 -g administrators -G developers,web-designers emma
    # id emma
    uid=1050(emma) gid=1028(administrators) groups=1028(administrators),1029(developers),1031(web-designers)

## 107.2 Automatizar e agendar tarefas administrativas de sistema

#### Cron

É um daemon, um processo que fica rodando, de agendamento do sistema (normalmente do sistema). Verificar se está rodando com `systemctl status cron`

O arquivo `/etc/crontab` é onde ficam as tarefas de agendamento, que é executado pelo usuário **root** (a tabela de tarefas `cron` é comumente chamado de `contrabs`, que contêm os chamdos `cron jobs` - trabalho cron)

>[!NOTE]
>
>No Linux, também existe o recurso `anacron`, adequado para sistemas que podem ser desligados (como computadores de mesa ou laptops). Ele só pode ser usado pelo root. Se a máquina estiver desligada quando os trabalhos de `anacron` tiverem de ser executados, isso ocorrerá na próxima vez em que se ligar a máquina. O `anacron` está fora do escopo da certificação LPIC-1.

Os 5 primeiros campos são delimitados questões do tempo, sendo, sequencialmente: <br>
**minuto da hora (0-59)** | **hora do dia (0-23)** | **dia do mês - dom (1-31)** | **mês do ano -mon (1-12)** | **dia da semana - dow (0-7 com Domingo=0 ou Domingo=7)**

*Para o mês do ano e o dia da semana, podemos usar as três primeiras letras do nome em vez do número correspondente.

- supõe que esteja com o valor 17 no campo **m** (**minute**), significa que vai executar todo minuto 17.
- `*` = qualquer valor. qualquer minuto, qualquer hora, qualquer dia do mês, etc. Outra forma que facilitar a leitura do asterisco é interpretá-lo como "**seja o dia/hora/mes que for** ou **qualquer valor**"
- **dow (day of week):**
	-  `7` e `0` = domingo, logo: 
	- `1`= segunda-feira, 
	- `2`= terça-feira, etc

- `,`: especifica uma lista de valores possíveis
- `-`(hífen): especifica um intervalor de valores possiveis
- `/`: especifica valores escalonados

A primeira entrada no arquivo `/etc/crontab`:

    17 *	* * *	root	cd / && run-parts --report /etc/cron.hourly

Nesse caso, executa em todo minuto 17, em todas as horas, em todos os dias do mês, todo mês, todos os dias da semana, o que estiver dentro de `/etc/cron.hourly`. A execução de todos os arquivos se deve ao programa `run-parts`.

A sintaxe dos crontabs de sistema é semelhante à dos crontabs de usuário, porém ela requer um campo adicional obrigatório que especifica **qual usuário executará o cron job**. Portanto, cada linha em um crontab de sistema contém sete campos separados por um espaço:

-   O minuto da hora (0-59).
-   A hora do dia (0-23).
-   O dia do mês (1-31).
-   O mês do ano (1-12).
-   O dia da semana (0-7 com Domingo=0 ou Domingo=7).
-   O nome da conta de usuário a ser usada ao executar o comando.
-   O comando a executar.
    
Quanto aos crontabs do usuário, podemos especificar mais de um valor nos campos de tempo usando os operadores  `*`,  `,`  ,  `-`  e  `/`. Também é possível indicar o mês do ano e o dia da semana com as três primeiras letras do nome em vez do número correspondente.

- **crontab de sistema**: `/etc/crontab` e `/etc/cron.d`
	- `/etc/cron.hourly` (de hora em hora)
	- `/etc/cron.daily` (diariamente)
	- `/etc/cron.weekly` (semanalmente)
	- `/etc/cron.monthly` (mensalmente)
- **crontab de usuário**: `/var/spool/cron`

>[!WARNING]
>
>Algumas distribuições usam `/etc/cron.d/hourly`, `/etc/cron.d/daily`, `/etc/cron.d/weekly` e `/etc/cron.d/monthly`. Lembre-se de sempre conferir os diretórios corretos nos quais colocar os scripts que o cron deve executar.

### Especificações de tempo particulares

Ao editar os arquivos crontab, podemos usar atalhos especiais nas primeiras cinco colunas em vez das especificações de tempo:

- `@reboot`: roda a tarefa especificada uma vez após a reinicialização.
- `@hourly`: roda a tarefa especificada uma vez por hora no início da hora.
- `@daily`  (ou  `@midnight`): roda a tarefa especificada uma vez por dia à meia-noite.
- `@weekly`: roda a tarefa especificada uma vez por semana, à meia-noite de domingo.
- `@monthly`: roda a tarefa especificada uma vez por mês, à meia-noite do primeiro dia do mês.
- `@yearly`  (ou  `@annually`): roda a tarefa especificada uma vez por ano, à meia-noite de 1º de janeiro.

**Exemplos**

-   **`@reboot`**
    -   Executa a tarefa apenas uma vez, sempre que o sistema é inicializado.
    -   Exemplo:
        ```
        bash
        
        Copiar código
        
        `@reboot /path/to/script.sh` 
        ```
        
        Uso comum: Iniciar serviços personalizados ou scripts após reiniciar o servidor.
        
-   **`@hourly`**
    -   Executa a tarefa uma vez por hora, no minuto 0.
    -   Equivalente a:
        ```
        `0 * * * *` 
        ```
    -   Exemplo:
        ```
        bash
        
        `@hourly /path/to/script.sh` 
        ```
        
-   **`@daily` (ou `@midnight`)**
    
    -   Executa a tarefa uma vez por dia, à meia-noite.
    -   Equivalente a:
        ```
        `0 0 * * *` 
        ```
    -   Exemplo:
        ```
        bash
        
        `@daily /path/to/script.sh` 
        ```
        
-   **`@weekly`**
    
    -   Executa a tarefa uma vez por semana, no primeiro minuto do domingo.
    -   Equivalente a:
        ```
        `0 0 * * 0` 
        ```
    -   Exemplo:
        ```
        bash
        
        `@weekly /path/to/script.sh` 
        ```
        
-   **`@monthly`**
    
    -   Executa a tarefa uma vez por mês, no primeiro minuto do primeiro dia.
    -   Equivalente a:
        ```
        `0 0 1 * *` 
        ```
    -   Exemplo:
        ```
        bash
        
        `@monthly /path/to/script.sh` 
        ```
        
-   **`@yearly` (ou `@annually`)**
    
    -   Executa a tarefa uma vez por ano, no primeiro minuto do primeiro dia do ano.
    -   Equivalente a:
        ```
        `0 0 1 1 *` 
        ```
    -   Exemplo:
	   ```
        bash
        
        `@yearly /path/to/script.sh`
	```

#### Variáveis no crontab

Dentro de um arquivo crontab, pode haver atribuições de variáveis definidas antes que as tarefas agendadas sejam declaradas. As variáveis de ambiente comumente definidas são:

- `HOME`: o diretório no qual o  `cron`  invoca os comandos (por padrão, o diretório inicial do usuário).
- `MAILTO`: o nome do usuário ou o endereço para o qual a saída e o erro padrão são enviados (por padrão, o proprietário do crontab). Diversos valores separados por vírgulas também são permitidos, e um valor vazio indica que nenhum email deve ser enviado.
- `PATH`: o caminho no qual os comandos podem ser encontrados.
- `SHELL`: o shell a ser usado (por padrão  `/bin/sh`).

No `crontab`, variáveis como `HOME`, `MAILTO`, `PATH`, e `SHELL` são usadas para definir o ambiente no qual os comandos serão executados. Aqui está uma explicação detalhada e exemplos para cada uma:

---

### 1. **`HOME`**
   - Define o diretório de trabalho padrão para os comandos executados pelo `crontab`.
   - Se não for especificado, o valor padrão geralmente é o diretório home do usuário que criou o crontab.
   - Exemplo:
     ```bash
     HOME=/home/usuario
     @daily /path/to/script.sh
     ```
     Aqui, o script será executado com `/home/usuario` como diretório de trabalho.

---

### 2. **`MAILTO`**
   - Define o endereço de email para o qual serão enviados os logs de saída e erros dos comandos executados.
   - Se definido como vazio (`MAILTO=""`), o email não será enviado.
   - Exemplo:
     ```bash
     MAILTO=admin@exemplo.com
     @hourly /path/to/script.sh
     ```
     Aqui, os logs da execução do script serão enviados para `admin@exemplo.com`.

---

### 3. **`PATH`**
   - Define os diretórios onde o `crontab` buscará os comandos executados.
   - Por padrão, o `PATH` do cron é mais restrito que o de um shell interativo, frequentemente algo como `/usr/bin:/bin`.
   - Exemplo:
     ```bash
     PATH=/usr/local/bin:/usr/bin:/bin
     @daily script.sh
     ```
     Aqui, o cron poderá localizar `script.sh` se ele estiver em qualquer um dos diretórios especificados.

---

### 4. **`SHELL`**
   - Define qual shell será usado para executar os comandos.
   - O valor padrão geralmente é `/bin/sh`.
   - Exemplo:
     ```bash
     SHELL=/bin/bash
     @reboot /path/to/script.sh
     ```
     Aqui, o script será executado usando o Bash em vez do shell padrão.

---

### Exemplo Completo
```bash
SHELL=/bin/bash
HOME=/home/usuario
MAILTO=admin@exemplo.com
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin

@hourly /home/usuario/scripts/backup.sh
@daily /home/usuario/scripts/limpeza.sh
```

### O que acontece aqui:
1. O `backup.sh` será executado a cada hora.
2. O `limpeza.sh` será executado diariamente.
3. Os logs dessas tarefas serão enviados para o email `admin@exemplo.com`.
4. Os comandos serão executados no diretório `/home/usuario` usando o Bash.

---

### Dicas Adicionais
- Se seus scripts dependem de variáveis de ambiente específicas (como `JAVA_HOME`), você pode defini-las no início do arquivo `crontab`.
- Teste seus comandos ou scripts manualmente para evitar problemas de execução devido a configurações de ambiente no cron. 

### uso interessante para o dia a dia

    @daily /path/to/script.sh >> /var/log/script.log 2>&1
    
Executa diariamente o script script.sh e joga a saída de sucesso ou de erro no arquivo script.log (2>&1 indica para jogar as duas saídas no arquivo script.log)

Outro exemplo interessante, executar o script  `barfoo.sh`  localizado no diretório  `/root`  todos os dias à 01:30, abra  `/etc/crontab`  com seu editor preferido e adicione a seguinte linha:

    30 01 * * * root /root/barfoo.sh >>/root/output.log 2>>/root/error.log

No exemplo acima, a saída do job é anexada a  `/root/output.log`, enquanto os erros são anexados a  `/root/error.log` (`2>` é a saída padrão para erro, usando `2>>` vai concatenar os valores).

>[!WARNING]
>
>Exceto nos casos em que a saída é redirecionada para um arquivo, como no exemplo acima (ou se a variável `MAILTO` estiver definida como um valor em branco), toda a saída de um trabalho cron será enviada ao usuário via email. Uma prática comum é redirecionar a saída padrão para `/dev/null` (ou para um arquivo, para revisão posterior, se necessário) e não redirecionar o erro padrão. Desta forma, o usuário é notificado imediatamente por email sobre eventuais erros.

### Cron para usuários

Para listar os agendamentos do seu usuário: `contrab -l -u rodrigo`. Se tentar listar agendamentos de outro usuário, se deparará com a mensagem que a opção `-u` deve ser com usuário privilegiado (root ou usuário com privilégio de root).

    must be privileged to use -u

- `crontab -e`: entra no modo de edição do crontab. (primeiro acesso lhe pergunta qual editor que usa). O formato é parecedo com o crontab que foi visto anteriormente, apenas com a exceção que não tem o campo de usuário.

Vejamos um exemplo:<br>

    #m	h	dia	mes	diasemana	comando/script
    15	13	1,10,20,30	* 1-5	/home/rodrigo/Scripts/script.sh >> /tmp/teste-cron.txt

Acima temos:<br>
nos dias 1,10,20,30 às 13h15m, em todo/qualquer mês (`*`), de segunda à sexta-feira (1=segunda, 5=sexta-feira), execute o script em `/home/rodrigo/Scripts/script.sh` e grava a saída do `script.sh` no arquivo `/tmp/teste-cron.txt`<br>
**Observação**: se os dias 1, 10, 20, ou 30 caírem em um sábado ou domingo, o script.sh não vai rodar.

Outro exemplo:

    #m		h	dia		mes	diasemana	comando/script
    */10	*	*		* 	*			/ cd /tmp ; rm -f teste

Nesse caso, a cada 10 minutos o comando será executado. (A `/` significa **a cada**). Se usar `*/5` no dia, seria a cada 5 dias, etc

Mais um exemplo para ilustrar:

    #m		h	dia		mes	diasemana	comando/script
	0		0	1		1	* /usr/bin/fogo-artificio.sh

No dia 1 de Janeiro, de todo ano, às meia noite (hora = 0 e minuto = 0), executa o script `fogos-artificio.sh`

Exemplo com range:<br>

    #m		h		dia		mes	diasemana	comando/script
    20		9-18	*		*	1-5 		/home/usuario/relatorio.sh

Em todo minuto 20, das horas entre 9h e 18h (horário comercial), qualquer dia, qualquer mês, de segunda à sexta-feira, executa o script `relatorio.sh`<br>
Observação: Lembrando que isso é referente ao usuário atual, e os scripts precisam ter permissão de execução.

- `crontab -r`: remove toda configuração do crontab.
- `# crontab -r -u lpi2`: (só root pode) remover crontab de outro usuário
- `crontab -u`: especifica o nome do usuário cujo crontab precisa ser modificado. Esta opção requer privilégios de root e permite que o usuário root edite os arquivos crontab do usuário.

Há possibilidade de criar um arquivo separado contendo as regras da crontab, e importar com o comando: `crontab arquivo_com_contrab`. Confirme com `contrab -l`

Essas modificações, tanto em sistema (`/etc/cron`) como a de usuário, são permanentes, e o(s) arquivo(s) do(s) usuário(s) fica(m) em `/var/spool/cron/crontabs` (precisa ser acesso como **root**). Em algumas distros pode ser que o diretório `crontabs` seja apenas `cron`.

Usuário root pode determinar quem pode e quem não pode utilizar crontab. Isso se baseia nos arquivos:
- /etc/cron.allow ou
- /etc/cron.deny

*Pode ser que esses arquivos não existam, sendo necessário criá-los. A lista de usuários é comum, linha a linha. O `cron.allow` tem prioridade em cima do `cron.deny` (caso tenha os mesmos usuários nas duas listas.

>[!NOTE]
>
>Há uma diferença no comportamento dos arquivos  **/etc/cron.allow**  e  **/etc/cron.deny**  entre sistemas baseados em Debian e RedHat.<br>
No Debian, e distribuições baseadas como o Ubuntu que usamos nesse curso, se ambos arquivos não existem, o uso dos recursos da cron é liberado para todos os usuários.<br>
No entanto, em sistemas baseados em RedHat, como o CentOS, na inexistência dos arquivos, o uso é bloqueado a todos os usuários, exceto para o usuário root.

#### Exercício interessante no lpi.org

Crie um job agendado simples que execute o comando  `date`  todas as sextas-feiras às 13h. Onde você poderia ver o resultado deste trabalho?

    00 13 * * 5 date

A saída é enviada ao usuário; para visualizá-la, use o comando  `mail`(no caso, é possível ver a saída com esse comando, mas precisa ter o pacote **mailutils** instalado (`apt install mailutisl`)

#### Exercício com MAILTO

Como é possível enviar a saída e os erros do seu trabalho agendado para a conta de usuário  `emma`  via email? E como evitar o envio da saída padrão e erros por email?

Para enviar a saída padrão e o erro para  `emma`, definimos a variável de ambiente  `MAILTO`  em nosso arquivo  `crontab`  desta forma:

    MAILTO="emma"

Para dizer ao  `cron`  que nenhum email deve ser enviado, atribuímos um valor vazio à variável de ambiente  `MAILTO`.

    MAILTO=""

### at (agendamento de uma execução)

Tipo de agendamento em determinada hora/momento (executa apenas uma vez)

    at now +2hour
    at> echo "Hora cafe"

Executa o echo `"Hora do café"` daqui duas horas, e poderia ir adicionando comandos. No final use `Ctrl+D` para adicionar essa tarefa (job).<br>
**(Como no caso do `cron`, a saída padrão e o erro são enviados por email)<br>
***Observe que o daemon `atd` precisará estar rodando no sistema para ser possível usar o agendamento de tarefas `at`

>[!NOTE]
>
>No Linux, o comando `batch` é semelhante a `at`, porém os jobs `batch` são executados apenas quando a carga do sistema está baixa o suficiente para permiti-lo.

- `atq` ou `at -l`: mostra os jobs que estão aguardando (vem de `queue`).

>[!NOTE]
>
>Se você executar `atq` como root, ele exibirá os trabalhos na fila para todos os usuários.

```
at 13:20
at> echo "Hora do almoço
```

Executa o echo às `13:20`. Caso já tenha passado esse horário, o at agenda para o dia seguinte. (para especificar quando um job `at` determinado deve ser executado, use o formato `HH:MM`, seguido opcionalmente por **AM** ou **PM** no caso do formato de 12 horas)

Formatos aceitos para passar uma data após a hora:
- `MMDDYY`
- `MM/DD/YY`
- `DD.MM.YY` e
- `YYYY-MM-DD`

- `at midnight`: agenda para meia noite
- `at teatime`: agenda para às 16h ou 4PM (hora do chá)
- `at noon`: agenda para hora do almoço - meio-dia
- `now`: para agora

- `at 02:20pm 05202024`: agenda para dia 20/05/2024 às 14:20

Para **remover** algum job feito pelo at: `atrm 10` ou `at -d 10`: remove o job 10.

>[!NOTE]
>
>O usuário que rodar `atrm` como root pode excluir os jobs de todos os outros usuários.

- `/etc/at.allow`: permite quais usuário usar o `at`
- `/etc/at.deny`: nega quais usuário a usar o `at` (esse já vem criado, preenchido com usuários do sistema, permitindo somente usuários comuns utilizar)

**As opções mais importantes do comando**  `at`  são:

- `-c`: imprime os comandos de um ID de trabalho específico na saída padrão.
- `-d`: exclui trabalhos com base em seu ID de trabalho. É um alias para  `atrm`.
- `-f`: lê o job em um arquivo em vez da entrada padrão.
- `-l`: lista as tarefas pendentes do usuário. Se o usuário for root, todos os trabalhos de todos os usuários serão listados. É um alias para  `atq`.
- `-m`: envia um email para o usuário no final do trabalho, mesmo se não houver saída.
- `-q`: especifica uma fila na forma de uma única letra de  `a`  a  `z`  e de  `A`  a  `Z`  (por padrão,  `a`  para  `at`  e  `b`  para  `batch`). Os jobs nas filas com as letras mais altas são executados com um valor nice maior. Os jobs enviados a uma fila com uma letra maiúscula são tratados como trabalhos em lote (`batch`).
- `-v`: mostra a hora em que o trabalho será executado antes de ler o trabalho.

Leia o arquivo `timespec` na árvore `/usr/share` para saber mais sobre a definição exata das especificações de data e hora.

#### Agendamento de Tarefas - systemd timer

- `systemct list-timers`: lista os agendamentos que já estão no sistema, no caso `UNITs`, com sufixo  (terminam com)`.timer`, ligadas às `ACTIVATES`, com sufixo (terminam com) `.service` (Por padrão, um `timer` ativa um serviço com o mesmo nome, exceto pelo sufixo).
- `systemct list-timers --all`: mostra agendamentos que possam estar inativas
- `systemctl list-units --type=timer`: lista as unidades do tipo `timer`

Para observar uma unit, é possível pode meio do comando:<br>
- `systemct list-timers`

```
$ systemctl status apt-daily-upgrade.timer 
● apt-daily-upgrade.timer - Daily apt upgrade and clean activities
     Loaded: loaded (/usr/lib/systemd/system/apt-daily-upgrade.timer; enabled; preset: enabled)
     Active: active (waiting) since Fri 2024-11-08 16:41:52 -03; 5 days ago
    Trigger: Fri 2024-11-15 06:13:26 -03; 16h left
   Triggers: ● apt-daily-upgrade.service

Nov 08 16:41:52 OptiPlex-3080 systemd[1]: Started apt-daily-upgrade.timer - Daily apt upgrade and clean activities.
```

Na terceira linha, é mostrado onde está configurado o `.timer`, no caso: `/usr/lib/systemd/system/apt-daily-upgrade.timer`(esse arquivo que seria alterado para definir novo agendamento). Sendo em um formato normal de unit, com sua descrição, e demais itens.

O que é interessante é a parte de `[Timer]`, onde tem a opção `onCalendar`, com a seguinte sintaxe:
- `OnCalendar= *-*-* 6:00`: sendo qualquer ano (*), qualquer mês (*), qualquer dia (*) às 6 horas.
- `OnCalendar= *-*-* 6..18:00,30 `: sendo qualquer ano (*), qualquer mês (*), qualquer dia (*) das 6 até às 18h, no minuto 00 e minuto 30. Se preferir, pode adicionar dois pontos (`:`) e informar os segundos, ou `*` para qualquer segundo.
- `OnCalendar=Mon..Fri *-*-* 6:00`: caso queira colocar de segunda à sexta-feira (entre dois valores para indicar um intervalo contíguo)
- `OnCalendar=Sat,Sun *-*-* 6:00`: caso queira colocar sábado e domingo (padrão para **Debian** e derivados - **RedHat** seria `Mon-Fri`)

- `RandomizedDelaySec=60m`: nessa faixa de 60 minutos, a execução pode fica aleatória dentro desse tempo, para que não tenha várias coisas executando ao mesmo tempo, achando um gap melhor para essa execução.
- `Persistend=true`: grava caso o `.service` seja executado manualmente. E considera essa informação para a próxima execução.

Na Unit do `.service`, é basicamente um `.service` comum, que é descrito o que será executado no `ExecStart`.<br>
Mais detalhes em `man systemd.timer`. Mais detalhes de como especificar a data e hora no calendar, usar: `man systemd.time`

Vejamos o exemplo de `systemd-tmpfiles-clean.timer`:<br:
- executa `systemctl status systemd-tmpfiles-clean.timer` para saber onde está carregado esse arquivo, no caso é em `/usr/lib/systemd/system/systemd-tmpfiles-clean.timer`, tendo como conteúdo:
```
[Unit]
Description=Daily Cleanup of Temporary Directories
Documentation=man:tmpfiles.d(5) man:systemd-tmpfiles(8)
ConditionPathExists=!/etc/initrd-release

[Timer]
OnBootSec=15min
OnUnitActiveSec=1d
```
Em `OnUnitActiveSec`, é informado que se a unidade estiver ativa, para executar o serviço a cada 1 dia. Em `OnBootSec` é nítido que será executado após 15 minutos. Isso é para casos que o sistema não é desligado.

**Outro exemplo interessante listado nas lições da lpi.org**

Por exemplo, para rodar o serviço  `/etc/systemd/system/foobar.service`  às 05:30 da primeira segunda-feira do mês, adicionamos as seguintes linhas no arquivo de unidade  `/etc/systemd/system/foobar.timer`  correspondente:

    [Unit]
    Description=Run the foobar service
    
    [Timer]
    OnCalendar=Mon *-*-1..7 05:30:00
    Persistent=true
    
    [Install]
    WantedBy=timers.target

Depois de criar o novo temporizador, você pode ativá-lo e iniciá-lo executando os seguintes comandos como root:

    # **systemctl enable foobar.timer**
    # **systemctl start foobar.timer**

Podemos alterar a frequência do trabalho agendado modificando o valor  `OnCalendar`  e, em seguida, digitando o comando  `systemctl daemon-reload`.

Finalmente, se você quiser ver a lista de temporizadores ativos ordenados pelo momento em que terminam, use o comando  `systemctl list-timers`. A opção  `--all`  exibe também as unidades de temporizador inativas.

>[!NOTE]
>
>Lembre-se de que os temporizadores são registrados no diário (journal) do systemd e você pode rever os registros das diferentes unidades usando o comando  `journalctl`. Além disso, se estiver trabalhando como um usuário comum, será preciso usar a opção  `--user`  dos comandos  `systemctl`  e  `journalctl`.

##### Criando um agendamento

1. criar um **serviço**, dentro de `/etc/systemd/system`:
	1.1 usar `vim exemplo.servce`
```
[Unit]
Description=Exemplo systemd-timer

[Service]
Type=oneshot
ExecStart=/bin/sh -c '/bin/date >> /tmp/exemplo-system.txt'
```

2. criar um **timer**, dentro de `/etc/systemd/system`:
	2.1 usar `vim exemplo.timer` (usar o mesmo nome, mudando só o final)
```
[Unit]
Description=Teste de systemd

[Timer]
OnCalendar=*-*-* *:*:10 # toda hora, todo min, no segundo 10

AccuracySec=1us # 1 micro segundo ou 1ms, que é a margem para executar com precisão. Se for muito alto, lembrar que tem prioridade.

Unit=teste.service
```

No `OnCalendar`, pode informar só a hora: `OnCalendar=*:*:10`<br>
No `AccuracySec` lembrar da prioridade, se colocar tempo muito alto e se estiver tendo muita execução, vai utilizar um tempo random dentro do intervalo colocado

Se rodar `systemctl list-timer`, o timer feito não aparece. Portanto é preciso iniciar o timer criado: `systemctl start exemplo.timer`. Executando novamente `systemctl list-timer`, já vai aparecer na lista. É interessante também recarregar as informações do daemon do systemctl, com o comando `systemctl daemon-reload`

Em vez da forma normalizada mais longa mencionada acima, é possível usar algumas expressões especiais que descrevem frequências específicas para a execução de um job:

- `hourly`: roda a tarefa especificada uma vez por hora, no início da hora.
- `daily`: roda a tarefa especificada uma vez por dia à meia-noite.
- `weekly`: roda a tarefa especificada uma vez por semana, na meia-noite de segunda-feira.
- `monthly`: roda a tarefa especificada uma vez por mês, na meia-noite do primeiro dia do mês.
- `yearly`: roda a tarefa especificada uma vez por ano, na meia-noite de 1º de janeiro.

Consulte as páginas de manual para ver a lista completa de especificações de hora e data em  `systemd.timer(5)`.

No **`systemd`**, os **timers** substituem ou complementam o uso do `cron` para agendamento de tarefas, proporcionando maior flexibilidade e integração com o sistema. Aqui estão os equivalentes aos atalhos do `crontab` usando **`systemd.timer`**:

---

### Estrutura de um Timer no `systemd`
Um timer no `systemd` geralmente é composto por dois arquivos:

1. **Arquivo de Serviço (`.service`)**
   - Define o que será executado.
2. **Arquivo de Timer (`.timer`)**
   - Define quando será executado.

---

### Equivalentes no `systemd.timer`
Os timers no `systemd` usam o campo `[Timer]` para configurar os intervalos de execução. Aqui estão os exemplos:

1. **`@reboot` (ao iniciar o sistema)**
   - Use o parâmetro **`OnBootSec`** no arquivo `.timer`.
   - Exemplo:
     ```ini
     [Timer]
     OnBootSec=1min
     ```
     Este timer executará a tarefa 1 minuto após o sistema inicializar.

2. **`@hourly` (uma vez por hora)**
   - Use **`OnCalendar`** com o valor `hourly`.
   - Exemplo:
     ```ini
     [Timer]
     OnCalendar=hourly
     ```
     Este timer será acionado no início de cada hora.

3. **`@daily` (uma vez por dia, à meia-noite)**
   - Use **`OnCalendar`** com o valor `daily`.
   - Exemplo:
     ```ini
     [Timer]
     OnCalendar=daily
     ```
     O timer será acionado diariamente à meia-noite.

4. **`@weekly` (uma vez por semana, no domingo)**
   - Use **`OnCalendar`** com o valor `weekly`.
   - Exemplo:
     ```ini
     [Timer]
     OnCalendar=weekly
     ```
     O timer será acionado no primeiro minuto de cada domingo.

5. **`@monthly` (uma vez por mês, no primeiro dia)**
   - Use **`OnCalendar`** com o valor `monthly`.
   - Exemplo:
     ```ini
     [Timer]
     OnCalendar=monthly
     ```
     O timer será acionado no primeiro minuto do dia 1 de cada mês.

6. **`@yearly` (ou `@annually`)**
   - Use **`OnCalendar`** com o valor `yearly`.
   - Exemplo:
     ```ini
     [Timer]
     OnCalendar=yearly
     ```
     O timer será acionado no primeiro minuto do primeiro dia de cada ano.

---

### Exemplo Completo
Aqui está um exemplo completo para criar um serviço e um timer que executam um script diariamente.

### Arquivo de Serviço (`exemplo.service`)
```ini
[Unit]
Description=Executa o script de exemplo

[Service]
ExecStart=/path/to/script.sh
```

### Arquivo de Timer (`exemplo.timer`)
```ini
[Unit]
Description=Executa o script de exemplo diariamente

[Timer]
OnCalendar=daily

[Install]
WantedBy=timers.target
```

#### Comandos para Ativar
1. Coloque os arquivos em `/etc/systemd/system/`.
2. Habilite o timer:
   ```bash
   sudo systemctl enable exemplo.timer
   ```
3. Inicie o timer:
   ```bash
   sudo systemctl start exemplo.timer
   ```

---

### Vantagens do `systemd.timer`
- Integração nativa com o `systemd` (logs em `journalctl`).
- Opções adicionais, como **`AccuracySec`** (ajustar precisão) e **`Persistent`** (executar tarefas perdidas durante períodos de inatividade).

Isso torna o `systemd` uma alternativa poderosa ao `cron` para tarefas agendadas! 

##### systemd-run (equivalente ao at)

Normalmente ele é usado para criar uma unidade transiente de temporizador para que um comando seja executado em um momento específico sem a necessidade de se criar um arquivo de serviço

Por exemplo, atuando como root, você pode executar o comando  `date`  às 11h30 em 06/10/2019 usando o seguinte:

    # **systemd-run --on-calendar='2019-10-06 11:30' date**

Se quiser executar o script  `foo.sh`, localizado em seu diretório atual, depois de dois minutos, use:

    # **systemd-run --on-active="2m" ./foo.sh**

- `system-run --on-active=60s /bin/touch /tmp/exemplo-run.txt`: roda após **60 segundos** o comando `touch` que criar o arquivo `exemplo-run.txt` em `/tmp`
- `system-run --on-active=60s --time-property=AccuracySec=1ms /bin/touch /tmp/exemplo-run.txt`: faz o mesmo do comando anterior, mas em system-run também tem a questão de prioridade, e se quiser com precisão, precisar incluir o argumento `--time-property`

É possível observar que após rodar o `system-run` acima, será retornado um run, que no caso é algo parecido com isso: `run-sequecia-caracteres.timer`

Se pegar esse `.timer` e olhar no `journalctl`, com a opção `-u` `--unit`, mais o `run` (`journalctl -u run-sequecia-caracteres.timer`), é possível notar que já está rodando (mas o comando ainda não foi executado - lembre-se, foi configurado para 60 segundos).

Se olhar no `systemctl list-timers` o `run-sequecia-caracteres.timer` que foi criado, vai estar listado, mostrando quanto tempo falta para sua hora de executar.

Depois que passar os 60 segundos, ele irá executar, e **não** irá mais aparecer no `systemctl list-timers`. Mostrando que fez 1 execução apenas. É possível ter certeza verificando o .service dele, com o comando `journalctl -u run-sequecia-caracteres.service`

Consulte as páginas de manual para aprender todos os usos possíveis de  `systemd-run`  com  `systemd-run(1)`.

>[!NOTE]
>
>Os temporizadores são registrados no diário do systemd e você pode rever os registros das diferentes unidades usando o comando `journalctl`. Além disso, se estiver trabalhando como um usuário comum, precisará usar a opção `--user` dos comandos `systemctl` e `journalctl`.

## 107.3 Localização e internacionalização

Para o Linux, o horário padrão é o UTC (Tempo Universal Coordenado). O UTC substituiu o GMT (Greenwich Meridian Time) ou Z (Zulu), que se baseava na hora local de Greenwich. Depois disso ele pega e converte para o que foi configurado de acordo com a localização.

- `timedatectl`: (disponível em distribuições que usam o `systemd`) é um date melhorado, mais completo, que descreve a **data/hora** em diferentes formatos (embora o `date` também mostre o deslocamento em relação a UTC.)

Tudo isso fica configurado em `/etc/localtime` (é um arquivo que não tem como ler, nele fica configurado a questão do **timezone**, horário de verão - **daylight saving time**). Lembrando que `/etc/localtime` aponta para `/usr/share/zoneinfo/America/Sao_Paulo` (a depender da sua localização).

    ls -l /etc/localtime 
    lrwxrwxrwx 1 root root 37 Nov  8 16:21 /etc/localtime -> /usr/share/zoneinfo/America/Sao_Paulo

Vendo em `/usr/share/zoneinfo/Brazil` é possível notar onde `/etc/localtime` está apontando:

    ls -l /usr/share/zoneinfo/Brazil/
    total 0
    lrwxrwxrwx 1 root root 21 Nov  8 16:20 Acre -> ../America/Rio_Branco
    lrwxrwxrwx 1 root root 18 Nov  8 16:20 DeNoronha -> ../America/Noronha
    lrwxrwxrwx 1 root root 20 Nov  8 16:20 East -> ../America/Sao_Paulo
    lrwxrwxrwx 1 root root 17 Nov  8 16:20 West -> ../America/Manaus

Em `/etc/timezone` está contido o fuso horário padrão padrão do sistema: (se der um `cat` nesse arquivo, retorna `America/Sao_Paulo`)

Os nomes genéricos de fusos horários indicados pela diferença em relação a UTC devem incluir  `Etc`  na primeira parte do nome. Assim, para definir o fuso horário padrão como GMT+3, o nome do fuso horário deve ser  `Etc/GMT+3`:

    $ **cat /etc/timezone**
    Etc/GMT+3

- `tzselect`: usado para ajudar a selecionar o **timezone** correto/desejado. (Também é possível especificar o fuso horário com coordenadas geográficas ou com a notação de deslocamento, também conhecida como _formato Posix TZ_)

Para alterar o timezone apenas da sessão atual, pode-se alterar a variável `$TZ`:<br>

    - export TZ=America/Chicago<br>

*Faça um date antes e depois de alterar o timezone para perceber as mudanças:<br>

    $ date
    Mon Nov 18 20:22:49 AM -03 2024
    $ export TZ=America/Los_Angeles
    $ date
    Mon Nov 18 15:23:05 AM PST 2024

*Lembrando que isso apenas está traduzindo o que está internamente no UTC. Para voltar a data no timezone que estava antes, basta executar: `unset TZ`.

Ainda alterando o `TZ`, se criar um arquivo, a data de criação atualiza caso o `TZ` seja alterado. Isso se torna interessante quando há usuário de diferentes timezones, para que possa ajustar de acordo com a localização (ajustar no `.bashrc`, por exemplo - ou até mesmo para todos os usuário, em `/etc/profile`).

>[!NOTE]
>
>Só o território brasileiro abrange quatro fusos horários.

A mudança por meio da variável prevalece a configuração em `/etc/localtime`. Podemos preencher da forma por extenso também:

    TZ=:/usr/share/zoneinfo/America/Sao_Paulo

Para alterar por meio do `/etc/localtime`, basta remover o link atual, e apontar para um novo (esse novo é possível consultar por meio das opções que há em `/usr/share/zoneinfo`)

    $ ls -l /etc/localtime
    /etc/localtime -> /usr/share/zoneinfo/America/Sao_Paulo
    
    rm -f /etc/localtime
    
    ln -s /usr/share/zoneinfo/Asia/Bangkok /etc/localtime

Confirme as mudanças com os comandos `date` e `timedatectl`. As mudanças são refletidas de imediato.

Uma máquina conectada pode ser acessada de diferentes partes do mundo, de forma que é aconselhável definir o relógio do hardware para UTC (o fuso horário GMT+0) e deixar a escolha do fuso horário para cada caso particular. Os serviços em nuvem, por exemplo, costumam ser configurados para usar UTC, o que pode ajudar a mitigar eventuais inconsistências entre o horário local e o horário dos clientes ou de outros servidores. Por outro lado, os usuários que abrem uma sessão remota no servidor podem querer usar seu fuso horário local. Assim, caberá ao sistema operacional configurar o fuso horário correto de acordo com cada caso.

### Localização e Internacionalização - Idioma, Linguagem e Codificação

- `locale`: lista informações específicas de acordo com locais, países no mundo, tais como: sistema monetário, se usa vírgula ou ponto, formato de datas, etc, assim como o tipo de codificação de caracteres. (tudo isso são variáveis de ambiente - vide `env | grep "^LC"`, perceba que há uma chamada `LC_ALL`, que sobrescreve todas as demais).

É possível configurar pelo `.bashrc` ou `/etc/profile`, definindo diretamente as variáveis por sessão ou para todos os usuários, respectivamente.

Por exemplo, caso esteja utilizando o modelo brasileiro de representação dos números, em uma moeda, e queira mudar para o modelo dos Estados Unidos, use: `export  LC_AL=en_US.UTF-8`. Para remover, `unset LC_ALL`.

Ex. **en_US.UTF-8** ou **pt_BR.UTF-8** (codificação usada na instalação)

- `locale -a` (`--all-locales`): lista os modelos disponíveis para o uso.

### Conversão de codificação

O primeiro mais antigo é o ASCII (_American Standard Code for Information Interchange_), depois foi melhorado para ISO/IEC 8859-1, e UTF-8 é o mais recente/utilizado. Se escrever um arquivo com caracteres especiais no Windows, e abrir no Linux, vai haver divergência (lembrando que para verificar a codificação do arquivo, pode-se utilizar o comando `file nome_arquivo`)

- `iconv -f ISO-8859-1 -t UTF-8 nome_do_arquivo`: (`-f` ou `--from-code` e `-t` ou `--to-encode`) converte o arquivo, que antes estava na decodificação do Windows, para a codificação que o Linux entende. (para casos que um texto no Windows não leia no Linux)
Para listar todas as codificações suportadas pelo comando `iconv`, usamos o comando `iconv -l` ou `iconv --list`. Ao invés de usar o redirecionamento de saída, como no exemplo, a opção `-o converted.txt` ou `--output converted.txt` também faz o serviço.

#### Exercicio sobre iconv

Os caracteres dos arquivos de texto podem não ser exibidos corretamente em um sistema com uma codificação de caracteres diferente da usada na criação do documento de texto. Como o  `iconv`  pode ser usado para converter o arquivo  `old.txt`, codificado em WINDOWS-1252, no arquivo  `new.txt`, que usa a codificação UTF-8?

O comando  `iconv -f WINDOWS-1252 -t UTF-8 -o new.txt old.txt`  realizará a conversão desejada.


>[!TIP]
>
>O comando `localectl`, disponível em sistemas que empregam o _systemd_ como gerenciador de sistema, também pode ser usado para consultar e alterar a localidade do sistema. Por exemplo: `localectl set-locale LANG=en_US.UTF-8`.

Além da variável  `LANG`, outras variáveis de ambiente afetam aspectos específicos da localidade, como o símbolo monetário ou o separador de milhar correto para números:
- `LC_COLLATE`: define a ordem alfabética. Uma de suas finalidades é definir a ordem em que os arquivos e diretórios são listados.
- `LC_CTYPE`: define como o sistema tratará certos conjuntos de caracteres. Ele define, por exemplo, quais caracteres considerar como  _maiúsculas_  ou  _minúsculas_.
- `LC_MESSAGES`: define o idioma para exibir as mensagens de programas (principalmente programas do GNU).
- `LC_MONETARY`: define a unidade monetária e o formato da moeda.
- `LC_NUMERIC`: define o formato numérico para valores não-monetários. Sua finalidade principal é definir os separadores de milhar e decimais.
- `LC_TIME`: define o formato de hora e data.
- `LC_PAPER`: define o tamanho padrão do papel.
- `LC_ALL`: sobrepõe todas as outras variáveis, incluindo  `LANG`.

O comando  `locale`  mostra todas as variáveis definidas na configuração de localidade atual:

    $ **locale**
    LANG=pt_BR.UTF-8
    LC_CTYPE="pt_BR.UTF-8"
    LC_NUMERIC=pt_BR.UTF-8
    LC_TIME=pt_BR.UTF-8
    LC_COLLATE="pt_BR.UTF-8"
    LC_MONETARY=pt_BR.UTF-8
    LC_MESSAGES="pt_BR.UTF-8"
    LC_PAPER=pt_BR.UTF-8
    LC_NAME=pt_BR.UTF-8
    LC_ADDRESS=pt_BR.UTF-8
    LC_TELEPHONE=pt_BR.UTF-8
    LC_MEASUREMENT=pt_BR.UTF-8
    LC_IDENTIFICATION=pt_BR.UTF-8
    LC_ALL=

A única variável indefinida é  `LC_ALL`, que pode ser usada para substituir temporariamente todas as outras configurações locais. O exemplo a seguir mostra como o comando  `date` — sendo executado em um sistema configurado para a localidade  `pt_BR.UTF-8` — modifica sua saída de forma a cumprir a nova variável  `LC_ALL`:

    $ **date**
    seg out 21 10:45:21 -03 2019
    $ **env LC_ALL=en_US.UTF-8 date**
    Mon Oct 21 10:45:21 -03 2019

A modificação da variável `LC_ALL` fez com que ambas as abreviações de dia da semana e nome do mês fossem mostradas em inglês americano (`en_US`). Não é obrigatório, entretanto, definir a mesma localidade para todas as variáveis. É possível, por exemplo, ter a linguagem definida como `pt_BR` e o formato numérico (`LC_NUMERIC`) no padrão americano.

Algumas configurações de localização alteram a forma como os programas lidam com a ordem alfabética e formatos de numeração. Embora os programas convencionais geralmente sejam capazes de escolher corretamente uma localidade comum para essas situações, os scripts podem se comportar de forma inesperada ao tentar ordenar corretamente uma lista de itens em ordem alfabética, por exemplo. Por este motivo, recomenda-se definir a variável de ambiente `LANG` para a localidade comum `C`, como em `LANG=C`, para que o script produza resultados inequívocos, independentemente das definições de localização usadas no sistema onde é executado. A localidade C realiza apenas uma comparação simples de bytes e, portanto, também terá um desempenho melhor do que as outras.

## 108.1 Manutenção da data e hora do sistema

### Manutenção do Horário do Sistema - Relógios e os comandos date e hwclock

**hardware clock**: relógio da BIOS (aquela que usa bateria para armazenar data/hora)

**software clock**: relógio do Linux propriamente dito, depois que o SO sobe

Em linhas gerais, o hardware e software clock não são sincronizados pois são independentes. Isso fica nítido quando o computador está ligado por muito tempo.

- `date`: retorna a hora no sistema
- `date -u`: retorna data/hora UTC (GMT0)
- `date 12251200`: ajusta o relógio para 12 de dezembro às 12:00 (o ano é opcional). Opção com ano seria: `date 122512002024` (precisa ser como root).
- `date --set="11 Nov 2011 11:11:11"`: também redefine o horário. Neste caso, é necessário ter privilégios de root para definir a data. Também podemos optar por alterar a hora ou data independentemente:
```
    # date +%Y%m%d -s "20111125"
```
Aqui, devemos especificar as sequências para que nossa string seja analisada corretamente. Por exemplo,  `%Y`  refere-se ao ano e, portanto, os primeiros quatro dígitos  `2011`  serão interpretados como o ano de 2011. Da mesma forma,  `%T`  é a sequência de hora, como demonstrado aqui ao definirmos a hora (`-s` ou `--set`):
```
# date +%T -s "13:11:00"
```
Depois de alterar a hora do sistema, é recomendável também definir o relógio do hardware para que os relógios do sistema e do hardware estejam sincronizados:
```
# hwclock --systohc
```
Outras opções comumente usadas retornam a hora local em um formato RFC aceito:
- `-I`:  data/hora no formato ISO 8601. Anexar  `date`  (`-Idate`) limita a saída apenas à data. Outros formatos são  `hours`,  `minutes`,  `seconds`  e  `ns`  (para nanossegundos).
- `-R`:  retorna data e hora no formato RFC 5322.
- `--rfc-3339`:  retorna data e hora no formato RFC 3339.

O formato de  `date`  pode ser personalizado pelo usuário com as sequências especificadas na página de manual. Por exemplo, a hora atual pode ser formatada como tempo do Unix da seguinte maneira:

    $ date +%s
    1574014515

Na página de manual de  `date`, podemos ver que  `%s`  se refere ao tempo do Unix.

O tempo do Unix é usado internamente na maioria dos sistemas baseados em Unix. Ele armazena a hora UTC como o número de segundos desde a  _Época_, que foi definida como 1º de janeiro de 1970.

>[!NOTE]
>
>O número de bits necessários para armazenar a hora Unix no momento atual é de 32 bits. No futuro, 32 bits se tornarão insuficientes para conter a hora atual no formato Unix. Isso causará problemas sérios para qualquer sistema Linux de 32 bits. Felizmente, isso não ocorrerá até 19 de janeiro de 2038.

A opção  `--debug`  é muito útil para garantir que uma data possa ser analisada com sucesso. Observe o que acontece ao passarmos uma data válida para o comando:

    $ date --debug --date="Fri, 03 Jan 2020 14:00:17 -0500"
    date: parsed day part: Fri (day ordinal=0 number=5)
    date: parsed date part: (Y-M-D) 2020-01-03
    date: parsed time part: 14:00:17 UTC-05
    date: input timezone: parsed date/time string (-05)
    date: using specified time as starting value: '14:00:17'
    date: warning: day (Fri) ignored when explicit dates are given
    date: starting date/time: '(Y-M-D) 2020-01-03 14:00:17 TZ=-05'
    date: '(Y-M-D) 2020-01-03 14:00:17 TZ=-05' = 1578078017 epoch-seconds
    date: timezone: system default
    date: final: 1578078017.000000000 (epoch-seconds)
    date: final: (Y-M-D) 2020-01-03 19:00:17 (UTC)
    date: final: (Y-M-D) 2020-01-03 14:00:17 (UTC-05)

Essa é uma ferramenta útil para a resolução de problemas em um aplicativo que gera uma data.

- `hwclock` (`apt install util-linux-extra`): mostra o relógio do BIOS

O `hwclock` serve ainda para sincronizar o horário do sistema igual ao do horário do hardware, ou vice-versa.

- `hwclock -w` ou `--systohc` (**hc**=**hardware clock**): pega o horário do sistema e sincroniza com o relógio no BIOS: Sys->Bios
- `hwclock -s` ou `--hctosys`: faz o contrário, pega o horário do BIOS e sincroniza com o relógio do Linux: Bios->Sys

- `hwclock --set --date "12/25/2024 14:00"`: define o horário na BIOS<br>
**Na aula o comando acima retorna erro, formato inválido para a data. Procurando no man , o formato usado é: <br>
```
    sudo hwclock --set --date "YYYY-MM-DD HH:MM:SS"
```
- `hwclock  --verbose`: retorna mais resultados, que podem ser úteis para solucionar problemas. Observe o `Calculated Hardware Clock drift`. Esta saída informa se a hora do sistema e a hora do hardware estão divergindo uma da outra.

>[!NOTE]
>
>Para fins de logs, é utilizado o horário do sistema.

>[!NOTE]
>
>Alguns processos internos (principalmente em distros baseadas em Ubuntu), a hora é atualizada automaticamente.

- `timedatectl`  é um comando que pode ser usado para verificar o status geral de hora e data, incluindo se a hora da rede foi ou não sincronizada (na próxima lição, trataremos do Network Time Protocol).

Por padrão,  `timedatectl`  retorna informações semelhantes a  `date`, mas com a adição da hora RTC (hardware), bem como o status do serviço NTP:

    $ timedatectl
                   Local time: Thu 2019-12-05 11:08:05 EST
               Universal time: Thu 2019-12-05 16:08:05 UTC
                     RTC time: Thu 2019-12-05 16:08:05
                    Time zone: America/Toronto (EST, -0500)
    System clock synchronized: yes
                  NTP service: active
              RTC in local TZ: no

Se o NTP não estiver disponível, recomenda-se usar  `timedatectl`  em vez de  `date`  ou  `hwclock`  para definir a hora:

    # **timedatectl set-time '2011-11-25 14:00:00'**

O processo é semelhante ao de  `date`. O usuário também pode definir a hora independentemente da data com o formato **HH:MM:SS**

### Definindo o fuso horário com timedatectl

`timedatectl`  é a melhor maneira de configurar o fuso horário local nos sistemas Linux baseados em  `systemd`  quando não existe GUI.  `timedatectl`  lista os fusos horários possíveis e, a partir daí, o fuso horário pode ser definido usando um deles como argumento.

Primeiro, listamos os fusos horários possíveis:

    $ **timedatectl list-timezones**
    Africa/Abidjan
    Africa/Accra
    Africa/Algiers
    Africa/Bissau
    Africa/Cairo
    ...

A lista de fusos horários possíveis é longa, por isso o uso do comando  `grep`  é recomendado neste caso.

Em seguida, podemos definir o fuso horário usando um dos elementos da lista retornada:

    $ timedatectl set-timezone Africa/Cairo
    $ timedatectl
                   Local time: Thu 2019-12-05 18:18:10 EET
               Universal time: Thu 2019-12-05 16:18:10 UTC
                     RTC time: Thu 2019-12-05 16:18:10
                    Time zone: Africa/Cairo (EET, +0200)
    System clock synchronized: yes
                  NTP service: active
              RTC in local TZ: no

Lembre-se de que o nome do fuso horário deve ser exato.  `Africa/Cairo`, por exemplo, muda o fuso horário, mas  `cairo`  ou  `africa/cairo`  não.

### Desativando o NTP com timedatectl

Em alguns casos, pode ser necessário desativar o NTP. Podemos fazer isso com  `systemctl`, mas vamos demonstrar o procedimento com  `timedatectl`:

    # timedatectl set-ntp no
    $ timedatectl\
                 Local time: Thu 2019-12-05 18:19:04 EET Universal time: Thu 2019-12-05 16:19:04 UTC
                   RTC time: Thu 2019-12-05 16:19:04
                  Time zone: Africa/Cairo (EET, +0200)
                NTP enabled: no
           NTP synchronized: no
            RTC in local TZ: no
                 DST active: n/a

### Definindo o fuso horário sem timedatectl

A definição do fuso horário é uma etapa padrão ao se instalar o Linux em uma nova máquina. Se houver um processo de instalação gráfico, isso provavelmente será feito sem nenhuma ação adicional do usuário.

O diretório  `/usr/share/zoneinfo`  contém informações sobre os diferentes fusos horários possíveis. No diretório  `zoneinfo`, há subdiretórios com o nome dos continentes, bem como outros links simbólicos. Recomenda-se encontrar o  `zoneinfo`  da sua região começando por seu continente.

Os arquivos  `zoneinfo`  contêm as regras necessárias para calcular a diferença de horário local em relação a UTC e também são importantes se a sua região segue o horário de verão. O conteúdo de  `/etc/localtime`  será lido quando o Linux precisar determinar o fuso horário local. Para definir o fuso horário sem o uso de uma GUI, o usuário deve criar um link simbólico de  `/usr/share/zoneinfo`  para  `/etc/localtime`  informando sua localização. Por exemplo:

    $ **ln -s /usr/share/zoneinfo/Canada/Eastern /etc/localtime**

Depois de definir o fuso horário correto, recomenda-se executar:

    # **hwclock --systohc**

Isso configurará o  _relógio do hardware_  a partir do  _relógio do sistema_  (ou seja, o relógio em tempo real será configurado para a mesma hora que  `date`). Note que este comando é executado com privilégios de root; neste caso, você está logado como root.

`/etc/timezone`  é semelhante a  `/etc/localtime`. É uma representação de dados do fuso horário local e, como tal, pode ser lido usando  `cat`:

$ **cat /etc/timezone**
America/Toronto

Observe que este arquivo não é usado por todas as distribuições Linux.

### Configurando data e hora sem timedatectl

>[!NOTE]
>
>A maioria dos sistemas Linux modernos usa o  `systemd`  para sua configuração e serviços; assim, não é recomendado usar  `date`  ou  `hwclock`  para definir a hora. O  `systemd`  emprega para isso o  `timedatectl`. No entanto, é importante conhecer esses comandos legados no caso de você precisar administrar um sistema mais antigo.

**Exercício interessante Timezone**

Existe um local chamado  `eucla`. De que continente ele faz parte? Use o comando  `grep`  para descobrir.

`timedatectl list-timezones \| grep -i eucla`
ou
`grep -ri eucla /usr/share/zoneinfo`

Defina seu fuso horário atual para  `eucla`.

`timedatectl set-timezone 'Australia/Eucla'`
ou
`ln -s /usr/share/zoneinfo/Australia/Eucla /etc/localtime`

#### Protocolo NTP (Network Time Protocol)

Alguns desses termos aparecem nos comandos que usamos para rastrear o status do NTP em nossas máquinas:

- **Deslocamento (offset)**: Refere-se à diferença absoluta entre a hora do sistema e a hora NTP. Por exemplo, se o relógio do sistema marca 12:00:02 e o horário NTP é 11:59:58, o deslocamento entre os dois relógios é de quatro segundos.
- **Salto (step)**: Se o deslocamento de tempo entre o provedor NTP e um consumidor for maior que 128ms, o NTP executará uma única alteração significativa na hora do sistema, em vez de desacelerar ou acelerar o relógio do sistema. Isso é chamado de  _stepping_.
- **Ajuste gradativo (slew)**: Slew refere-se às alterações feitas na hora do sistema quando o deslocamento entre a hora do sistema e o NTP é menor que 128ms. Se esse for o caso, as alterações serão feitas gradualmente. Isso é conhecido como  _slewing_.
- **Relógio insano**: Se o deslocamento entre a hora do sistema e a hora NTP for maior que 17 minutos, o tempo do sistema é considerado  _insano_  e o daemon NTP não introduzirá nenhuma alteração no relógio do sistema. Será preciso tomar medidas especiais para trazer a hora do sistema até menos de 17 minutos da hora correta.
- **Escorregamento ou deslizamento (drift)**: O escorregamento se refere ao fenômeno em que dois relógios ficam fora de sincronia com o tempo. Essencialmente, se dois relógios são inicialmente sincronizados, mas vão ficando fora de sincronia com o passar do tempo, está ocorrendo um escorregamento do relógio.
- **Variação (jitter)**: A variação refere-se à quantidade de escorregamento desde a última vez em que um relógio foi consultado. Portanto, se a última sincronização com o NTP ocorreu há 17 minutos, e o deslocamento entre o provedor NTP e o consumidor é de 3 milissegundos, então 3 milissegundos é a variação.

Protocolo que usa a porta **123** via UDP (pode ser visto no arquivo `/etc/services`, que lista as portas)

Primeiro é preciso instalar os pacotes: `apt install ntp ntpdate`. Depois de instalador, pode verificar se o daemon do ntp está executando com o comando `ps axu | grep ntp`

O arquivo de configuração do NTP é `/etc/ntp.conf`. Dentro desse arquivo têm listado as pools com endereços NTP. Essas pools precedem da palavra reservada `pool` ou `server`.

- `ntpq -p`ou`--peers`: (é um utilitário para monitorar o status do NTP. Uma vez que o daemon NTP foi iniciado e configurado, usamos `ntpq` para verificar seu status) lista as pools (peers) com diversas estatísticas de cada pool ou server. Com `-n` não resolve os nomes, traz só os IPs. As colunas são:

- `remote`: nome do host do provedor NTP.
- `refid`:  ID de referência do provedor NTP.
- `st`: estrato do provedor.
- `when`: número de segundos desde a última consulta.
- `poll`: número de segundos entre as consultas.
- `reach`: ID de status para indicar se um servidor foi alcançado. As conexões bem-sucedidas aumentam este número em 1.
- `delay`: tempo em ms entre a consulta e a resposta do servidor.
- `offset`: tempo em ms entre a hora do sistema e a hora NTP.
- `jitter`: deslocamento em ms entre a hora do sistema e o NTP na última consulta.

`ntpq`  também inclui um modo interativo, que é acessado quando ele é executado sem opções ou argumentos. A opção  `?`  retorna uma lista de comandos reconhecidos pelo  `ntpq`.



- `ntpdate 3.pt.pool.ntp.org` (`apt install ntpsec-ntpdate -y`): vai até o NTP de Portugal e atualiza o horário (de acordo com NTP de Portugal)<br>
**O comando acima não altera para o horário de Portugal, na realidade vai pegar o horário de lá, e de acordo com as configurações de timezone do sistema, vai ajustar de acordo com o timezone.

- `ntpdate -q 3.pt.pool.ntp.org`: (`-q` ou `--query`): consulta se o servidor está funcionando.

Durante a configuração inicial, a hora do sistema e o NTP podem ser seriamente dessincronizados. Se o  _deslocamento_  entre o sistema e a hora NTP for maior que 17 minutos, o daemon NTP não fará alterações na hora do sistema. Neste caso, será necessária uma intervenção manual.

Primeiramente, se  `ntpd`  estiver rodando, será necessário  _interromper_  o serviço. Use  `systemctl stop ntpd`  para fazer isso.

Em seguida, use  `ntpdate pool.ntp.org`  para realizar uma sincronização inicial única, onde  `pool.ntp.org`  se refere ao endereço IP ou URL de um servidor NTP. Pode ser necessária mais de uma sincronização.

#### chrony e timedatect

- **chrony**: funciona melhor em ambientes instáveis. Precisa instalar: `apt install chrony`. Confirmar com `ps axu | grep chrony` e `systemctl status chrony`.

O arquivo de configuração ficam `/etc/chrony/chrony.conf`, podendo ainda usar igual ao ntp, com a palavra `pool` ou `server` para indicar o servidor a ser consultado

#### chronyc (é o cli do chrony)

- `chrony` é outra forma de implementar o NTP. Ele é instalado por padrão em alguns sistemas Linux, mas está disponível para download em todas as principais distribuições. 
- `chronyd` é o daemon chrony e `chronyc` é a interface de linha de comando
---
- `chronyc tracking`: fornece informações sobre o NTP e a hora do sistema que está configurado (vê um status geral)
Essa saída contém muitas informações, mais do que as que estão disponíveis em outras implementações.

- `Reference ID`: O ID de referência e o nome ao qual o computador está sincronizado no momento.
- `Stratum`: Número de passos até um computador com um relógio de referência anexado.
- `Ref time`: Esta é a hora UTC em que a última medição da fonte de referência foi feita.
- `System time`: Atraso do relógio do sistema do servidor sincronizado.
- `Last offset`: Deslocamento estimado da última atualização do relógio.
- `RMS offset`: Média de longo prazo do valor do deslocamento.
- `Frequency`: Esta é a taxa na qual o relógio do sistema estaria errado se o chronyd não o estivesse corrigindo. É fornecida em ppm (partes por milhão).
- `Residual freq`: Frequência residual indicando a diferença entre as medições da fonte de referência e a frequência atualmente sendo usada.
- `Skew`: Limite de erro estimado da frequência.
- `Root delay`: Total de atrasos do caminho de rede até o computador do estrato a partir do qual o computador está sendo sincronizado.
- `Leap status`: Este é o status de intercalação, que pode ter um dos seguintes valores: normal, inserir segundo, excluir segundo ou não sincronizado.
---

- `chronyc sources`: retorna informações sobre os servidores NTP usados para sincronizar a hora
- `chronyc sources -v`:  this command displays information about the current time sources that chronyd is accessing. Mostra se é um server (`^`), se é um peer (`=`) ou se se é o relógio local (`#`). Mostra também se está sincronizado (`*`), se está combinado (`+`) ou se está não está combinado (`-`)
- `chronyc activity`: mostra status das atividades, mostrando se está com status 200 OK, por exemplo<br>
*Se digitar só `chronyc`, entra no modo de cli, e os comandos anteriores podem ser digitados diretamente.
- `chrony ntpdate`: usado para ver informações detalhadas sobre a última atualização válida do NTP


A título de curiosidade, o **systemd** tem uma forma de sincronia por meio do serviço `systemd-timesyncd.service`, que pode conflitar com o ntp. Vide o comando `timedatectl`, que apresenta informações de `network time on` e `NTP synchronized`. Para evitar seria interessante usar o comando: `timedatectl set-ntp false`, assim, vai deixar como **no**, a opção `network time on`

O ntpd usa a porta **123** e o chrony usa a **323**.

NTP Pool recomendado: https://www.ntppool.org/en/

## 108.2 Sistema de Logs - Rsyslog

- **syslog**: derivado dos sistemas unix, bsd, e posteriormente nos sistemas linux.
- **rsyslog**: melhoramento do syslog (mais cobrado na LPI) e (mais veloz para processamento de log, e trouxe melhorias importantes como suporte a RELP - _Reliable Event Logging Protocol_: Protocolo confiável de registro de eventos em log, e estende a funcionalidade do protocolo syslog de maneira a assegurar a entrega de mensagens)
- **syslog-ng**: mesmo padrão do syslog, mas muda a implementação (ng = new generation)
- **systemd-journal**: recurso do systemd, para gerenciar logs (depois do rsyslog, é bem implementado)

>[!NOTE]
>
>Normalmente em `/var/log`. No entanto, alguns serviços cuidam de seus próprios logs (por exemplo, o servidor web Apache HTTPD ou o sistema de impressão CUPS). Da mesma forma, o kernel do Linux usa um buffer de anel na memória para armazenar suas mensagens de log.

O `rsyslog` usa um modelo cliente-servidor. O cliente e o servidor podem existir no mesmo host ou em máquinas diferentes. As mensagens são enviadas e recebidas em um formato específico e podem ser mantidas em servidores `rsyslog` centralizados em redes IP. O daemon do rsyslog —`rsyslogd`— trabalha junto com o `klogd` (que gerencia as mensagens do kernel). Nas próximas seções, discutiremos o `rsyslog` e sua infraestrutura de registro de eventos.

#### Tipos de log

Como os logs são dados  _variáveis_, costumam ser encontrados em  `/var/log`. Grosso modo, podem ser classificados em  _logs do sistema_  e  _logs de serviços ou programas_.

Vamos conhecer alguns logs do sistema e as informações que eles preservam:

- `/var/log/auth.log`: atividades relacionadas aos processos de autenticação: usuários registrados, informações de  `sudo`, cron jobs, tentativas de login malsucedidas etc.
- `/var/log/syslog`: um arquivo centralizado para praticamente todos os logs capturados pelo  `rsyslogd`. Por incluir muitas informações, os logs são distribuídos por outros arquivos de acordo com a configuração fornecida em  `/etc/rsyslog.conf`.
- `/var/log/debug`: informações de depuração dos programas.
- `/var/log/kern.log`: mensagens do kernel.
- `/var/log/messages`: mensagens informativas que não estão relacionadas ao kernel, mas a outros serviços. **É também o destino padrão do log do cliente remoto em uma implementação de servidor de log centralizado**.
- `/var/log/daemon.log`: informações relacionadas aos daemons ou serviços em execução em segundo plano.
- `/var/log/mail.log`: informações relacionadas ao servidor de email, por exemplo o postfix.
- `/var/log/Xorg.0.log`: informações relacionadas à placa de vídeo.
- `/var/run/utmp`  e  `/var/log/wtmp`:  Logins bem-sucedidos.
- `/var/log/btmp`: tentativas de login malsucedidas, por exemplo ataques de força bruta via ssh.
- `/var/log/faillog`: tentativas de autenticação malsucedidas.
- `/var/log/lastlog`: data e hora dos logins recentes do usuário.

Vejamos agora alguns exemplos de logs de serviço:

- `/var/log/cups/`: diretório para logs do  _Common Unix Printing System_. Geralmente inclui os seguintes arquivos de log padrão:  `error_log`,  `page_log`  e  `access_log`.
- `/var/log/apache2/`  or  `/var/log/httpd`: diretório para logs do  _Apache Web Server_. Geralmente inclui os seguintes arquivos de log padrão:  `access.log`,  `error_log`  e  `other_vhosts_access.log`.
- `/var/log/mysql`: diretório para logs do  _MySQL Relational Database Management System_. Geralmente inclui os seguintes arquivos de log padrão:  `error_log`,  `mysql.log`  e  `mysql-slow.log`.
- `/var/log/samba/`: diretório para logs do protocolo  _Session Message Block_  (SMB). Geralmente inclui os seguintes arquivos de log padrão:  `log.`,  `log.nmbd`  and  `log.smbd`.

>[!NOTE]
>
>O nome e o conteúdo exatos dos arquivos de log podem variar de acordo com as distribuições Linux. Existem também logs específicos para distribuições específicas como  `/var/log/dpkg.log`  (contendo informações relacionadas aos pacotes  `dpkg`) no Debian GNU/Linux e seus derivados.

- `/etc/rsyslog.conf`: arquivo principal de configuração do rsyslog. A primeira vista temos os módulos (`module(load="imuxsock")`), que nesse caso serve para comunicação do `rsyslog` com `systemd-journal`, eles se comunicam. (isso nos sistemas baseados em Debian, já em Redhat muito provável que o nome do módulo seja `imjournal` - ambos tem as mesmas funções)

As configurações serão obtidas em `/etc/rsyslog.d/*.conf`(informado na última linha de `/etc/rsyslog.conf`)

Conforme for instalando aplicações, muito provável que elas criarão uma entrada no arquivo `50-default.conf`:<br>
Nesse arquivo o padrão de entrada é: `facility.priority`(facility é quem está gerando o log, qual aplicação, e priority é o nível do log (em ordem ascendente/crescente):<br>
- `debug`: muitos registros, mas não tão importantes
- `info`
- `notice`
- `warn` ou `warning`
- `err` ou `error`
- `crit`: poucos registros, mas precisa ser olhado
- `alert`
- `emerg` ou `panic`
- `*`=todos, qualquer nível de debug<br>
Exemplo: `mail.err` (`mail` é a facility e `err` é a priority)<br>
Como é em ordem crescente, no caso do mail acima, tudo que vir acima de `err`, vai ser criado log (`crit`, `alert` e `emerg`)

Se quiser priorizar **apenas** `err`, use `mail.=err`

Depois da coluna de `facility.priority`, seria onde se destina o log, no caso pode ser um caminho (`/var/log/syslog`, por exemplo) ou pode ser para um determinado usuário (`lpi1,lpi2` - separado pode vírgula) ou ainda para todos os usuário, usando o asterisco (`*`). Há possibilidade de mandar remotamente para outro servidor, usando a notação `@10.0.0.1`, por exemplo (precisa ser um servidor de logs - útil quando tiver muitos servidores, e para descentralizar a geração de logs).

A segunda linha é bem interessante:<br>

    auth,authpriv.*				var/log/auth.log
    *.*;auth,authpriv.none		-/var/log/syslog

*O `-` em frente ao caminho, significa prioridade para performance, que nesse caso com o traço (evita gravações em disco excessivas), **não** precisa ser registrado imediatamente.

No caso, a 2ª linha indica que tudo (`*`), relacionado à facility e priority (`*.*` - qualquer facility e qualquer priority), exceto `;auth,authpriv.none`, irão gerar log em `/var/log/syslog` (em Redhat seria em `/var/log/messages`)

*Todas as configurações vistas serão as mesmas no **syslog**.

É possível criar sua própria configuração:<br>
Em `/etc/rsyslog.d` crie no final do arquivo `50-default.conf`<br>

    local0.warn			/var/log/teste-rsyslog.out

Reinicie o **rsyslog**: `systemctl restart rsyslogd`

Para gerar o log, pode-se utilizar a ferramenta `logger`, com o seguinte comando:<br>

    logger -p local0.err "Teste de Rsyslog"
    # -p = --priority

Depois de executar o comando, é para ter gerado o arquivo `teste-rsyslog.out` dentro de `/var/log`. Executando um `cat` no arquivo criado, é possível verificar a mensagem de log que acabou de ser realizada.

Lembrando que o `rsyslog` é a evolução do `syslog`, caso queira usar o `syslog`, instalar o pacote `inetutils-syslog`. O arquivo de configuração do syslog fica geralmente em `/etc/syslog.conf` (`syslog` não cai no exame, apenas `rsyslog`)

Para leitura do log, usar `less` ou `more`. Se tiver compactado, usar `zless` ou `zmore`. Pode usar também `tail` ou `head`. Para filtrar, usar o `grep`:<br>

       # grep "dhcpclient" /var/log/syslog
        Sep 13 11:58:48 debian dhclient[448]: DHCPREQUEST of 192.168.1.4 on enp0s3 to 192.168.1.1 port 67
    Sep 13 11:58:49 debian dhclient[448]: DHCPACK of 192.168.1.4 from 192.168.1.1
    Sep 13 11:58:49 debian dhclient[448]: bound to 192.168.1.4 -- renewal in 1368 seconds.

Como você deve ter notado, a saída é impressa no seguinte formato:

-   Carimbo de data/hora
-   Nome do host a partir do qual a mensagem se originou
-   Nome do programa/serviço que gerou a mensagem
-   O PID do programa que gerou a mensagem
-   Descrição da ação que ocorreu

Existem alguns exemplos em que os registros não são em forma de texto, mas arquivos binários e — conseqüentemente — você deverá usar comandos especiais para analisá-los:

`/var/log/wtmp`

Use  `who`  (ou  `w`):

    root@debian:~# **who**
    root    pts/0        2020-09-14 13:05 (192.168.1.75)
    root    pts/1        2020-09-14 13:43 (192.168.1.75)

`/var/log/btmp`

Use  `utmpdump`  ou  `last -f`:

    root@debian:~# **utmpdump /var/log/btmp**
    Utmp dump of /var/log/btmp
    [6] [01287] [    ] [dave     ] [ssh:notty   ] [192.168.1.75        ] [192.168.1.75   ] [2019-09-07T19:33:32,000000+0000]

`/var/log/faillog`

Use  `faillog`:

    root@debian:~# **faillog -a | less**
    Login       Failures Maximum Latest                   On
    
    root            0        0   01/01/70 01:00:00 +0100
    daemon          0        0   01/01/70 01:00:00 +0100
    bin             0        0   01/01/70 01:00:00 +0100
    sys             0        0   01/01/70 01:00:00 +0100
    sync            0        0   01/01/70 01:00:00 +0100
    games           0        0   01/01/70 01:00:00 +0100
    man             0        0   01/01/70 01:00:00 +0100
    lp              0        0   01/01/70 01:00:00 +0100
    mail            0        0   01/01/70 01:00:00 +0100
    (...)

`/var/log/lastlog`

Use  `lastlog`:

    root@debian:~# **lastlog | less**
    Username         Port     From             Latest
    root                                       **Never logged in**
    daemon                                     **Never logged in**
    bin                                        **Never logged in**
    sys                                        **Never logged in**
    (...)
    sync                                       **Never logged in**
    avahi                                      **Never logged in**
    colord                                     **Never logged in**
    saned                                      **Never logged in**
    hplip                                      **Never logged in**
    carol            pts/1    192.168.1.75     Sat Sep 14 13:43:06 +0200 2019
    dave             pts/3    192.168.1.75     Mon Sep  2 14:22:08 +0200 2019

>[!NOTE]
>
> Também existem ferramentas gráficas para ler arquivos de log, como  `gnome-logs`  e  `KSystemLog`.

#### Entradas manuais no log do sistema:  `logger`

O comando  `logger`  é prático para scripts do shell ou para testes. O  `logger`  anexa todas as as mensagens recebidas a  `/var/log/syslog`  (ou a  `/var/log/messages`  quando o registro for feito em um servidor de log remoto centralizado, como veremos mais adiante):

carol@debian:~$ **logger this comment goes into "/var/log/syslog"**

Para imprimir a última linha de  `/var/log/syslog`, use o comando  `tail`  com a opção  `-1`:

root@debian:~# **tail -1 /var/log/syslog**
Sep 17 17:55:33 debian carol: this comment goes into /var/log/syslog

#### Como as mensagens são transformadas em logs

O processo a seguir ilustra como uma mensagem é gravada em um arquivo de log:

1.  Aplicativos, serviços e o kernel gravam mensagens em arquivos especiais (sockets e buffers de memória), por exemplo,  `/dev/log`  ou  `/dev/kmsg`.
2.  O  `rsyslogd`  obtém as informações dos sockets ou buffers de memória.
3.  Dependendo das regras encontradas em  `/etc/rsyslog.conf`  e/ou dos arquivos em  `/etc/ryslog.d/`, o  `rsyslogd`  move as informações para o arquivo de log correspondente (normalmente encontrado em  `/var/log`).
    

>[!NOTE]
>
>Um socket é um arquivo especial usado para transferir informações entre diferentes processos. Para listar todos os sockets em seu sistema, você pode usar o comando  `systemctl list-sockets --all`.

### logrotate (rotacionamento de logs)

Imagine o cenário que os logs começam a crescer com o passar do tempo, ao ponto de encher o disco. Aí que entra o rotacionamento de logs.

Um exemplo é executar o comando: `# ls -ltr /var/log/syslog*`

    -rw-r----- 1 syslog adm  130685 Nov 10 00:00 /var/log/syslog.3.gz
    -rw-r----- 1 syslog adm   88855 Nov 17 00:00 /var/log/syslog.2.gz
    -rw-r----- 1 syslog adm 2870981 Nov 24 00:00 /var/log/syslog.1
    -rw-r----- 1 syslog adm 1246647 Nov 25 08:19 /var/log/syslog

É possível perceber que o log do `syslog` vai rotacionando, de `syslog` vira `syslog.1`, depois é compactado, e o último é excluído, tudo isso configurável no `logrotate`.

- `/etc/logrotate.conf`: arquivo de configuração do logrotate. Aqui é uma configuração mais geral e genérica, e que incluir o diretório `/etc/logrotate.d`, que possui as configurações separadamente.

O **logrotate** não é um **daemon** que fica rodando, na realidade é executado pelo crontab (geralmente em `/etc/cron.daily`).

Alguns valores do logrotate nos arquivos de configuração:
- `rotate 4`: Preserva 4 semanas de logs.
- `weekly`: Rotaciona arquivos de log semanalmente.
- `missingok`: Não emite uma mensagem de erro se o arquivo de log estiver ausente; simplesmente passa para o seguinte.
- `notifempty`: Não rotaciona o log se estiver vazio.
- `compress`: Compacta arquivos de log com o  `gzip`  (padrão).
- `delaycompress`: Adia a compactação do arquivo de log anterior para o próximo ciclo de rotação (válido apenas quando usado em combinação com compress). Útil quando um programa não pode ser instruído a fechar seu arquivo de log e, portanto, pode continuar gravando no arquivo de log anterior por algum tempo.
- `sharedscripts`: Relacionado aos scripts  _prerotate_  e  _postrotate_. Para evitar que um script seja executado várias vezes, esse comando executa os scripts apenas uma vez, independentemente de quantos arquivos de log correspondem a um determinado padrão (por exemplo,  `/var/log/mail/*`). Porém, os scripts não serão executados se nenhum dos logs no padrão requerir a rotação. Além disso, se os scripts forem encerrados com erros, as ações restantes não serão executadas em nenhum log.
- `postrotate`: Indica o início de um script  _postrotate_.
- `invoke-rc.d rsyslog rotate > /dev/null`: Usa  `/bin/sh`  para executar  `invoke-rc.d rsyslog rotate > /dev/null`  depois de rotacionar os logs.
- `endscript`: Indica o fim do script  _postrotate_.

>[!NOTE]
>
>Para uma lista completa de diretrizes e explicações, consulte a página de manual de `logrotate.conf`.

#### O buffer de anel do kernel

Uma vez que o kernel gera diversas mensagens antes de  `rsyslogd`  se tornar disponível na inicialização, torna-se necessário um mecanismo para registrar essas mensagens. É aqui que o  _buffer de anel do kernel_  entra em ação. Trata-se de uma estrutura de dados de tamanho fixo e — portanto — à medida que novas mensagens são gravadas, as mais antigas vão desaparecendo.

O comando  `dmesg`  imprime o buffer de anel do kernel. Devido ao tamanho do buffer, este comando é normalmente usado em combinação com o utilitário de filtragem de texto  `grep`. Por exemplo, para pesquisar mensagens relacionadas a dispositivos Universal Serial Bus:

    root@debian:~# dmesg | grep "usb"
    [    1.241182] usbcore: registered new interface driver usbfs
    [    1.241188] usbcore: registered new interface driver hub
    [    1.250968] usbcore: registered new device driver usb
    [    1.339754] usb usb1: New USB device found, idVendor=1d6b, idProduct=0001, bcdDevice= 4.19
    [    1.339756] usb usb1: New USB device strings: Mfr=3, Product=2, SerialNumber=1
    (...)

#### systemd-journal

Monitora as entradas do sistema, gerando registro de logs, em uma base de dados interna (trabalha diferente do **rsyslog**). Logo são 2 tipos de registros, uma pelo **rsyslog** e outra pelo **systemd-journal**.

- `/etc/systemd/journald.conf`: arquivo de configuração do systemd-journal

É muito recomendado olhar o `man journald.conf` para aprofundar nas opções que ele oferece.

Os logs ficam em `/var/log/journal`, no entanto é criado um arquivo de base de dados interna, que não é possível ler com `cat` ou `less`.

Para realizar a leitura, é preciso usar o comando `journalctl`. Ele sozinho sendo executado, mostra todos os dados que já foram para o log do **journal** (muitos dados, que precisam ser filtrados) imprimirá todo o diário em ordem cronológica (com as entradas mais antigas listadas primeiro - se usar `-r` imprime na ordem reversa). Olhar `journalctl --help` para ver os filtros

- `journalctl -n10`: mostra as 10 últimas linhas
- `journalctl -f`: igual ao `tail -f`
- `journalctl -b` ou `--boot`: mensagens de log relacionadas ao boot do sistema
- `journalctl _TRANSPORT=kernel`: mostra tudo que tiver origem do kernel
- `journalctl _UID=0`: tudo que for referente ao usuário root (id=0)
- `journalctl --since "today"` ( `-S` ou `--since` ): todos os logs que aconteceram hoje
- `journalctl --since "1 hour ago"`: todos os logs que aconteceram há 1 dia
- `journalctl --since "2024-11-20" --until "2024-11-21"` (`-U` ou `--until`): todos os logs que aconteceram entre os dias 20 e 21 de novembro e 2024.
- `journalctl --verify`: verifica os logs, se não há nada corrompido.
- `journalctl --sync`: grava em disco tudo que ainda está em memória.

Mais algumas opções de palavras-chave:
- `yesterday`: A partir de meia-noite do dia anterior ao dia atual.
- `today`: A partir de meia-noite do dia atual.
- `tomorrow`: A partir de meia-noite do dia seguinte ao dia atual.
- `now`: A hora atual.

Exemplo: Vamos ver todas as mensagens desde a meia-noite passada até hoje às 21:00:

    root@debian:~# journalctl --since "today" --until "21:00:00"

Para ver as mensagens do diário relacionadas a um **executável** específico, a seguinte sintaxe é usada:  `journalctl  _/path/to/executable_`:

    root@debian:~# **journalctl /usr/sbin/sshd**
    -- Logs begin at Sat 2019-10-12 20:45:29 CEST, end at Sat 2019-10-12 21:54:49 CEST. --
    Oct 12 21:16:28 debian sshd[1569]: Accepted password for carol from 192.168.1.65 port 34050 ssh2

Para ver da mesma forma, mas com **unidades** (units), usa o `-u`:

    root@debian:~# **journalctl -u ssh.service**
    -- Logs begin at Sun 2019-10-13 10:50:59 CEST, end at Sun 2019-10-13 12:22:59 CEST. --
    Oct 13 10:51:00 debian systemd[1]: Starting OpenBSD Secure Shell server...

>[!NOTE]
>
>Para imprimir todas as unidades carregadas e ativas, use `systemctl list-units`; para ver todos os arquivos de unidade instalados, use `systemctl list-unit-files`.


#### Para navegar pela saída do diário, usamos:

-   Teclas `PageUp`, `PageDown` e as setinhas para nos mover para cima, para baixo, a direita e a esquerda.
-   `>`  para ir ao final da saída.
-   `<`  para ir ao início da saída.
    
Você pode pesquisar strings para a frente e para trás a partir de sua posição atual:
-   **Busca para a frente**: Pressione  `/`  e insira a string a pesquisar, depois dê Enter.
-   **Busca para trás**: Pressione  `?`  e insira a string a pesquisar, depois dê Enter.
    
Para navegar pelas correspondências nas pesquisas, use  `N`  para ir para a próxima ocorrência e  `Shift+N`  para ir para a anterior.

#### ver o tamanho dos logs

Supõe que esteja em `/var/log/`, execute `du -sh .`

#### túnel de dados (socket)

Como já vimos em `/etc/rsyslog.conf`, tem o uso de módulos, no caso o `imuxsock`, que vai servir como um túnel de dados entre o **journalctl** e o **rsyslog**.

Em `systemctl status rsyslog`, podemos obter o arquivo que carrega o **rsyslog**, no caso `rsyslog.service`. E se executar um `cat` nele (`cat /lib/systemd/system/rsyslog.service`) é possível ver ele requer (no campo **Requires**) o socket `syslog.socket` (que é uma unit do systemd - podendo ser verificada com o comando `systemctl status syslog.socket` - aqui é possível ver onde ele foi carregado).

Dando um cat onde está o socket visto anteriormente, `cat /lib/systemd/system/syslog.socket`, no campo **ListenDatagram**, mostra o que o syslog está ouvindo, que no caso é `/run/systemd/journal/syslog`. Nesse caso o rsyslog usa esse socket, por conta do módulo `imuxsock` que ouve  o **systemd journal**.

Para confirmar o socket, liste os arquivos em `/run/systemd/journal` (os arquivos **socket** e **stdout**, que começam com s nas permissões)

    cd /run/systemd/journal/
    root@PC:/run/systemd/journal# ls -l
    total 8
    srw-rw-rw- 1 root root    0 Nov  8 16:41 dev-log
    -rw-r--r-- 1 root root    0 Nov  8 16:41 flushed
    srw------- 1 root root    0 Nov  8 16:41 io.systemd.journal
    -rw-r--r-- 1 root root    8 Nov  8 16:41 kernel-seqnum
    -rw-r--r-- 1 root root   24 Nov  8 16:41 seqnum
    srw-rw-rw- 1 root root    0 Nov  8 16:41 socket
    srw-rw-rw- 1 root root    0 Nov  8 16:41 stdout
    drwxr-xr-x 2 root root 1160 Nov 25 10:32 streams
    srw-rw-rw- 1 root root    0 Nov  8 16:41 syslog


#### systemd-cat (parecido com logger)

Execute o `journalctl -f` para ficar logando as entradas (igual ao `tail -f`) em um terminal, e em outro use o `systemd-cat`, que vai mandar o output do comando diretamente para o **journal**.

Ex. `systemd-cat ls -ls rsyslog.conf`: manda a saída do comando `ls` diretamente no journal (onde deixou rodando o comando `journalctl -f`)

Pode usar também dessa forma: `echo "Mensagem de teste" | systemd-cat`

#### ver o tamanho dos logs journal

Supõe que esteja em `/var/log/journal`, execute `journalctl --disk-usage`

#### limpar logs

- `journalctl --vacuum-size=200M`: limpa 200 MB os arquivos de logs (archived apenas, não os ativos). Pode usar `--vacuum-time` e `--vacuum-files`

Voltar depois nesse tópico e no de mail e impressoras


## 109.1 Fundamentos dos protocolos de internet

- **TCP/IP**: Conjunto de Protocolos de comunicação entre computadores
- Engloba os protocolos IP, TCP, UDP, ICMP, entre outras

- **IP**: é o protocolo responsável pelo endereçamento lógico. Cada dispositivo em uma rede deve possuir um endereço IP único

- O endereço IP (IPv4) é formado por 32 bits, separados em 4 grupos de 8 bits, representados de maneira decimal.
	- 192.168.10.20 = 10000000.10101000.00001010.00010100
	- 0.0.0.0 = 00000000.00000000.00000000.0000000
	- 255.255.255.255 = 11111111.11111111.11111111.11111111

#### Classes

| Classe | 1º Octeto | Range |
| -------- | ----- | ----------- |
| A | 1-126 | 1.0.0.0 - 126.255.255.255 |
| B | 128-191 | 128.0.0.0 - 191.255.255.255 |
| C | 192-223 | 192.0.0.0 - 223.255.255.255 |

Exemplos:
- Classe A - 10.25.13.10 - 110.14.20.12
- Classe B - 141.150.200.1 / 172.168.1.1
- Classe C - 192.168.20.30 / 200.178.12.242

#### Endereços: Privado vs Público

| Classe | 1º Octeto | Range | IPs Privados |
| -------- | ----- | ---------- | ------------ |
| A | 1-126 | 1.0.0.0 - 126.255.255.255 | 10.0.0.0 - 10.255.255.255 |
| B | 128-191 | 128.0.0.0 - 191.255.255.255 | 172.16.0.0 - 172.31.255.255 |
| C | 192-223 | 192.0.0.0 - 223.255.255.255 | 192.168.0.0 - 192.168.255.255 |

#### Máscara

- utilizada em conjunto com o endereço IP para determinar a segmentação de rede
- também composta de 32 bits em 4 grupos de 8:
	- 255.0.0.0 = 11111111.00000000.00000000.00000000 = /8
	- 255.255.0.0 = 11111111.11111111.00000000.00000000 = /16
	- 255.255.255.0 = 11111111.11111111.11111111.00000000 = /24
	- 255.255.255.255 = 11111111.11111111.11111111.11111111 = /32
- 1s identificam a rede
- 0s identificam os hosts

| Classe | 1º Octeto | Range | Máscara Padrão |
| -------- | ----- | ---------- | ------------ |
| A | 1-126 | 1.0.0.0 - 126.255.255.255 | 255.0.0.0 /8 |
| B | 128-191 | 128.0.0.0 - 191.255.255.255 | 255.255.0.0 /16 |
| C | 192-223 | 192.0.0.0 - 223.255.255.255 | 255.255.255.0 /24 |

Exemplos:
- Classe A - `110`.14.20.12
- Classe B - `172.168`.1.1
- Classe C - `200.178.12`.242

#### sub-redes

| Máscara | CIDR | Hosts | Sub-rede |
| -------- | ----- | ---------- | ------------ |
| 255.255.255.0 | 24 | 254 | 1 |
| 255.255.255.128 | 25 | 126 | 2 |
| 255.255.255.192 | 26 | 62 | 4 |
| 255.255.255.224 | 27 | 30 | 8 |
| 255.255.255.240 | 28 | 14 | 16 |
| 255.255.255.248 | 29 | 6 | 32 |
| 255.255.255.252 | 30 | 2 | 64 |

#### Rota padrão (gateway)

Duas sub-redes distintas, caso precisem se comunicar, terá que ter um gateway para realizar o intermédio entre essas redes (precisa de uma rota padrão).

#### IPv6

- IPv6 é um novo padrão de endereçamento IP
- cada endereço possui 128 bits, divididos em 8 grupos de 16 bits, representados por 4 números hexadecimais
- Exemplo: `2001:0db8:85a3:08d3:1319:8a2e:0370:7344`

#### abreviações

- 2001:0db8:85a3`:0000:0000:0000:0000:`7344
- 2001:0db8:85a3`:0:0:0:0:`7344
- 2001:0db8:85a3`::`7344
<br>
- 2001:0db8:85a3`:0000:0000:`1319`:0000:`7344
- 2001:0db8:85a3`:0:0:`1319`:0:`7344
- 2001:0db8:85a3`::`1319`:0:`7344

<br>

- **Unicast**: identifica uma única interface
- **Multicast**: identifica um conjunto de interfaces. Um pacote é enviado para cada interface
- **Anycast**: identifica um conjunto de interfaces. Um pacote e enviado para'uma única interface, normalmente a mais próxima

#### Diferenças entre IPv4 e IPv6

Além do endereço, diversas outras diferenças podem ser apontadas entre as versões 4 e 6 do IP. Eis algumas delas:
-   As portas de serviço seguem os mesmos padrões e protocolos (TCP, UDP); a diferença está apenas na representação do IP e no conjunto de portas. No IPv6, o endereço IP deve ser protegido com  `[]`  (colchetes):
    
   - IPv4:  `200.216.10.15:443`
   - IPv6:  `[2001:0db8:85a3:08d3:1319:8a2e:0370:7344]:443`
    
-   O IPv6 não implementa o recurso de broadcast (transmissão) da mesma maneira que o IPv4. Porém, o mesmo resultado pode ser obtido enviando-se o pacote para o endereço  `ff02::1`, que alcança todos os hosts da rede local — semelhante a usar  `224.0.0.1`  no IPv4 para uma transmissão multicast.
-   Por meio do recurso SLAAC (_Stateless Address Autoconfiguration_), os hosts IPv6 podem se autoconfigurar.
-   O campo TTL (_Time to Live_) do IPv4 foi substituído pelo “Hop Limit” (limite de saltos) no cabeçalho do IPv6.
-   Todas as interfaces IPv6 têm um endereço local, denominado endereço de link local, prefixado com  `fe80::/10`.
-   O IPv6 implementa o  _Neighbor Discovery Protocol_  (NDP), semelhante ao ARP usado pelo IPv4, mas com muito mais funcionalidades.

Que tipo de informação o Neighbour Discovery Protocol (NDP) pode descobrir?

O NDP é capaz de obter diversas informações da rede, incluindo outros nós, endereços duplicados, rotas, servidores DNS, gateways, etc.

#### TCP

- **TCP**: Transmission Control Protocol: protocolo de transporte orientado a conexões. Garante a entrega dos pacotes na ordem correta. O pacote é retransmitido em caso de erros na rede. Usado por serviços como FTP, SMTP, HTTP, POP3, IMAP, SSH, etc

#### UDP

- **UDP**: User Datagram Protocol: protocolo de transporte não  orientado a conexões. Não oferece garantia de entrega dos pacotes, assim tem melhor performance na transmissão de dados. Usado por serviços como DHCP, DNS, NFS e NTP.

#### ICMP

- **ICMP**: Internet Control Message Protocol: utilizado para transmitir informações de controle entre os elementos de rede, por exemplo:
	- controle de volume de tráfego
	- detecção de destinos nao atingíveis
	- redirecionamento de rotas
	- verificação de status de hosts remotos
- utilizado em comandos como o `ping` e `traceroute`

#### Portas e Serviços

- cada serviço é provido por meio de uma porta
- portas possuem 16 bits, ou seja, um máximo de 65535
- as primeiras 1024 portas são reservadas a serviços conhecidos (_portas privilegiadas_, por ter acesso de root ao sistema)
- as demais são utilizadas para serviços específicos ou para a porta de socket (_portas não privilegiadas_ ou portas de socket) de uma conexão (quando um cliente se conecta a um servidor http, o servidor normalmente usa a porta 80, já no cliente é configurado um socket/porta aleatório, como 42222, por exemplo. Essa porta é chamada de socket)
- toda conexão é composta de IP de **destino** e **origem**, assim como a porta de **destino** e **origem** (socket)
- As portas usadas por cada tipo de serviço são padronizadas e controladas pela IANA (_Internet Assigned Numbers Authority_). Assim, em qualquer sistema, a porta 22 é usada pelo serviço SSH, a porta 80 pelo serviço HTTP e assim por diante.
- Em um sistema Linux, as portas de serviço padrão são listadas no arquivo `/etc/services`.

<br>

Exemplo:
- `200.20.125.60`:25 (serviço SMTP)
- `172.168.8.10`:80 (serviço HTTP)
- `[2001:0db8:85a3:0000:0000:1319:0000:7344]`:80

| Porta(s) | Serviço |
| -------- | ----- |
| 20 e 21 | FTP |
| 22 | SSH |
| 23 | Telnet |
| 25 e 465 | SMTP e SMTPs |
| 53 | DNS |
| 67 e 68 | DHCP |
| 80 e 443 | HTTP e HTTPS |
| 110 e 995 | POP3 e POP3S |
| 123 | NTP |
| 139 | Netbios |
| 143 e 993 | IMAP e IMAPS |
| 161 e 162 | SNMP |
| 389 e 636 | LDAP e LDAPS |


## 109.2 Configuração de rede persistente

- `/etc/hostname`: define o nome da máquina (assim como digitar `hostname` vai mostrar o nome da máquina)
- `hostnamectl`: mostra mais informações do host
- `hostnamectl set-hostname novo_nome`: altera o hostname da máquina (altera também lá no `/etc/hostname`)

Uma configuração funcional de TCP/IP é apenas o primeiro passo para a usabilidade total da rede. Além de ser capaz de distinguir os nós da rede por seus números IP, o sistema deve poder identificá-los com nomes mais facilmente compreensíveis por seres humanos.

O nome pelo qual o sistema se identifica é personalizável e é aconselhável fazê-lo, mesmo se a máquina não for destinada a se conectar a uma rede. O nome local geralmente corresponde ao nome da rede da máquina, mas nem sempre. Se o arquivo  `/etc/hostname`  existir, o sistema operacional usará o conteúdo da primeira linha como nome local, que a partir daí é chamado simplesmente de  _nome do host_  (hostname, em inglês). As linhas que começam com  `#`  dentro de  `/etc/hostname`  são ignoradas.

O arquivo  `/etc/hostname`  pode ser editado diretamente, mas o nome de host da máquina também pode ser definido com o comando  `hostnamectl`. Quando fornecido com o subcomando  `set-hostname`, o comando  `hostnamectl`  pega o nome dado como argumento e o escreve em  `/etc/hostname`:

    # hostnamectl set-hostname storage
    # cat /etc/hostname
    storage

O nome de host (ou “hospedeiro”) definido em  `/etc/hostname`  é o nome  _estático_, ou seja, o nome usado para inicializar o nome de host do sistema na inicialização. O nome de host estático pode ser uma string com até 64 caracteres de comprimento. No entanto, é recomendado que ele consista apenas em caracteres ASCII minúsculos e sem espaços ou pontos. Também é aconselhável limitá-lo ao formato permitido para rótulos de nomes de domínio DNS, embora esse não seja um requisito estrito.

O comando  `hostnamectl`  pode definir dois outros tipos de nomes de host além do nome de host estático:

- **Hostname pretty**: Ao contrário do nome de host estático, o nome de host pretty pode incluir todos os tipos de caracteres especiais. Ele pode ser usado para definir um nome mais descritivo para a máquina, por exemplo “Armazenamento compartilhado da LAN”:
```
    # hostnamectl --pretty set-hostname "LAN Shared Storage"
```
- **Hostname transiente**: Usado quando o nome de host estático não está definido ou quando ele é o nome  `localhost`  padrão. O nome de host transiente é normalmente definido junto com outras configurações automáticas, mas também pode ser modificado com o comando  `hostnamectl`, por exemplo:
```
# hostnamectl --transient set-hostname generic-host
```
Se nem a opção  `--pretty`  nem  `--transient`  forem usadas, os três tipos de nomes de host serão configurados com o nome fornecido. Para definir o nome de host estático, mas não os nomes pretty e transiente, usa-se a opção  `--static`. Em todos os casos, somente o nome de host estático é armazenado no arquivo  `/etc/hostname`.

- `/etc/hosts`: arquivo que cria uma relação do IP e nome da máquina (igual o que há no windows)
Ex. de entrada no `/etc/hosts`:
```
192.168.0.100		minhamaquina		minhamaquina.dominio.com.br
```
*O terceiro campo é opcional. Quando for no terminal e der um ping em `minhamaquina`, vai pingar no IP associado:

    $ ping minhamaquina
    PING minhamaquina (192.168.0.100) 56(84) bytes of data.
    64 bytes from minhamaquina (192.168.0.100): icmp_seq=1 ttl=64 time=0.257 ms
    64 bytes from minhamaquina (192.168.0.100): icmp_seq=2 ttl=64 time=0.381 ms

- `/etc/nsswitch.conf` (Name Service Switch): disponibiliza diversas informações, de onde buscar as informações de `passwd`, `group`, `shadow`, etc. Geralmente é indicado como `compat` (compatibilidade), mas poderia, por exemplo, indicar para buscar no `ldap`.

No entanto para LPI1, é importante saber a parte de `hosts` e `networks`:
- `hosts`: vai estar como `files`, o que indica para buscar primeiramente aos arquivos do sistema, como o `/etc/hosts` (o que faz relação IP e nome), e caso não encontre, vai buscar em algum DNS configurado (no arquivo vai estar o `mdns4_minimal`, que é um serviço de DNS interno - `multicast dns`).

Exercício interessante:<br>
Qual entrada de  `/etc/hosts`  associa os nomes  `firewall`  e  `router`  com o IP  `10.8.0.1`?<br>
Resposta: A linha  `10.8.0.1 firewall router`.

- `/etc/networks`: mesma relação com o /etc/hosts, mas esse seria para redes.
```
rede-local		192.168.1.0 #nomeia essa rede como rede-local
```

- `/etc/resolv.conf`: determinar qual servidor DNS será utilizado pelo sistema. Indica o `nameserver` (apenas um servidor de nomes é necessário, mas é possível informar até **três** deles - os suplementares serão usados como reserva - se nenhuma entrada de servidor de nomes estiver presente, o comportamento padrão é usar o servidor de nomes da máquina local), que é basicamente o servidor DNS que irá usar. (mais detalhes no tópico **109.3**)
Importante dizer que esse arquivo é dinamicamente gerenciado/escrito/gerado pelo `systemd-resolved(8)`, que basicamente é um link que vem do `/etc/resolv.conf`. Isso significa que poderia ter seu próprio arquivo parecido com `resolv.conf` apontando para o `resolv` do `systemd` (para ambiente de produção, por exemplo).
```
ls -l /etc/resolv.conf 
lrwxrwxrwx 1 root root 39 Nov  8 16:20 /etc/resolv.conf -> ../run/systemd/resolve/stub-resolv.conf
```

#### NetworkManager

De modo geral, a configuração costuma ser feita por arquivos, sendo eles:
- No padrão Debian, geralmente fica em `/etc/network/interfaces`.
- Já no Red Hat, fica em `/etc/sysconfig/network-scripts`

No entanto as distros mais novas tem tendenciado utilizar o **NetworkManager**(o que é exigido na LPI - em tese não é cobrado os scripts listados acima, apenas na LPI2)

Existem aplicativos cliente do NetworkManager para a linha de comando e para o ambiente gráfico. No caso deste último, o aplicativo cliente é incluído como um acessório do ambiente de desktop (com nomes como _nm-tray_, _network-manager-gnome_, _nm-applet_ ou _plasma-nm_) e geralmente fica acessível por meio de um ícone indicador no canto da barra da área de trabalho ou no utilitário de configuração do sistema

Os arquivos de configuração ficam em `/etc/NetworkManager`. Dentro há algumas pastas, sendo:
- `system-connections`: onde é salvo as redes conhecidas pelo NetworkManager, configuração de perfis, redes wifi, etc.

Para verificar se o serviço do NetworkManager está executando: `systemctl status NetworkManager`. O NetworkManager foi desenvolvido originalmente pela Red Hat, sendo atualmente um projeto GNOME.

É possível gerir o NetworkManager por CLI, utilizando o `nmcli`.

As categorias chamadas  _objetos_ são:
- `general`: Status e operações gerais do NetworkManager
- `networking`: Controle geral de rede.
- `radio`: Controles de rádio do NetworkManager.
- `connection`: Conexões do NetworkManager.
- `device`: Dispositivos gerenciados pelo NetworkManager.
- `agent`: Agente secreto ou agente polkit do NetworkManager.
- `monitor`: Monitora as mudanças do NetworkManager.


- `nmcli`: lista as interfaces detectadas pelo NetworkManager e os servidores DNS configurados no computador
- `nmcli device` (ou `nmcli d` ou `nmcli dev`): resumo das interfaces
- `nmcli device show`: mostra mais detalhes das interfaces (mostra IP, máscara formato CIDR, rota padrão e DNS)
- `nmcli device show enp2s0`: mostra mais detalhes das interfaces (mostra IP, máscara formato CIDR, rota padrão e DNS) da interface selecionada
- `nmcli --help`: mostra as diversas outras opções do `nmcli`
- `nmcli general status`: mostra as informações/status na conexão no momento
- `nmcli networking`: se a rede cabeada está habilitada/funcionando
- `nmcli radio`: se o wifi está habilitado/funcionando
- `nmcli connection`: enquanto device mostra informações referentes ao dispositivo em si, connections mostra informações da(s) conexão(ões), como o tipo (ethernet e wifi)

Supondo que a saída do comando `nmcli connection` seja (O comando `status` é usado por padrão se nenhum argumento de comando estiver presente, de modo que o comando `nmcli general` é interpretado, na verdade, como `nmcli general status`): 

    DEVICE		UUID		TYPE			STATE			CONNECTION
    enp0s2		779a5...	ethernet		connected		Wired connection 1	
    enp0s4		45f23...	ethernet		connected		Wired connection 2

Para baixar a `Wired connection 2`, use: `nmcli con down "Wired connection 2"`

- `nmcli connection add type ethernet con-name nome_conexao ifname enp2s0 ip4 192.168.0.20/24 gw4 192.168.0.1`: cria uma nova conexao chamada `nome_conexao`, na placa `enp2s0`, com IP `192.168.0.20` máscara `255.255.255.0` e gateway `192.168.0.1`.
- `nmcli connection up nome_conexao`: ativa a rede criada no comando acima.
- `nmcli connection del nome_conexao`: remove a rede `nome_conexao`

Se voltarmos em `/etc/NetworkManager`, em `system-connections`, foi criado um arquivo `nome_conexao`. Mais opções em `nmcli connection --help`

#### NetworkManager - redes sem fio

- `nmcli device wifi list`: mostra as redes disponíveis (SSIDs). A com asterisco (`*`) é a que está em uso.
- `nmcli device wifi rescan`: reescaeia e coloca uma flag se um novo Wi-Fi scan deve ser engatilhado. Depois rode o `list` novamente.
- `nmcli radio wifi on/off`: habilita/desabilita o rádio wifi. (se trocar `radio` por `networking`, habilita/desabilita rede cabeada)
- `nmcli device wifi connect NOME_SSID password 123456`: conecta na rede `NOME_SSID` com a senha `123456` (obviamente não usar essa senha em produção). Confirme se conector com o asterisco mostrado no `nmcli device wifi list`
- Se a rede wi-fi esconde seu nome SSID, o  `nmcli`  ainda assim pode se conectar a ela com os argumentos extras  `hidden yes`:
```
$ nmcli device wifi connect Hypnotoad password MyPassword hidden yes
```
- Se o sistema tiver mais de um adaptador wi-fi, indicamos o que deve ser usado com  `ifname`. Por exemplo, para se conectar usando o adaptador de nome  `wlo1`:
```
$ nmcli device wifi connect Hypnotoad password MyPassword ifname wlo1
```

>[!NOTE]
>
>`nmcli device wifi connect`, apenas o SSID é obrigatório, a senha pode ser omitida caso a conexão já tenha sido criada anteriormente. Se o comando for executado dentro de um emulador de terminal no ambiente gráfico, aparecerá uma caixa de diálogo solicitando a senha da rede. Quando executado em um console de texto, a senha pode ser fornecida junto com os outros argumentos, como no comando acima

- `nmcli device disconnect wlo1`: desconectar da rede conectada anteriormente (não chega a desligar a interface - tanto que `nmcli device list` funciona).

Se houver um adaptador sem fio disponível, mas ele não estiver sendo usado, ele pode ser desligado para economizar energia. Desta vez, o objeto  _radio_  deve ser passado para  `nmcli`:

    $ nmcli radio wifi off

Obviamente, o dispositivo sem fio pode ser ativado novamente com o comando  `nmcli radio wifi on`.

>[!NOTE]
>
>Uma vez que as conexões forem estabelecidas, nenhuma interação manual será necessária no futuro, pois o NetworkManager identifica as redes conhecidas disponíveis e se conecta a elas automaticamente. Se necessário, o NetworkManager possui plugins que podem estender suas funcionalidades, por exemplo para suportar conexões VPN.

>[!NOTE]
>
>o UUID da conexão muda a cada vez que a conexão é ativada e, portanto, é preferível usar o nome para manter a consistência

Redes que o PC já conectou (e conhece):  **/etc/NetworkManager/system-connections**  e se dar um  **ls -la**, vai listar todas as redes que já foram conectadas (tanto wireless como rede cabeada). Inclusive se der um cat (como root) **mostra até a senha da rede** em um dos arquivos de conexão sem fio.

>[!WARNING]
>
>Atenção para os **estados possíveis** na execução de “**nmcli networking connectivity**” (pelo man):
-   **none**: O host não está conectado em nenhuma rede.
-   **portal**: O host está atrás de um “captive portal” e ainda não possui total acesso à Internet. “Captive portal” é a tela de login à qual você é redirecionado ao se conectar em uma rede de hotel ou aeroporto por exemplo.
-   **limited**: O host está conectado à rede, mas não tem acesso à Internet.
-   **full**: O host está conectado à rede e tem total acesso à Internet.
-   **unknown**: O status da conectividade não pode ser encontrado.

##### uma breve apresentação de ifupdown

Primeiramente precisa verificar se o pacote `ifupdown` está instalado: `dpkg -l | grep ifupdown`, caso não tenha, instalar: `apt install ifupdown -y` (nas distros mais recentes esse pacote foi retirado devido a entenderem que o que deve ser utilizado é o `NetworkManager`).

No man `ifup`, fala claramente que tanto `ifup` (para subir interfaces) como `ifdown` (para baixar interfaces) são usados baseados no arquivo `/etc/network/interfaces` (para caso deseje não utilizar o NetworkManager, e usar por arquivo de configuração)

Se tentarmos dar um `ifdown` na interface `enp2s0`, vai retornar que a interface em questão é desconhecida, pois `enp2s0` não está listado no arquivo `/etc/network/interfaces`.

#### systemd-networkd

O `systemd` também tem um gerenciador de rede (`systemctl status systemd-networkd` - provavelmente vai estar desabilitado) muito parecido com o modo de administração do NetworkManager.

No entanto é possível mudar o gerenciamento para o **systemd-networkd**. Basta parar o NetworkManager (`systemctl stop NetworkManager`) e iniciar o systemd-networkd (`systemctl start systemd-networkd`)

Se tentar rodar `nmcli device`, vai dar erro, pois o NetworkManager foi parado anteriormente.

Os arquivos de configuração podem estar em:
- `/lib/systemd/network` (com arquivos `.link` e `.network`) é onde. Aqui seria o diretório de rede do sistema.
- `/etc/systemd/network` : diretório local de administração da rede.
- `/run/systemd/netif` ou `/run/systemd/network`: diretório volátil de tempo de execução da rede.

Os arquivos são processados em ordem lexicográfica, por isso é recomendável iniciar seus nomes com números para facilitar o ordenamento e a leitura.

Os arquivos em  `/etc`  têm a prioridade mais alta, ao passo que os arquivos em  `/run`  têm precedência sobre os arquivos com o mesmo nome em  `/lib`. Ou seja, se dois ou mais arquivos de configuração em diretórios diferentes tiverem o mesmo nome, o systemd-networkd ignora os que tiverem menor prioridade. Essa maneira de separar os arquivos permite mudar as configurações da interface sem que seja necessário modificar os arquivos originais: as modificações podem ser postas em  `/etc/systemd/network`  para sobrescrever as existentes em  `/lib/systemd/network`.

A finalidade de cada arquivo de configuração depende de seu sufixo. Os nomes de arquivos que terminam em  `.netdev`  são usados pelo systemd-networkd para criar dispositivos de rede virtuais, como dispositivos  _bridge_  ou  _tun_. Os arquivos que terminam em  `.link`  definem configurações de baixo nível para a interface de rede correspondente. O systemd-networkd detecta e configura os dispositivos de rede automaticamente conforme eles aparecem — além de ignorar dispositivos já configurados por outros meios — e, portanto, há pouca necessidade de adicionar esses arquivos na maioria das situações.

O sufixo mais importante é  `.network`. Os arquivos que empregam esse sufixo podem ser usados para configurar endereços de rede e rotas. Tal como acontece com os outros tipos de arquivos de configuração, o nome do arquivo define a ordem em que ele será processado. A interface de rede à qual o arquivo de configuração se refere é definida na seção  ``[Match]` ``  dentro do arquivo.

Por exemplo, a interface de rede ethernet  `enp3s5`  pode ser selecionada dentro do arquivo  `/etc/systemd/network/30-lan.network`  graças à entrada  `Name=enp3s5`  na seção  `[Match]`:
```
[Match]
Name=enp3s5
```
Também é possível usar uma lista de nomes separados por espaços em branco para selecionar diversas interfaces de rede de uma vez neste mesmo arquivo. Os nomes podem conter globs no estilo do shell, como  `en*`. Outras entradas permitem usar regras diferentes, como por exemplo selecionar um dispositivo de rede por seu endereço MAC:
```
[Match]
MACAddress=00:16:3e:8d:2b:5b
```
As configurações do dispositivo estão na seção  `[Network]`  do arquivo. Uma configuração de rede estática simples requer apenas as entradas  `Address`  e  `Gateway`:
```
[Match]
MACAddress=00:16:3e:8d:2b:5b

[Network]
Address=192.168.0.100/24
Gateway=192.168.0.1
```
Para usar o protocolo DHCP em vez de endereços IP estáticos, a entrada  `DHCP`  deve ser usada:
```
[Match]
MACAddress=00:16:3e:8d:2b:5b

[Network]
DHCP=yes
```
O serviço systemd-networkd tenta buscar os endereços IPv4 e IPv6 para a interface de rede. Para usar apenas IPv4, empregamos  `DHCP=ipv4`. Da mesma forma,  `DHCP=ipv6`  ignora as configurações IPv4 e usa apenas o endereço IPv6 fornecido.

As redes sem fio protegidas por senha também podem ser configuradas pelo systemd-networkd, mas o adaptador de rede já deve estar autenticado na rede antes que o systemd-networkd possa configurá-lo. A autenticação é realizada pelo  _WPA supplicant_, um programa dedicado a configurar adaptadores de rede para redes protegidas por senha.

O primeiro passo é criar o arquivo de credenciais com o comando  `wpa_passphrase`:
```
# wpa_passphrase MyWifi > /etc/wpa_supplicant/wpa_supplicant-wlo1.conf
```
Este comando pega a frase-senha para a rede sem fio  `MyWifi`  da entrada padrão e armazena seu hash em  `/etc/wpa_supplicant/wpa_supplicant-wlo1.conf`. Note que o nome do arquivo deve conter o nome apropriado da interface sem fio, por isso o  `wlo1`  no nome do arquivo.

O gerenciador do systemd lê os arquivos de frase-senha do WPA em  `/etc/wpa_supplicant/`  e cria o serviço correspondente para executar o WPA supplicant e abrir a interface. O arquivo de frase secreta criado no exemplo terá uma unidade de serviço correspondente chamada  `wpa_supplicant@wlo1.service`. O comando  `systemctl start wpa_supplicant@wlo1.service`  associará o adaptador sem fio ao ponto de acesso remoto. O comando  `systemctl enable wpa_supplicant@wlo1.service`  tornará essa associação automática durante a inicialização.

Finalmente, um arquivo  `.network`  correspondente à interface  `wlo1`  deve estar presente em  `/etc/systemd/network/`, já que o systemd-networkd vai usá-lo para configurar a interface assim que o WPA supplicant encerrar a associação com o ponto de acesso.

Lembrando que a LPI apenas cobra que saiba (awareness) que existe o `systemd-networkd`

#### nomenclaturas das placas de rede

As distribuições Linux mais antigas atribuíam às interfaces de rede ethernet nomes como  `eth0`,  `eth1`, etc., numeradas de acordo com a ordem em que o kernel identificava os dispositivos. As interfaces wireless eram nomeadas  `wlan0`,  `wlan1`, etc. Esta convenção de nomenclatura, no entanto, não esclarece qual porta Ethernet específica corresponde à interface  `eth0`, por exemplo. Dependendo de como o hardware fosse detectado, era possível inclusive que duas interfaces de rede trocassem de nome após uma reinicialização.

Para evitar essa ambiguidade, os sistemas Linux mais recentes empregam uma convenção de nomenclatura previsível para as interfaces de rede, criando uma aproximação maior entre o nome da interface e a conexão de hardware subjacente.

Nas distribuições Linux que usam o esquema de nomenclatura do systemd, todos os nomes de interfaces começam com um prefixo de dois caracteres que indica o tipo de interface:
- `en`: Ethernet
- `ib`: InfiniBand
- `sl`: Serial line IP (slip)
- `wl`: Rede de área local sem fio (WLAN)
- `ww`: Rede de longa distância sem fio (WWAN)

De prioridade mais alta para mais baixa, as seguintes regras são usadas pelo sistema operacional para nomear e numerar as interfaces de rede:

1.  Nomear a interface de acordo com o índice fornecido pela BIOS ou pelo firmware dos dispositivos incorporados, por exemplo,  `eno1`.
2.  Nomear a interface de acordo com o índice do slot PCI Express, conforme fornecido pela BIOS ou firmware, por exemplo,  `ens1`.
3.  Nomear a interface de acordo com seu endereço no barramento correspondente, por exemplo,  `enp3s5`.
4.  Nomear a interface de acordo com o endereço MAC da interface, por exemplo,  `enx78e7d1ea46da`.
5.  Nomear a interface usando a convenção legada, por exemplo,  `eth0`.

É correto pressupor, por exemplo, que a interface de rede  `enp3s5`  recebeu esse nome porque não se encaixava nos dois primeiros métodos de nomenclatura, de forma que seu endereço no barramento e no slot correspondentes foi usado. O endereço do dispositivo  `03:05.0`, encontrado na saída do comando  `lspci`, revela o dispositivo associado:

    $ lspci | fgrep Ethernet
    03:05.0 Ethernet controller: Realtek Semiconductor Co., Ltd. RTL-8110SC/8169SC Gigabit Ethernet (rev 10)

As interfaces de rede são criadas pelo próprio kernel do Linux, mas existem muitos comandos que podem ser usados para interagir com elas. Normalmente, a configuração ocorre automaticamente e não há necessidade de se alterar as configurações manualmente. Ainda assim, com o nome da interface, é possível informar ao kernel como proceder para configurá-la se necessário.

## 109.3 Resolução de problemas básicos de rede

Na LPI-1 versão 5, foi adicionado o uso do pacote `iproute2` (`dpkg -l | grep iproute2`), sendo o principal pacote abordado, tendo os principais comandos o `ip` e `ss`.

Quem trabalha com linux a mais tempo, muito provável está mais acostumado a trabalhar com os comandos `ifconfig`, `route` e `netstat`, que são comandos do pacote `net-tools` (para administrar interfaces de rede e rotas no sistema).

O `iproute2` é uma implementação mais moderna, e a tendencia é utilizá-lo no lugar dos comandos do pacote `net-tools`. O pacote `net-tools`, no ponto de vista do exame, exige apenas conhecimento (awareness)

Com o comando IP é possível configurar interfaces e criar rotas. Na lição 109.2, quando foi visto NetworkManager, era ele quem fazia as alterações e configurações diretamente nas interfaces, já com `ip`, é o administrador que faz esse contato direto com as interfaces e todas do computador.

- `ip link show`: mostra as interfaces em uso e se estão funcionando. Não mostra IP. `link` é referente às interfaces (mostra também se está UP/DOWN).
- `ip address show` (pode usar `addr`): mostra com informações do IP
-  `ip route show` ou `ip route list`: mostra as rotas, como a default (pc que não está navegando, pode ser que está sem rota default)

Pressupondo que o sistema de arquivos  `sys`  esteja montado, também podemos listar o conteúdo de  `/sys/class/net`

    $ ls /sys/class/net
    enp0s3  enp0s8  lo

#### manipular endereços na interface

- `ip addr add 192.168.1.50/24 dev enp0s2`: configura o IP `192.168.1.50` na interface `enp0s2` (uma interface de rede pode receber mais de 1 IP)
- `ip addr del 192.168.1.50/24 dev enp0s2`: remove o IP 192.168.1.50 da interface enp0s2
- `ip addr flush dev enp0s2` remove todos os IPs configurados na interface `enp0s2`
- `ip addr add 2001:db8::10/64 dev enp0s8`: define u IPv6 para interface `enp0s8`

*Lembrando que essas alterações são em memória, ao reiniciar o PC, ele pegará as configurações do NetworkManager ou outro programa que esteja configurado para gerenciar a rede.

#### manipular a interface em si

O comando `ip link` é usado para configurar a interface de baixo nível ou para configurações de protocolos, como `VLANs`, `ARP` ou `MTUs`, ou ainda para desabilitar uma interface.

Às vezes é necessário ajustar o MTU de uma interface. Da mesma forma que é possível habilitar/desabilitar interfaces, esse ajuste também pode ser feito com  `ifconfig`  ou  `ip link`:

    # ip link set enp0s8 mtu 2000
    # ip link show dev enp0s3
    2: enp0s3: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu **2000** qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000
        link/ether 08:00:27:54:53:59 brd ff:ff:ff:ff:ff:ff
    # ifconfig enp0s3 mtu 1500
    # ip link show dev enp0s3
    2: enp0s3: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu **1500** qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000
        link/ether 08:00:27:54:53:59 brd ff:ff:ff:ff:ff:ff

- `ip link set enp0s2 down` (para subir usa `up`): baixa a interface `enp0s2` (retira o UP quando `ip link show`). Caso tenha mudado o IP antes de dar down e up, acaba perdendo essa configuração e busca novamente no gerenciador padrão de rede (normalmente NetworkManager).


#### rotas

Se adicionar um IP qualquer em alguma interface, será criado uma rota para a placa de rede escolhida. Se pode exemplo, `ip addr add 10.0.0.10/24 dev enp0s2` for executado, nas rotas (`ip route show`) será adicionado uma entrada dessa forma:
```
10.0.0.0/24 dev enp0s2 proto kernel scope link scr ...
```
Isso indica que tudo que estiver na rede `10.0.0.0/24` vá para interface `enp0s2`

- `ip route del default`: remove a rota default
- `ip route add default via 192.168.1.1`: adiciona uma rota default (nesse caso vai anexar à interface que a rede `192.168.1.0` pertence)
- `ip route add defaul via 192.168.1.1 dev enp0s2`: nesse caso adiciona a rota default à interface desejada, que no caso é `enp0s2`.
- `ip route add 172.16.30.0/24 via 10.0.0.1 dev enp0s2` : todo tráfego que for para a rede `172.16.30.0` vai para a rede `10.0.0.1` (`dev enp0s2` é opcional, pois aqui também detecta pela rede),
- - `ip route del 172.16.30.0/24 via 10.0.0.1 dev enp0s2`: remove a rota criada anteriormente
- 
No comando ip, a  opção `-s` ou `--stats` ou `-statistics` também pode ser usada para obtenção de estatísticas, como pacotes enviados, recebidos e etc, por exemplo:
-   `ip -s address` 
-   `ip -s address show wlp3s0`
-   `ip -s link`
-   `ip -s link show wlp3s0`

#### net-tools (ifconfig e route)

-`ifconfig enp0s8 down`: baixa a interface (se der `ifconfig`, não mostrartá mais, para mostrar precisar usar `ifconfig -a` - display all interfaces which are currently available, even if `down`)
- `ifconfig enp0s8 up`: sobe a interface (vai voltar o que estiver no padrão do NetworkManager)
- `ifconfig enp0s8 10.0.0.100 netmask 255.255.255.0` (pode fazer por CIDR também: `10.0.0.100/24`): coloca o IP 10.0.0.100 na interface `enp0s8`.
- `ifconfig enp0s8 add 2001:db8::10/64`: configura IPv6 na interface.

*Note como, no IPv6, a palavra-chave  `add`  foi usada. Se um endereço IPv6 não for precedido por  `add`, será exibida uma mensagem de erro.

Se um interface já estiver down, e queira subir com IP, acrescente up no final do comando anterior, ficando:
```
ifconfig enp0s8 10.0.0.100 netmask 255.255.255.0 up
```
Adicionar mais de um IP na mesma interface: 

    ifconfig enp0s8:0 10.0.0.100 netmask 255.255.255.0
    ifconfig enp0s8:1 10.0.0.102 netmask 255.255.255.0
    etc

- `route`: mostra a tabela de roteamento (similar ao `ip route`). Rota `default` = `0.0.0.0`
- `route del default`: remove a rota default
- route add default gw 192.168.1.1: adiciona a rota default para o gateway 192.168.1.1
- `route add -net 172.16.30.0/24 gw 192.168.1.50`: tudo que chegar para a rede `172.16.30.0/24` mande para `192.168.1.50`.


#### Comandos Debug

- `hostname -d` (ou `--domain`): mostra o domínio
- `hostname -f` (ou `--fqdn` ou `--long`): mostra o full qualified domain name (nome completo - hostname + domínio). Nome de domínio pega do `/etc/hosts`. Pega informações do NIS domain name (ou do DNS). **NIS (Network Information Service)**, também conhecido como **YP (Yellow Pages)**, é um serviço de diretório usado em sistemas Unix e Linux para compartilhar informações administrativas de forma centralizada em uma rede. Ele é projetado para distribuir dados como usuários, senhas, grupos, informações de hosts, entre outros, para facilitar a administração de sistemas em redes locais.

O **YP domain name** (nome do domínio NIS) é o identificador que agrupa os servidores e clientes NIS que compartilham o mesmo conjunto de informações. Ele é essencial para que os clientes saibam de qual servidor NIS obter dados.

- `ping -c5 192.168.0.1`: dispara 5 `ECHO_REQUEST` para o host/IP, que por sua vez, se acessível, faz 5 `ECHO_REPLY`.
- `ping -c5 -i2 192.168.0.1`: dispara a cada 2 segundos (-i = interval)
- `ping www.google.com`: primeiro vai resolver o domínio, buscando em `/etc/hosts/` e depois no `DNS`. Lembrando que se não está resolvendo o domain name, pode ser que a conexão esteja tudo certo, mas algum problema no `DNS`. Caso esteja resolvendo o domain name e obtendo o IP, mas mesmo não retorna o ping, pode ter algum problema da rota padrão. Uma última opção de falha, seria algum firewall no caminho ou no próprio domínio, que as vezes pode estar configurado para não receber ICMP (por exemplo o domínio `www.lpi.org` não responde a pacotes ICMP)

O `ping` em linhas gerais, trabalha tanto em IPv4 como em IPv6, mas caso queira especificar:
- `ping -4`: especifica que é um endereço IPv4
- `ping -6`: especifica que é um endereço IPv6

Para testar o IPv6, rode `host ipv6.google.com`, para obter o endereço IPv6
- `ping6 2800:3f0:4001:804::200e`: faz o ping no domínio IPv6 do google (O PC assim como o roteador e sua ISP precisam estar preparados para IPv6 para conclusão do comando acima)

- `traceroute www.google.com`: imprime a rota que o pacote faz até chegar ao host  de destino (**NÃO** faz por **ICMP**, e sim por **UDP**)
- `traceroute -I www.google.com` (ou `--icmp`): imprime a rota que o pacote faz até chegar ao host  de destino **USANDO ICMP** (com `-I`, precisa ser **root**).
- `traceroute6 ipv6.google.com`: imprime a rota usando IPv6 (específico para `IPv6`)

Semelhante ao `traceroute` é o `tracepath`. O `tracepath` não precisa ser root para excutar, como acontece com algumas opções do `traceroute`. O tracepath também trabalha com pacotes `UDP`.

Veja a descrição do man do `tracepath`:<br>

*It traces the network path to destination discovering MTU along this path. It uses UDP port port or some random port. It is similar to traceroute. However, it does not require superuser privileges and has no fancy options. tracepath -6 is a good replacement for traceroute6 and classic example of application of Linux error queues. The situation with IPv4 is worse, because commercial IP routers do not return enough information in ICMP error messages. Probably, it will change, when they are updated. For now it uses Van Jacobson's trick, sweeping a range of UDP ports to maintain trace history.*

Entretanto `tracepath` é mais simples do que o `tracepath`. Para IPv6, tem o `tracepath6`

Exercícios interessantes
1. Qual subcomando de  `ip`  pode ser usado para configurar a marcação de vlan?<br>
`ip link`  tem uma opção  `vlan`  que pode ser empregada. Veja abaixo um exemplo de marcação de uma sub-interface com vlan 20.

    # ip link add link enp0s9 name enp0s9.20 type vlan id 20

2. Como fazer backup da tabela de roteamento? Como restaurar esse backup?
    
    O exemplo abaixo demonstra o backup e a restauração de uma tabela de roteamento:
  ```  
    # ip route save > /root/routes/route_backup
    # ip route restore < /root/routes/route_backup
```

3. Qual subcomando de  `ip`  pode ser usado para configurar opções de spanning tree?

Como no caso do gerenciamento de configurações de vlan, o  `ip link`  pode configurar o spanning tree usando o tipo  `bridge`. O exemplo mostra a adição de uma interface virtual com uma prioridade STP de 50:

    # ip link add link enp0s9 name enp0s9.50 type bridge priority 50

#### comando ss e netstat

O `ss` é um comando do pacote `ip route` (mais moderno). O `netstat` pertence ao pacote `net-tools` (mais antigo). Ambos são utilizados para ver as conexões ativas no computador.

    $ whatis ss
    ss (8)               - another utility to investigate sockets
    $ whatis netstat
    netstat (8)          - Print network connections, routing tables, interface statistics, masquerade connections, and multicast...

Eis algumas opções disponíveis para ambos os programas (`ss` e `netstat`):
- `-a`: Mostra todos os sockets.
- `-l`: Mostra os sockets de escuta.
- `-p`: Mostra o processo associado à conexão.
- `-n`: Impede pesquisas de nome para portas e endereços.
- `-t`: Mostra as conexões TCP.
- `-u`: Mostra as conexões UDP.

- `ss`: mostra todas as conexões (e sockets) da máquina (inclusive para abertura de arquivos - que também usam socket)
- `ss -tu` (`-t` ou `--tcp` e `-u` ou `--udp`): lista conexões dos pacotes TCP e UDP estabelecidas no momento (mostra apenas conexões estabelecidas).
- `ss -a` (`--all`): mostra ambas `listening` e `non-listening` sockets
- `ss -l (--listening)`: mostra sockets que estão somente em `listening`(normalmente esses já são omitidos por padrão)

As formas vistas até agora, o comando ss resolve o nome das portas, em vez de colocar o número delas, assim como os hosts, para não resolver, use `-n`:
- `ss -tuln`: mostra sockets somente em `listening`, que sejam TCP e UDP e não resolve os nomes (mostrando o número da porta em si, e não a sua descrição - a descrição é obtida em `/etc/services`)

Com o `netstat`, vai funcionar normalmente, mudando apenas um pouco o formato: `netstat -tuln`

- `netstat ou ss -tanp`: mostra as conexões da porta TCP e UDP, com estado de `listening`, não resolvendo nomes e portas e relacionando o serviço com seu respectivo `PID` (`-p`).

Os exemplos abaixo mostram a saída de um conjunto de opções comumente usado em ambos os programas:

    # netstat -tulnp
    Active Internet connections (only servers)
    Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
    tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      892/sshd
    tcp        0      0 127.0.0.1:25            0.0.0.0:*               LISTEN      1141/master
    tcp6       0      0 :::22                   :::*                    LISTEN      892/sshd
    tcp6       0      0 ::1:25                  :::*                    LISTEN      1141/master
    udp        0      0 0.0.0.0:68              0.0.0.0:*                           692/dhclient
    # ss -tulnp
    # ss -tulnp
    Netid  State      Recv-Q Send-Q      Local Address:Port                     Peer Address:Port
    udp    UNCONN     0      0                       **:68                                  *:**                   users:(("dhclient",pid=693,fd=6))
    tcp    LISTEN     0      128                     **:22                                  *:**                   users:(("sshd",pid=892,fd=3))
    tcp    LISTEN     0      100             127.0.0.1:25                                  **:**                   users:(("master",pid=1099,fd=13))
    tcp    LISTEN     0      128                  [::]:22                               [::]:*                   users:(("sshd",pid=892,fd=4))
    tcp    LISTEN     0      100                 [::1]:25                               [::]:*                   users:(("master",pid=1099,fd=14))

A coluna  `Recv-Q`  é o número de pacotes que um socket recebeu, mas não passou para seu programa. A coluna  `Send-Q`  é o número de pacotes que um socket enviou e que não foram confirmados pelo receptor. As colunas restantes são autoexplicativas.

Alguns exercícios interessantes

1. Qual comando poderia mostrar se há processos escutando na porta TCP 80?

Com  `ss`:

    $ ss -ln | grep ":80"

Com  `netstat`:

    $ netstat -ln | grep ":80"

Embora este não seja um requisito para o exame, você também poderia usar  `lsof`:

    # lsof -Pi:80

2. Como forçar o  `traceroute`  a usar uma interface diferente?

Usando a opção  `-i`:

    $ traceroute -i eth2 learning.lpi.org
    traceroute -i eth2 learning.lpi.org
    traceroute to learning.lpi.org (208.94.166.201), 30 hops max, 60 byte packets

3. O  `traceroute`  é capaz de relatar MTUs?

Sim, com a opção  `--mtu`:

    # traceroute -I --mtu  learning.lpi.org
    traceroute to learning.lpi.org (208.94.166.201), 30 hops max, 65000 byte packets
     1  047-132-144-001.res.spectrum.com (47.132.144.1)  9.974 ms **F=1500**  10.476 ms  4.743 ms
     2  096-034-094-106.biz.spectrum.com (96.34.94.106)  8.697 ms  9.963 ms  10.321 ms
    ...

#### netcat

Usado para teste de conexão no computador ou para abrir conexões locais. (arbitrary TCP and UDP connections and listens)

- `netcat 127.0.0.1 22`: teste localmente se é possível conectar na porta 22 (funciona parecido com `telnet`).

>[!NOTE]
>
>`netcat` e `nc` são o mesmo comando.

- `nc -l -p 1234`: abre a porta `1234` para ficar em `listening`. (`-l` = Listen for an incoming connection rather than initiating a connection to a remote host) e (`-p` = source_port: specify the source port `nc` should use, subject to privilege restrictions and availability)
- `nc 192.168.0.20 1234`: conecta na conexão aberta anteriormente (se digitar algo, aparece na outra ponta que está abrindo a conexão)
- `nc -vz 192.168.0.20 1234`: mostra uma mensagem se a conexão foi com sucesso. (`-v` Produce more verbose output) e (`-z` Only scan for listening daemons, without sending any data to them.  Cannot be used together with `-l`.)
- `nc -k -l -p 1234`: mantém a conexão para testes (`-k` When a connection is completed, listen for another one.  Requires `-l`.  When used together with the `-u` option, the server socket is not  connected and it can receive UDP datagrams from multiple hosts.)
- `nc -vz 192.168.0.20 1230-1240`: teste o range de portas definido entre `1230` e `1240`

O netcat funciona com endereços IPv4 e IPv6. Ele funciona com TCP e UDP. Pode inclusive ser usado para configurar um **shell remoto rudimentar**.
```
    $ hostname
    net2
    $ nc -u -e /bin/bash -l 1234
```
A opção  `-u`  significa UDP.  `-e`  instrui o netcat a enviar tudo o que recebe para a entrada padrão do executável que vem em seguida. Neste exemplo,  `/bin/bash`.

    $ hostname
    net1
    $ **nc -u net2.example.net 1234
    hostname
    net2
    pwd
    /home/emma

Percebeu como a saída do comando  `hostname`  corresponde à do host ouvinte e a saída do comando  `pwd`  é um diretório?

>[!WARNING]
>
>Nem toda instalação de  `nc`  suporta a opção  `-e`. Consulte as páginas de manual de sua instalação para obter informações de segurança sobre esta opção, bem como métodos alternativos para executar comandos em um sistema remoto.


## 109.4 Configurar o DNS do lado do cliente

- `/etc/hosts`: referências fixas entre IP e Nomes
- `/etc/nsswitch.conf`: determinar se a primeira consulta vai ser nos arquivos internos (padrão, como `hosts`)
- `/etc/resolv.conf`: arquivo principal onde é adicionado os servidores DNS (indicado por `nameserver`). Aqui que pode ter configuração de domínio: `domain dominio.com.br`
- `/etc/resolv.conf` está sendo gerado por  `/run/systemd/resolve/stub-resolv.conf` (resolvedor interno, pelo serviço `systemd.resolvd`)
- comando `resolvectl status` para ver os DNS configurados propriamente dito
- comando `resolvectl statistics` mostra estatísticas do servidor DNS, com cache, total de transações, etc.

A opção  `search` (em `/etc/resolv.conf`)  é usada para permitir pesquisas curtas. No exemplo, configuramos um único domínio para pesquisa,  `lpi.org`. Isso significa que qualquer tentativa de resolver um nome de host sem uma parte de domínio terá  `.lpi.org`  incluído antes da pesquisa. Por exemplo, se pesquisarmos por um host chamado  `learning`, o resolvedor buscará por  `learning.lpi.org`. É possível configurar até seis domínios de pesquisa.

Outra opção comum é  `domain`. Ela é usada para definir o nome de domínio local. Se esta opção estiver ausente, o padrão é usar tudo após o primeiro  `.`  no nome de host da máquina. Se o nome do host não contiver um  `.`, presume-se que a máquina faça parte do domínio raiz. Como no caso de  `search`,  `domain`  pode ser usado para pesquisas curtas de nomes.

Lembre-se de que  `domain`  e  `search`  são mutuamente exclusivos. Se ambos estiverem presentes, será usada a última instância no arquivo.

Muitas opções podem ser definidas de forma a afetar o comportamento do resolvedor. Para configurá-las, use a palavra-chave  `option`, seguida pelo nome da opção a ser configurada e, se for o caso, um  `:`  seguido pelo valor. Veja abaixo um exemplo de configuração da opção de tempo limite (timeout), ou seja, o período de tempo em segundos que o resolvedor espera por um servidor de nome antes de desistir:

    option timeout:3

O systemd inclui um serviço chamado `systemd-resolved`. Ele fornece mDNS, DNS e LLMNR. Quando está em execução, ele escuta as solicitações de DNS em `127.0.0.53`. Ele _não_ fornece um servidor DNS completo. Quaisquer solicitações de DNS que recebe são pesquisadas nos servidores configurados em `/etc/systemd/resolv.conf` ou `/etc/resolv.conf`. Se você deseja empregar o serviço, use `resolve` para `hosts` em `/etc/nsswitch.conf`. Lembre-se de que o pacote do sistema operacional que possui a biblioteca `systemd-resolution` pode não estar instalado por padrão

- `getent`, é útil para ver como as solicitações do mundo real serão resolvidas.
- `host`, é ótimo para consultas de DNS simples. 
- `dig` é prático para operações de DNS complexas que podem ajudar na resolução de problemas do servidor DNS.

- `host www.debian.org`: usa o servidor DNS para resolver o endereço www.debian.org. Se retirar o `www`, mostra todos os IPs relacionados ao domínio.
- `host www.debian.org 1.1.1.1`: consulta usando o server `1.1.1.1`
- `host -t mx debian.org`: mostra quais são os servidores que recebem query relacionadas aos emails no domínio. (`-t type`: This option specifies the query type. The type argument can be any recognized query type: `CNAME`, `NS`, `SOA`, `TXT`, `DNSKEY`, `AXFR`, etc)

- `dig` (antigamente usava `nslookup`): parecido com `host`, mas tem mais opções (internamente consulta o `systemd-resolve`).
- `dig www.debian.org @1.1.1.1`: consulta usando o server `1.1.1.1`
- `dig www.debian.org +short`: mostra só o IP (retira outros cabeçalhos)
- `dig -x 200.45.31.18`: resolve reverse lookups (mostra o nome associado ao IP)

- `getent`: pela entradas do Name Service Switch libraries (`/etc/nsswitch.conf`)
- `getent passwd`: mostra informações do `/etc/passwd`
- `getent passwd rodrigo`: mostra informações do usuário rodrigo
- `getent hosts www.debian.org`: resolve o domínio (tende resolver IPv6 - diferentemente de `host www.debian.org`, que traz IPv4 e IPv6)
- `getent ahostsv4 www.debian.org`: resolve em IPv4

Databases suportadas:
`ahosts` `ahostsv4` `ahostsv6` `aliases` `ethers` `group` `gshadow` `hosts` `initgroups` `netgroup` `networks` `passwd` `protocols` `rpc` `services` `shadow` (lembrar que `/etc/nsswitch.conf` que aponta por meio de `db files`)

Exercicios interessantes

1. Qual das opções a seguir é uma entrada correta de  `/etc/hosts`  entry?

| | |
|---|---|
|  ::1 localhost | certo |
| **localhost 127.0.0.1** | errado  |

`::1 localhost`  é a linha correta. A coluna da esquerda é sempre um endereço IPv4 ou IPv6.

2. O que significa a seguinte linha em  `/etc/nsswitch.conf`?
```
    hosts: files [SUCCESS=continue] dns
```
As pesquisas por nomes de host verificarão primeiro os arquivos de  `/etc/hosts`  e em seguida o DNS. Se uma entrada for encontrada nos arquivos e no DNS, a entrada no DNS será preferida.

3. O que faz o comando  `dig +noall +answer +question lpi.org`?

Ele pesquisa o registro A de  `lpi.org`  e exibe apenas a consulta e a resposta.

4. Como passar por cima dos padrões de  `dig`  sem especificá-los na linha de comando?

Criando um arquivo  `.digrc`  em seu diretório inicial

## 110.1 Executar tarefas administrativas de segurança

#### su e sudo
- `su`: muda de usuário para outro (loga como `root`: precisa digitar a senha do `root`)
- `sudo su`: loga como root usando a senha do usuário normal.

- `su lpi2`: loga com usuário `lpi2` (apenas muda o usuário - não executa o `.profile`, não cai no `home` do usuário propriamente dito)
- `su - lpi2`: loga com usuário `lpi2` (faz um novo login, como usuário `lpi2`, executando o `.profile` e caindo no home do usuário `lpi2`)
- `su -`: o mesmo que o explicado anteriormente. (aqui é feito um login propriamente dito, carrega as informações de `.profile`). Só `su` não faz efetivamente login.

Há alguns comandos que exigem que seja executado somente pro user root, como o `fdisk`, por exemplo.

Para executar uma vez, estando com usuário lpi1: `su -c "fdisk -l` (vai pedir senha do usuário root - `-c` = `--command`). Depois de executar volta ao usuário comum.

O `sudo` serve para situações que você não tenha a senha do usuário root (comum em ambientes de produção), e que precisa executar algo com privilégios de root.
- `sudo su -`: se estiver logado como `lpi1`, vai pedir a senha de `lpi1`, e loga como `root`. (isso porque `lpi1` tem permissões de logar como `root`)

Agora caso seja um usuário que não tenha permissão, e tente se logar, teremos a seguinte mensagem de erro:
```
$ sudo su -
[sudo] password for lpi2:    
Sorry, user lpi2 is not allowed to execute '/usr/bin/su -' as root on computer-name.

ou

lpi2 is not in the sudoers file. This incident will be reported.
```

Caso possua as permissões, pode simplesmente executar comandos como root usando: `sudo fdisk -l`

- `/etc/sudoers`: arquivo de configuração que vai dizer o que quais usuário podem fazer as alterações no sistema. A `%`no sufixo dos nomes `admin` e `sudo` indica que tanto `%admin` como `%sudo` são grupos.
- `%admin = ALL=(ALL) ALL`: membros do grupo `admin`, podem a partir de qualquer terminal (primeiro `ALL`), utilizando qualquer usuário (segundo `ALL`), podem executar qualquer comando (terceiro `ALL`)
- `%sudo ALL=(ALL:ALL) ALL`: mesmo raciocínio, agora para o grupo `sudo`. O usuário criado na instalação, muito provavelmente estará nesse grupo. Confirme com o comando `grep sudo /etc/group`. Para adicionar um usuário ao grupo `sudo`, digite: `sudo usermod -aG sudo usuario`. Para remover use: `sudo usermod -rG sudo usuario`

Se quiser personalizar uma regra, por exemplo para determinar que usuário `lpi2` possa desligar o computador, inclua o seguinte no arquivo `/etc/sudoers`

    lpi2 ALL=/sbin/poweroff

Caso queira listar os comandos que deseja liberar (lembrando vai pedir a senha do usuário, o que vai acontecer é como se estivesse no grupo `sudo`):

    Cmnd_Alias TESTE = /sbin/fdisk, /sbin/parted
    lpi2  ALL=TESTE

- `visudo`: vai direto para edição do `/etc/sudoers` (usando o editor padrão - para alterar o editor padrão: `update-alternatives --config editor`)

**Observações**: O  `sudo`  permite executar comandos simples com privilégios elevados em vez de lançar um novo subshell para root, como faria  `su`.
    
O uso básico de  `sudo`  é  `sudo -u  _target-username_  _command_`. Porém, para executar um comando como usuário root, a opção  `-u  _target-username_`  não é necessária:

    carol@debian:~$ sudo -u mimi whoami
    mimi
    carol@debian:~$ sudo whoami
    root

>[!NOTE]
>
>O  `sudoers`  usa uma marca temporal por usuário (e por terminal) para ocultar as credenciais, sendo assim possível usar o  `sudo`  sem uma senha por um período padrão de quinze minutos. Esse valor padrão pode ser modificado adicionando-se a opção  `timestamp_timeout`  como configuração de  `Defaults`  em  `/etc/sudoers`  (p. ex.:  `Defaults timestamp_timeout=1`  define o tempo limite do cache de credenciais como um minuto).

#### O arquivo  `/etc/sudoers`

O arquivo de configuração principal do  `sudo`  é  `/etc/sudoers`  (também existe o diretório  `/etc/sudoers.d`). É ali que os privilégios de  `sudo`  dos usuários são determinados. Em outras palavras, aqui você especifica quem pode executar quais comandos, sob quais nomes de usuário e em quais máquinas — bem como outras configurações. A sintaxe usada é a seguinte:

    carol@debian:~$ sudo less /etc/sudoers
    (...)
    # User privilege specification
    root    ALL=(ALL:ALL) ALL
    
    # Allow members of group sudo to execute any command
    %sudo   ALL=(ALL:ALL) ALL
    (...)

A especificação de privilégio para o usuário root é  `ALL=(ALL:ALL) ALL`. Isso se traduz assim: o usuário root (`root`) pode se logar com todos os hosts (`ALL`), em nome de todos os usuários e todos os grupos (`(ALL:ALL)`), além de executar todos os comandos (`ALL`). O mesmo vale para os membros do grupo  `sudo` — note como os nomes de grupos são identificados com um símbolo de porcentagem (`%`).

Assim, para que a usuária  `carol`  seja capaz de verificar o status de  `apache2`  de qualquer host em nome de qualquer usuário ou grupo, adicionaríamos a seguinte linha ao arquivo  `sudoers`:

    carol   ALL=(ALL:ALL) /usr/bin/systemctl status apache2

Para evitar a  `carol`  o incômodo de precisar fornecer sua senha para executar o comando  `systemctl status apache2`, modificamos a linha desta maneira:

    carol   ALL=(ALL:ALL) NOPASSWD: /usr/bin/systemctl status apache2

Digamos que agora você queira restringir seus hosts a 192.168.1.7 e permitir que  `carol`  execute  `systemctl status apache2`  no nome da usuária  `mimi`. A linha teria de ser modificada desta forma:

    carol   192.168.1.7=(mimi) /usr/bin/systemctl status apache2

Vamos então verificar o status do servidor web Apache como a usuária  `mimi`:

    carol@debian:~$ sudo -u mimi systemctl status apache2
    ● apache2.service - The Apache HTTP Server
       Loaded: loaded (/lib/systemd/system/apache2.service; enabled; vendor preset: enabled)
       Active: active (running) since Tue 2020-06-09 13:12:19 CEST; 29min ago
    (...)

Se  `carol`  fosse promovida a sysadmin e você quisesse conceder a ela todos os privilégios, a maneira mais fácil seria incluí-la no grupo especial  `sudo`  com  `usermod`  e a opção  `-G`  (e talvez também a opção  `-a`, que garante que o usuário não seja removido de nenhum outro grupo ao qual possa pertencer):

    root@debian:~# sudo useradd -aG sudo carol

>[!NOTE]
>
>Na família de distribuições Red Hat , o grupo  `wheel`  é equivalente ao grupo especial de administradores  `sudo`  dos sistemas Debian.

Além dos usuários e grupos, também podemos utilizar aliases em  `/etc/sudoers`. É possível definir três categorias principais de aliases:  _aliases de host_  (`Host_Alias`),  _aliases de usuário_  (`User_Alias`) e  _aliases de comando_  (`Cmnd_Alias`). Eis um exemplo:

    # Host alias specification
    
    Host_Alias SERVERS = 192.168.1.7, server1, server2
    
    # User alias specification
    
    User_Alias REGULAR_USERS = john, mary, alex
    
    User_Alias PRIVILEGED_USERS = mimi
    
    User_Alias ADMINS = carol, %sudo, PRIVILEGED_USERS, !REGULAR_USERS
    
    # Cmnd alias specification
    
    Cmnd_Alias SERVICES = /usr/bin/systemctl *
    
    # User privilege specification
    root    ALL=(ALL:ALL) ALL
    ADMINS  SERVERS=SERVICES
    
    # Allow members of group sudo to execute any command
    %sudo   ALL=(ALL:ALL) ALL

A partir deste arquivo  `sudoers`  de amostra, vamos explicar os três tipos de aliases com um pouco mais de detalhes:

- **Aliases de host**: Incluem uma lista separada por vírgulas de nomes de host, endereços IP, redes e grupos de rede (precedidos por  `+`). Máscaras de rede também podem estar especificadas. O alias de host  `SERVERS`  inclui um endereço IP e dois nomes de host:
```
Host_Alias SERVERS = 192.168.1.7, server1, server2
```
- **Aliases de usuário**: Incluem uma lista separada por vírgulas de usuários especificados como nomes de usuários, grupos (precedidos por  `%`) e grupos de rede (precedidos por  `+`). Para excluir usuários específicos, usamos  `!`. O alias de usuário  `ADMINS` — por exemplo — inclui a usuária  `carol`, os membros do grupo  `sudo`  e os membros do alias de usuário  `PRIVILEGE_USERS`  que não pertencem ao alias de usuário  `REGULAR_USERS`:
```
User_Alias ADMINS = carol, %sudo, PRIVILEGED_USERS, !REGULAR_USERS
```
- **Aliases de comando**: Incluem uma lista separada por vírgulas de comandos e diretórios. Se um diretório for especificado, qualquer arquivo que esteja nesse diretório será incluído — mas os subdiretórios serão ignorados. O alias do comando  `SERVICES`  inclui um único comando com todos os seus subcomandos — conforme especificado pelo asterisco (`*`):
```
Cmnd_Alias SERVICES = /usr/bin/systemctl *
```
Como resultado das especificações de alias, a linha  `ADMINS SERVERS=SERVICES`  na seção  `User privilege specification`  é traduzida como: todos os usuários pertencentes a  `ADMINS`  podem usar  `sudo`  para executar qualquer comando em  `SERVICES`  em qualquer servidor em  `SERVERS`.

>[!NOTE]
>
>Existe um quarto tipo de alias que pode ser incluído em  `/etc/sudoers`:  _aliases de execução_  (`Runas_Alias`). São muito semelhantes aos aliases de usuário, mas permitem especificar usuários por seu  _ID de usuário_  (UID). Esse recurso pode ser conveniente em certos casos.

#### who, w, last, lastb, lastlog

- `who`: mostra quem está logado no sistema, mostrando usuário, o terminal (`tty7` = terminal gráfico) e horário que logou. Se apertar `Ctrl+Alt+F2` (vai para o `tty2`), e se logar por lá, voltar para o `tty` e digita novamente `who`, vai mostrar a sessão de `tty2`
- `who -aH` (`-a` = `--all` e `-H` = `--heading`, colocar um header): mostra mais detalhes, assim como os terminais que não estão em uso, mostra também o `pid`.

O `who` aceita uma série de opções, dentre as quais podemos destacar as seguintes:
- `-b`,`--boot`: Exibe a hora da última inicialização do sistema.
- `-r`,`--runlevel`: Mostra o nível de execução atual.
- `-H`,`--heading`: Imprime o cabeçalho das colunas.

- `w`: mostra quem está logado e o que está fazendo (Show who is logged on and what they are doing.). Se voltar lá no `tty2` e executar o `top`, voltar para `tty7` e digitar `w`, mostra todas as informações do que o usuário que logou no `tty2` está fazendo, quanto está consumindo, etc. **JCPU** = uso de CPU no geral, **PCPU** = quanto o processo que está sendo executado (`top`) está consumindo. Ideal para monitorar sessões que estão consumindo muito recurso do computador.

>[!NOTE]
>
>Comparado ao  `who`, o  `w`  fornece uma saída um pouco mais detalhada:

Como no caso do  `who`, podemos passar nomes de usuários ao  `w`: `root@debian:~# w lpi2`

- `last`: histórico de logins no computador. Mostra o usuário que logou, o terminal que usou, quando foi feito o login, e quanto tempo ficou logado.
- `last lpi2`: mostra os últimos logins do usuário `lpi2`
- `lastb`: histórico de usuários que tentaram se logar, mas erraram a senha, ou usuário não existia. Esses dados (do `last`) são consultados de `/var/log/wtmp` (arquivo binário). Para ler usar last -f `/var/log/wtmp` (`-f` ou `--file`). O `lastb` é lido em `/var/log/btmp`. Para ler faz igual ao last: `last -f /var/log/btmp`

- `lastlog`: mostra quando os usuários do sistema fizeram login (login mesmo, não conta `su -`). `Observação`: usuários de sistema normalmente não devem ter feito login (precisa mostrar como `Never logged in`.
- `lastlog -u rodrigo` (`-u` ou `--user`): mostra o último login do usuário `lpi2`

#### passwd, usermod e chage

- `chage`: muda as definições de tempo para a senha expirar, conta inativa. Olhar novamente no item 107.1 parte 4. Similar ao `passwd`

- `passwd -S lpi2` (`-S` ou `--status`): mostra o status do usuário `lpi2`
```
lpi1@debian:~$ passwd -S
lpi1 P 12/07/2019 0 99999 7 -1
```
Eis uma análise dos sete campos obtidos na saída:
- `lpi1`: Nome de login do usuário.
- `P`: Indica que o usuário possui uma senha válida (`P`); outros valores possíveis são  `L`  para uma senha bloqueada e  `NP`  para nenhuma senha.
- `12/07/2019`: Data da última alteração da senha.
- `0`: Idade mínima em dias (o número mínimo de dias entre mudanças de senha). Um valor de  `0`  significa que a senha pode ser alterada a qualquer momento.
- `99999`: Idade máxima em dias (o número máximo de dias em que a senha é válida). Um valor de  `99999`  desabilita a expiração da senha.
- `7`: Período de aviso em dias (o número de dias antes da expiração da senha em que um usuário será avisado).
- `-1`: Período de inatividade da senha em dias (o número de dias inativos após a expiração da senha até que a conta seja bloqueada). Um valor de  `-1`  remove a inatividade de uma conta.

- `passwd -x30 lpi2` (`-x` ou `--maxday`): define para a senha expirar daqui `30` dias. (consulte com `chage -l lpi2`) (similar ao `chage -M` ou `--maxdays`)
```
chage -l lpi2
Last password change					: Nov 13, 2024
Password expires					: Dec 13, 2024
Password inactive					: never
Account expires						: never
Minimum number of days between password change		: 0
Maximum number of days between password change		: 30 #definiu aqui
Number of days of warning before password expires	: 7
```
- `passwd -n2 lpi2` (ou `--mindays`): define o mínimo de dias que o usuário pode trocar a senha. Similar ao `chage -m` ou `--mindays`.

- `passwd -w4 lpi2` ( ou`--warndays`): número de dias que vai alertar que a senha vai expirar (Number of days of warning before password expires). No `chage`, seria `chage -W` ou `--warndays`
- `passwd -i10 lpi2` (ou `--inactive`): depois de 10 dias que a conta expirar, a conta vai ficar inativa. O `chage` seria `chage -I` ou `--inactive`
- `passwd -l lpi2` (ou `--lock`): trava (lock) o usuário `lpi2` (colocar `!` no primeiro caractere do campo de senha do `/etc/shadow`) - usando quando precisa investigar o usuário. Para destravar `passwd -u lpi1` (ou `--unlock`): retira a exclamação `/etc/shadow`. Quando estiver lock, no `passwd -S lpi2` vai mostrar um `L` de `Locked`. Se estiver `unlocked`, vai mostrar um `P` de `Password`. No `chage` seria `chage -E` ou `--expiredate` para fazer lock do usuário e `chage -1` para deixar `unlocked`

- `usermod -L lpi2` (ou `--lock`): trava (lock) o usuário
- `usernod -U lpi2` (ou `--unlock`): remove lock da conta.
- `usermod -e lpi2` (ou `--expiredate`): colocar uma data de expiração.
- `usermod -f lpi2` (ou `--inactive`): quantidade de dias que vai ficar inativo quando expirar a senha

#### find, ulimit, limits.conf

Partindo do cenário que `/usr/bin/passwd` tem o bit **SUID** ligado (`rwsr-xr-x`) e que qualquer usuário pode executá-lo como `root` e, diferentemente de `/bin/rm`, que por segurança não possui bit **SUID** ligado (pois qualquer usuário poderia excluir pastas críticas), é interessante monitorar por arquivos com **SUID** ligado, com o comando find.

- `find / -perm -4000 -ls` (ou `-2000`): `4000` procura por **SUID** e `2000` pelo **SGID** (o `-ls` no final é apenas para listar).
- `find / \( -perm -2000 -o -perm -4000 \) -ls
`: procura tanto por **SUID** como por **GUID** (precisa proteger com parênteses e escapá-los - o `-o` = or/ou).
- `find / -perm /6000`: busca tanto **SUID** como **GUID**

>[!NOTE]
>
>Pode usar com a notação simbólica: `find / -perm -u+s` para 4000 ou `find / -perm -g+s` para 2000.

Situação ideal seria criar um script que guarde essa informação diariamente, e compare, e caso haja mudança emita um alerta ao Administrador.

Outra medida de segurança é buscar por arquivos que não tenham usuários associados, novamente com o `find`:
- `find / -path /proc -prune -nouser -ls`: mostra todos

Alguns exercícios interessantes dessa seção:

1. O `chage` permite alterar as informações de expiração de senha de um usuário. Como root, complete a seguinte tabela, fornecendo os comandos corretos para o usuário `mary`:
2. 
| Significado           | Comandos `chage`                  |
|---------------------------|--------------------------------------|
| Faça a senha ser válida por 365 dias.                                       | `chage -M 365 mary`, `chage --maxdays 365 mary`                             |
| Faça o usuário alterar a senha no próximo login.                           | `chage -d 0 mary`, `chage --lastday 0 mary`                                 |
| Defina o número mínimo de dias entre as alterações de senha para 1.         | `chage -m 1 mary`, `chage --mindays 1 mary`                                 |
| Desative a expiração da senha.                                              | `chage -M 99999 mary`, `chage --maxdays 99999 mary`                         |
| Permita que o usuário altere sua senha a qualquer momento.                  | `chage -m 0 mary`, `chage --mindays 0 mary`                                 |
| Defina o período de aviso para 7 dias e a data de expiração da conta para 20 de agosto de 2050. | `chage -W 7 -E 2050-08-20 mary`, `chage --warndays 7 --expiredate 2050-08-20 mary` |
| Imprima as informações de validade da senha atual do usuário.               | `chage -l mary`, `chage --list mary`                                        |

2. Considere a seguinte linha de saída de comando  `last`  e responda às perguntas:
```
carol    pts/0        192.168.1.4      Sun May 31 14:16 - 14:22  (00:06)
```
-   `carol`  estava conectada a partir de um host remoto? Por quê?
    Sim, o endereço IP do host remoto está na terceira coluna.
    
-   Quanto tempo durou a sessão de  `carol`?
    Seis minutos (como mostrado na última coluna).
    
-   `carol`  estava conectada através de um terminal de texto clássico? Por quê?
    Não,  `pts/0`  na segunda coluna indica que a conexão foi feita por meio de um emulador de terminal gráfico (ou  _Pseudo Terminal Slave_).

3. Além de  `SUID`  e  `SGID`, existe uma terceira permissão especial: o  _sticky bit_. No momento, ele é usado principalmente em diretórios como  `/tmp`  para evitar que usuários regulares excluam ou movam arquivos que não sejam seus. Realize as seguintes tarefas:

-   Defina o  _sticky bit_  em  `~/temporal`:
    ```
    `chmod +t temporal`,  `chmod 1755 temporal`
    ```
-   Encontre diretórios com o  _sticky bit_  (e quaisquer outras permissões) definidas em seu diretório inicial:
    ```
    `find ~ -perm -1000`,  `find ~ -perm /1000`
    ```
-   Remova o  _sticky bit_  de  `~/temporal`:
    ```
    `chmod -t temporal`,  `chmod 0755 temporal`
    ```
## 110.2 Configurar a segurança do host



## 110.3 Proteção de dados com criptografia

#### O que é criptografia

Uma maneira de garantir que dados sejam enviados de um ponto a outro de maneira segura, tendo os objetivos principais:
	- Autenticidade (do remetente)
	- Confidencialidade (da mensagem)
	- Integridade (da mensagem)
	- Irretratabilidade (do remetente)

#### SSH - Secure Shell

- protocolo de criptográfica de rede
- cria um canal seguro de comunicação entre 2 hosts, um cliente

# LPIC-1 Exam 101
#### Version: 5.0
LPIC-1 é a primeira certificação no programa de certificação profissional Linux multinível da LPI. O LPIC-1 validará a capacidade do candidato de realizar tarefas de manutenção na linha de comando, instalar e configurar um computador executando Linux e configurar a rede básica.

# Parte 2

## 102-500

### 105.1 Personalizar e trabalhar no ambiente shell

Relembrando:
- `env` ou `printenv`: imprime uma lista de todas as variáveis de ambiente

- `printenv` ainda pode ser usado de forma semelhante ao comando `echo`:<br>

    $ echo $PWD
    /home/user2
    $ printenv PWD
    /home/user2
Note, entretanto, que com `printenv` o nome da variável não é precedido por `$`.

- `echo $TESTE`: lê o valor da variável TESTE
- `TESTE=valor1`: define um valor para a variável TESTE
- `env | grep TESTE`: não encontra nada da variável TESTE pois ela não foi exportada, está localmente apenas
- `set | grep TESTE`: mostra tanto as locais de ambiente, como as exportadas de usuário.

>[!NOTE]
>
>Para remover variáveis definidas (locais ou globais), usamos o comando  `unset`:

    $ echo $reptile
    tortoise
    $ unset reptile
    $ echo $reptile
    $

>[!NOTE]
>
>`unset` deve ser seguido somente pelo nome da variável (não precedido pelo símbolo `$`)

Se tivermos um script que lê essa variável TESTE, ao executá-lo ele não irá ler, pois quando é executado um script ele cria abre em uma nova sessão do shell/bash (processo filho do shell atual), logo essa variável teria que estar exportada.

É possível contornar isso com o comando **source**. Ele faz com que seja executado no mesmo shell da sessão atual, dessa forma retornando o valor de TESTE.

Outra forma é utilizar o ponto (.): `. script.sh` (faz rodar/executar localmente o script, sem chamar outra sessão de bash) (**NÃO** confundir com `./script.sh`)

Para criarmos variáveis imutáveis, basta a deixarmos como **readonly** (somente leitura).<br>
Ex. `readonly reptile=tortoise`<br>
Ou transformá-las depois de criá-las:<br>

    reptile=tortoise
    readonly reptile

Agora, se tentarmos alterar o valor de  `reptile`, o Bash se recusará:

    $ reptile=lizard
    -bash: distro: readonly variable

>[!NOTE]
>
>Para listar todas as variáveis somente leitura da sessão atual, digite `readonly` ou `readonly -p` no terminal

Para que uma variável local do shell se torne uma variável de ambiente, usamos o comando  `export`:

    $ export reptile

Com  `export reptile`, transformamos nossa variável local em uma variável de ambiente para que os shells filhos possam reconhecê-la e usá-la:

    $ bash
    $ echo $reptile
    tortoise

Da mesma maneira,  `export`  pode ser usado para definir e exportar uma variável de uma só vez:

    $ export amphibian=frog

Agora podemos abrir uma nova instância do Bash e referenciar com sucesso a nova variável:

    $ bash
    $ echo $amphibian
    frog

>[!NOTE]
>
>Com `export -n <VARIABLE-NAME>`, a variável será novamente transformada em variável local do shell.

- `export` ou `export -p`: lista todas as variáveis de ambiente existentes. (`declare -x` é equivalente a `export`)

Comando `alias`: cria alias para os comandos (sinônimos de comandos)

`alias dt="date +%H:%M"`: cria um alias chamado **dt** que vai executar o comando date mostrando apenas hora e minuto (se deslogar, perde a configuração, é apenas temporário)

Se digitar somente `alias`, é mostrado os alias cadastrados no bash atual.

- `unalias alias_criado`: remove o alias criado

Podemos escapar um alias com  `\`:

    $ alias where?='echo $PWD'
    $ where?
    /home/user2
    $ \where?
    -bash: where?: command not found

O escape de um alias é útil quando um alias tem o mesmo nome de um comando regular. Nesse caso, o alias tem precedência sobre o comando original, que, no entanto, ainda pode ser acessado escapando-se o alias.

Da mesma forma, podemos colocar um alias dentro de outro alias:

    $ where?
    /home/user2
    $ alias my_home=where?
    $ my_home
    /home/user2

Além disso, também é possível colocar uma função dentro de um alias, como será demonstrado mais adiante.

#### Expansão e avaliação de aspas em aliases

Ao se usar aspas com variáveis de ambiente, as aspas simples tornam a **expansão dinâmica**:

    $ alias where?='echo $PWD'
    $ where?
    /home/user2
    $ cd Music
    $ where?
    /home/user2/Music

No entanto, com aspas duplas, a expansão é feita **estaticamente**:

    $ alias where?="echo $PWD"
    $ where?
    /home/user2
    $ cd Music
    $ where?
    /home/user2

#### Persistência de aliases: scripts de inicialização

Como no caso das variáveis, para que nossos aliases se tornem persistentes devemos colocá-los em scripts de inicialização que são originados quando o sistema é iniciado. Como já sabemos, um bom arquivo para os usuários colocarem seus aliases pessoais é  `~/.bashrc`. Já deve haver alguns aliases por lá (a maioria deles comentados e prontos para uso, bastando remover o  `#`  inicial):

    $ grep alias .bashrc
    # enable color support of ls and also add handy aliases
        alias ls='ls --color=auto'
        #alias dir='dir --color=
        #alias vdir='vdir --color=
        #alias grep='grep --color=
        #alias fgrep='fgrep --color'
        #alias egrep='egrep --color=
    # some more ls aliases
    #ll='ls -al'
    #alias la='ls -A'
    #alias l='ls -CF'
    # ~/.bash_aliases, instead of adding them here directly.
    if [ -f ~/.bash_aliases ]; then
       . ~/.bash_aliases

Como podemos ver nas últimas três linhas, é possível ter nosso próprio arquivo dedicado aos aliases — `~/.bash_aliases` — para o  `.bashrc`  abrir e executar a cada inicialização do sistema. Ao escolher essa opção, criamos e preenchemos esse arquivo:

    ###########
    # .bash_aliases:
    # a file to be populated by the user's personal aliases (and sourced by ~/.bashrc).
    ###########
    alias git_info='which git;git --version'
    alias greet='echo Hello world!'
    alias ll='ls -al'
    alias where?='echo $PWD

**function**: usado para criar uma rotina de comandos.

Ex. Criando uma função e a chamando no final<br> 
```
$ function funcao1 {
>    date;
>   uptime;
>    uname -a
>    echo "Fim funcao";
>}

$ funcao1
```
Para visualizar a função é só digitar `set`

>[!NOTE]
>
>É possível começar uma função digitando tudo em uma linha ou omitindo a palavra `function`. Ex. `funcao3 () {date; uptime; }`

Como no caso das variáveis e aliases, se quisermos que as funções sejam persistentes durante as reinicializações do sistema, temos de colocá-las em scripts de inicialização do shell, como  `/etc/bash.bashrc`  (global) ou  `~/.bashrc`  (local).

>[!WARNING]
>
>Depois de adicionar aliases ou funções para qualquer arquivo de script de inicialização, é preciso executar  `.`  ou  `source`  nesses arquivos para que as alterações tenham efeito (caso você não queira fazer logout e login novamente ou reinicializar o sistema).

#### Variáveis integradas especiais do Bash

O  _Bourne Again Shell_  vem com um conjunto de variáveis especiais que são particularmente úteis para funções e scripts. Elas são especiais porque só podem ser referenciadas — e não atribuídas. Eis uma lista das mais relevantes:

- `$?`: a referência desta variável se expande para o resultado do último comando executado. Um valor de  `0`  significa sucesso:

    $ ps aux | grep bash
    user2      420  0.0  0.4  21156  5012 pts/0    Ss   17:10   0:00 -bash
    user2      640  0.0  0.0  12784   936 pts/0    S+   18:04   0:00 grep bash
    $ echo $?
    0

Um valor diferente de  `0`  significa erro:

    user1@debian:~$ ps aux |rep bash
    -bash: rep: command not found
    user1@debian:~$ echo $?
    127

- `$$`: expande-se para o PID do shell (ID do processo):

    $ ps aux | grep bash
    user2      420  0.0  0.4  21156  5012 pts/0    Ss   17:10   0:00 -bash
    user2      640  0.0  0.0  12784   936 pts/0    S+   18:04   0:00 grep bash
    $ echo $$
    420

- `$!`: expande-se para o PID do último trabalho em segundo plano:

    $ ps aux | grep bash &
    [1] 663
    $ user2      420  0.0  0.4  21156  5012 pts/0    Ss+  17:10   0:00 -bash
    user2      663  0.0  0.0  12784   972 pts/0    S    18:08   0:00 grep bash
    ^C
    [1]+  Done                   ps aux | grep bash
    $ echo $!
    663

>[NOTE]
>
>Lembre-se, o e comercial (`&`) é usado para iniciar processos em segundo plano.

#### Parâmetros posicionais  `$0`  a  `$9`

Expandem-se para os parâmetros ou argumentos que estão sendo passados para a função (alias ou script) — `$0`  se expande para o nome do script ou shell.

Um _parâmetro posicional_ é um parâmetro denotado por um ou mais dígitos diferentes do dígito único `0`. Por exemplo, a variável `$1` corresponde ao primeiro argumento dado ao script (parâmetro posicional um), `$2` corresponde ao segundo argumento e assim por diante. Se a posição de um parâmetro for maior que nove, ele deve ser referenciado com chaves, como em `${10}`, `${11}` etc.

Vamos criar uma função para demonstrar os parâmetros posicionais — note  `PS2`  (`>`) indicando novas linhas após as quebras de linha:

    $ special_vars() {
    > echo $0
    > echo $1
    > echo $2
    > echo $3
    }

Agora, vamos invocar a função (`special_vars`) passando três parâmetros para ela (`debian`,  `ubuntu`,  `zorin`):

    $ special_vars debian ubuntu zorin
    -bash
    debian
    ubuntu
    zorin

Tudo funcionou como esperado.

>[!WARNING]
>
>Embora seja tecnicamente possível passar parâmetros posicionais para aliases, não é lá muito prático, já que — com aliases — os parâmetros posicionais são sempre passados no final:

    $ alias great_editor='echo $1 is a great text editor'
    $ great_editor emacs
    is a great text editor emacs

#### Outras variáveis integradas especiais do Bash incluem:

- `$#`: expande-se para o número de argumentos passados para o comando.
- `$@`,  `$*`: expandem-se para os argumentos passados para o comando.
-`$_`:  expande-se para o último parâmetro ou o nome do script (dentre outras coisas; consulte  `man bash`  para saber mais!):

Para configuração/customização do ambiente shell, usamos os seguintes arquivos:
- `/etc/profile`: usado para quando um usuário faz o procedimento de login, seja por interface gráfica ou por terminal.
- `/etc/bash.bashrc`: aplicado quando se abre uma nova sessão de bash/shell (sempre que ver `algo.bashrc`, está ligado a um novo shell/bash e `algo.profile` é um novo login)

Por exemplo, caso adicionar uma variável no final do arquivo **/etc/profile**, chamada E**TCPROFILE=Valor1** e tentarmos com o **echo** ver o valor dessa variável, não será retornado nada. No entanto se for mudado para qualquer outro terminal (com CTRL+ALT+F1) e efetuar o login, e exibir a variável com o comando **echo**, a variável aparecerá. 
Isso deixa claro que **profile** está ligado com login realmente, no caso quando qualquer usuário fizer login.

Ainda no **/etc/profile** que é possível incluir um alias, uma função, para que seja comum a todos que se logarem no sistema.

É possível notar que ao se fazer o mesmo teste, agora com **/etc/bash.bashrc**, é possível perceber que a variável apenas irá aparecer quando for aberto um novo shell (e **NÃO** no shell atual) ou um novo login, que automaticamente irá abrir um novo shell.

Dentro de **/etc/profile.d/** há scripts que são carregados ao fazer login. Lembrando que o que foi visto é de definição geral, para todos os usuários.

Para configurações individuais de login (correspondente ao **/etc/profile**), geralmente em **/home** de cada usuário, temos os arquivos, nessa ordem, e logo que um é encontrado e executado, os outros são ignorados:
- `~/.bash_profile`
- `~/.bash_login` (caso não exista `~/.bash_profile`)
- `~/.profile` (mais comum)

Já o correspondente ao **/etc/bash.bashrc**, temos o (nova sessão, novo shell):
- **~/.bashrc**

Dentro do **/home** do usuário há ainda um arquivo chamado **.bash_logout** que é executado ao fazer logout do usuário.

- `~/.bash_logout`: se existir, este arquivo específico do Bash faz algumas operações de limpeza ao sair do shell. Isso pode ser conveniente em certos casos, como as sessões remotas.

Em **/etc/inputrc** temos a opção de editar as definições de input do terminal. Por exemplo, o que fará a combinação de Ctrl + alguma tecla específica, como limpar tela, e etc.

>[!WARNING]
>
>Lembre-se, devido à ordem em que os arquivos são executados, os arquivos **locais** têm precedência sobre os **globais**.

Em **/etc/skel** (de esqueleto): toda vez que criar um usuário, a base de arquivos básicos do usuário será pega daqui, arquivos esses que irão fazer parte do usuário. (será pego desse "esqueleto" de arquivos).<br>
Se criarmos um arquivo qualquer, como **touch teste-skel**, quando criarmos um novo usuário, esse arquivo ficará disponível no **/home** do novo usuário. Isso se torna interessante quando é necessário colocar alguma configuração específica para todo usuário durante sua criação.

Principais Variáveis de Ambiente
É importante conhecer a função de algumas variáveis de ambiente existentes no sistema, as principais são:

- **DISPLAY**: Indica às aplicações gráficas onde as janelas deverão ser exibidas. Será estudado no Tópico 106
- **HISTFILE**: Arquivo do histórico de comandos
- **HISTFILESIZE**: Quantidade de linhas/comandos armazenados no arquivo de histórico
- **HOME**: Indica o diretório do usuário atual
- **LANG**: Definição do idioma
- **LOGNAME** e **USER**: Nome do usuário atual
- **PATH**: Diretórios em que o Linux irá procurar por arquivos executáveis
- **PS1**: Aparência do prompt do shell.
- **PWD**: Diretório atual
- **OLDPWD**: Diretório anterior

Outro comando interessante e que alguns alunos já reportaram ter caído nos exames é o **chsh**.

O **chsh** serve simplesmente para alterar o shell utilizado pelo usuário. Por exemplo:
```
1.  $ chsh
2.  Senha:
3.  Mudando o shell de login para ricardo
4.  Informe o novo valor ou pressione ENTER para aceitar o padrão
5.    Shell de Login  [/bin/sh]:  /bin/bash
```

Ainda sobre terminais, podemos dizer se estiver usando uma interface gráfica, muito provavelmente estará em uso de algum emulador de terminal na GUI, ou um shell **pts**, como gnome-terminal ou konsole (são mais ricos em recursos e fáceis de usar).<br>
Agora se estiver lidando com console do sistema, ou tty, trata-se de um terminal baseado em texto.<br>
Pode-se alternar, como já vimos, com as teclas Ctrl+Alt+F1-F6, sendo o F7 normalmente a sssão que leva à interface gráfica.

>[!NOTE]
>
>**tty** significa teletypewritter (teletipo); **pts** é a abreviação de pseudo terminal slave (pseudo terminal escravo). Para saber mais: **man tty** e **man pts**

#### Lançando shells com o bash
Após fazer o login, digite **bash** em um terminal para abrir um novo shell. Tecnicamente, este shell é um processo filho do shell atual.

Ao iniciar o processo filho bash, podemos especificar diversas opções para definir que tipo de shell queremos iniciar. Eis algumas opções importantes de invocação no bash:

- **bash -l** ou **bash --login**: invoca um shell de login.
- **bash -i**: invoca um shell interativo.
- **bash --noprofile**: com shells de login, ignora o arquivo de inicialização do sistema /etc/profile e os arquivos de inicialização em nível de usuário ~/.bash_profile, ~/.bash_login e ~/.profile.
- **bash --norc**: com shells interativos, ignora tanto o arquivo de inicialização do sistema /etc/bash.bashrc quanto o arquivo de inicialização em nível de usuário ~/.bashrc.
- **bash --rcfile** <file>: com shells interativos, considera <file> como arquivo de inicialização, ignorando os arquivos de inicialização do sistema /etc/bash.bashrc e em nível de usuário ~/.bashrc

#### #### Iniciando shells com  `su`  e  `sudo`

- `su`: muda o ID de user ou o torna superusuário
- `su - user2`, `su -l user2` ou `su --login user2`: iniciam um shell de login interativo com **user2**
- `su user2`: inicia um shell sem login interativo como **user2**
- `su - root` ou `su -`: inicia um shell de login interativo como **root**
- `su root` ou `su` inicia um shell interativo sem login como `root`

`sudo`: executa comandos como outro usuário (incluindo o superusuário). Como este comando é usado principalmente para obter privilégios de root temporariamente, o usuário que o emprega deve estar no arquivo  `sudoers`. Para adicionar usuários a  `sudoers`, precisamos nos tornar  `root`  e então executar:

    # usermod -aG sudo user2

Assim como o  `su`, o  `sudo`  permite invocar shells de login e sem login:
-   `sudo su - user2`,  `sudo su -l user2`  ou  `sudo su --login user2`  iniciam um shell de login interativo como  `user2`.   
-   `sudo su user2`  inicia um shell sem login interativo como  `user2`.
-   `sudo -u user2 -s`  inicia um shell sem login interativo como  `user2`.
-   `sudo su - root`  ou  `sudo su -`  inicia um shell de login interativo como  `root`.
-   `sudo -i`  inicia um shell de login interativo como  `root`.
-   `sudo -i <algum_comando>`  inicia um shell de login interativo como  `root`, executa o comando e retorna ao usuário original.
-   `sudo su root`  ou  `sudo su`  inicia um shell sem login interativo como  `root`.
-   `sudo -s`  ou  `sudo -u root -s`  iniciam um shell sem login como  `root`.

Ao usar `su` ou `sudo`, é importante considerar o contexto particular antes de iniciar um novo shell: Precisamos ou não do ambiente do usuário de destino? Se a resposta for sim, usaríamos as opções que invocam shells de login; se não, as que invocam shells sem login.

- `echo $0`: mostra qual tipo de shell está sendo usado no momento

#### Ver a quantidade de shells

`ps aux | grep bash`: supondo a seguinte saída<br>

    user2@debian:~$ **ps aux | grep bash**
    user2       5270  0.1  0.1  25532  5664 pts/0    Ss   23:03   0:00 bash
    user2       5411  0.3  0.1  25608  5268 tty1     S+   23:03   0:00 -bash
    user2       5452  0.0  0.0  16760   940 pts/0    S+   23:04   0:00 grep --color=auto bash
    
A usuária `user2` em `debian` se logou em uma sessão GUI (ou X Window System) e abriu _gnome-terminal_, depois pressionou Ctrl+Alt+F1 para entrar em uma sessão de terminal `tty`. Finalmente, ela retornou à sessão GUI pressionando Ctrl+Alt+F7 e digitou o comando `ps aux | grep bash`. Assim, a saída mostra um shell sem login interativo por meio do emulador de terminal (`pts/0`) e um shell de login interativo por meio do terminal baseado em texto (`tty1`). Note também como o último campo de cada linha (o comando) é `bash` para o primeiro e `-bash` para o último.

- `-bash`  ou  `-su`: Interativo de login
- `bash`  or  `/bin/bash`: Interativo sem login
- `<nome_do_script>`: Não-interativo sem login (scripts)

#### Variáveis

Pode conter letras (`a-z, A-Z`), números (`0-9`) e sublinhados (`_`). E não deve começar com um número para não confundir o Bash. Não deve conter espaços (nem mesmo entre aspas), por convenção, os sublinhados são usados no lugar dos espaços.

No que diz respeito à referência ou valor das variáveis, também é importante considerar uma série de regras. As variáveis podem conter quaisquer caracteres alfanuméricos (`a-z`,`A-Z`,`0-9`), além da maioria dos outros caracteres (`?`,`!`,`*`,`.`,`/`, etc.). Os valores das variáveis devem ser postos entre aspas se contiverem espaços simples.

Os valores das variáveis também devem ser postos entre aspas se contiverem caracteres como os usados para redirecionamento (`<`,`>`) ou o símbolo de barra vertical (`|`). A única coisa que o comando a seguir faz é criar um arquivo vazio chamado  `zorin`:

    $ distro=>zorin
    $ echo $distro
    
    $ ls zorin
    zorin

Mas quando usamos as aspas, a coisa funciona:

    $ distro=">zorin"
    $ echo $distro
    >zorin

No entanto, aspas simples e duplas nem sempre são intercambiáveis. Dependendo do que estamos fazendo com uma variável (atribuindo ou referenciando), o uso de uma ou de outra tem implicações e produzirá resultados diferentes. No contexto da atribuição de variáveis, as **aspas simples** consideram  _literalmente_  todos os caracteres do valor da variável, enquanto as **aspas duplas** permitem a substituição de variáveis:

    $ lizard=uromastyx
    $ animal='My $lizard'
    $ echo $animal
    My $lizard
    $ animal="My $lizard"
    $ echo $animal
    My uromastyx

Por outro lado, ao referenciar uma variável cujo valor inclui alguns espaços iniciais (ou extras) — às vezes combinados com asteriscos — é obrigatório usar aspas duplas após o comando  `echo`  para evitar  _divisão de campos_  e  _expansão de nome de caminho_:

    $ lizard="   genus   |   uromastyx"
    $ echo $lizard
    genus | uromastyx
    $ echo "$lizard"
       genus   |   uromastyx

Se a referência da variável contiver um ponto de exclamação no final, este deve ser o último caractere da string (caso contrário, o Bash pensará que estamos nos referindo a um evento de  `history`):

    $ distro=zorin.?/!os
    -bash: !os: event not found
    $ distro=zorin.?/!
    $ echo $distro
    zorin.?/!

Todas as barras invertidas devem ser escapadas com outra barra invertida. Aliás, se uma barra invertida for o último caractere na string e não o escaparmos, o Bash interpretará que queremos uma quebra de linha e criará uma nova linha:

    $ distro=zorinos\
    >
    $ distro=zorinos\\
    $ echo $distro
    zorinos\

- `env -i bash`: inicia um bash removendo a maioria das variáveis (além de funções e aliases)

    $ env -i bash

Agora, a maioria das nossas variáveis de ambiente se foi:

    $ echo $USER
    $

Restam apenas algumas:

    $ env
    LS_COLORS=
    PWD=/home/user2
    SHLVL=1
    _=/usr/bin/printenv

`PS1`

Essa variável armazena o valor do prompt do Bash. No trecho de código a seguir (igualmente de  `/etc/profile`), a declaração  `if`  testa a identidade do usuário e lhe atribui um prompt bastante personalizado (  `#`  para  `root`  ou  `$`  para usuários regulares):

    if [ "`id -u`" -eq 0 ]; then
      PS1='# '
    else
      PS1='$ '
    fi

>[!NOTE]
>
>O  `id`  de  `root`  é  `0`. Entre como  `root`  e teste você mesmo com  `id -u`.

Eis algumas outras variáveis de prompt:
- `PS2`: normalmente definido como  `>`  e usado como prompt de continuação para comandos longos de muitas linhas.
- `PS3`: usado como prompt para o comando  `select`.
- `PS4`: normalmente definido como  `+`  e usado para depuração.
- `SHELL`: esta variável armazena o caminho absoluto do shell atual:

    $ echo $SHELL
    /bin/bash

- `USER`: armazena o nome do usuário atual:

    $ echo $USER
    carol

- `echo $DISPLAY` retorna `reptilium:0:2`, que quer dizer: a máquina **reptilium** tem um servidor X rodando e estamos usando a **segunda** tela do sistema

### 105.2 Editar e escrever scripts simples

Ao criar um `script.sh` (script = sequencia de comandos) comum, como por exemplo:

    clear
    echo "===== Primeiro Script======"
    echo ""
    uptime
    free -m
    echo ""
    echo "Fim Script"

Podemos executá-lo usando apenas o comando source ou ponto (.)<br>
Quando um script é executado, os comandos nele contidos não são executados diretamente na sessão atual, mas sim por um novo processo do Bash, chamado _sub-shell_. Isso evita que o script sobrescreva as variáveis de ambiente da sessão atual e faça modificações indesejadas nela. Se o objetivo é executar o conteúdo do script na sessão atual do shell, ele deve ser executado com `source script.sh` ou `. script.sh` (note que há um espaço entre o ponto e o nome do script).

    $ source script.sh
    $ . script.sh

Isso inclusive faz com que seja executado no bash atual, sem mudar para um processo filho.

Se tentar executar usando `./script.sh` ou o caminho absoluto dele, vai dar erro de permissão, pois o arquivo não tem permissão de execução. Precisaria executar `chmod u+x script`, para dar permissão de execução para o arquivo (nesse caso, permissão para o usuário dono do arquivo).

- `exec script.sh`: executa o script e fecha a sessão atual (nem dá pra ver o resultado, pois já fecha em seguida)
- `bash script.sh`: também executa o script sem o bit de execução.

>[!WARNING]
>
>Um script que executa ações restritas pode ter sua permissão SUID ativada e, portanto, os usuários comuns também podem executar o script com privilégios de root. Nesse caso, é muito importante garantir que nenhum usuário além do root tenha permissão para escrever no arquivo. Caso contrário, um usuário comum poderá modificar o arquivo para realizar operações arbitrárias e potencialmente prejudiciais.

Caso queira direcionar algum outro interpretador, usa-se o she-bang, que no caso é indicar no começo do arquivo: `#!/bin/bash`

>[!TIP]
>
>O Bash chama qualquer comando indicado após o `#!` como interpretador do arquivo de script. Pode ser útil, por exemplo, empregar o shebang para outras linguagens de script, como _Python_ (`#!/usr/bin/python`), _Perl_ (`#!/usr/bin/perl`) ou _awk_ (`#!/usr/bin/awk`).

#### Parâmetro em shell script

- `$*`: imprime todos os argumentos passados para o script.
- `$@`: todos os argumentos passados para o script. Se usado com aspas duplas, como em  `"$@"`, todos os argumentos serão colocados entre aspas duplas.
- `$0`: imprime o nome do arquivo que está sendo executado
- `$#`: imprime a quantidade de parâmetros utilizados
- `$1`, `$2`, etc: imprime os parâmetros sequencialmente conforme entrada
- `$!`: PID do último programa executado.
- `$$`: PID do shell atual.
- `$?`: código de status de saída numérico do último comando concluído. Para processos POSIX padrão, um valor numérico de  `0`  indica que o último comando foi executado com sucesso, o que também se aplica a scripts do shell.
```
echo "O meu script se chama $0"
echo ""
echo "Esse script recebeu $# parâmetros, que são, $1 e $2"
```

#### Receber uma variável com read

É possível, ao usuário digitar, receber um valor de variável durante a execução de um script, usando o read:

```
echo -n "Digite um valor: "
read VAR1
echo "O valor digitado foi $VAR1"
```
- `echo -n`: não quebra linha

echo "Do you want to continue (y/n)?"
read ANSWER

O valor retornado será armazenado na variável  `ANSWER`. Se o nome da variável não for fornecido, o nome da variável  `REPLY`  será usado por padrão. Também é possível usar o comando  `read`  para ler mais de uma variável simultaneamente:

    echo "Type your first name and last name:"
    read NAME SURNAME

Neste caso, cada termo separado por espaços será atribuído às variáveis  `NAME`  e  `SURNAME`  respectivamente. Se o número de termos dados for maior que o número de variáveis, os termos excedentes serão armazenados na última variável. O próprio  `read`  pode exibir a mensagem para o usuário com a opção  `-p`, tornando o comando  `echo`  redundante nesse caso:

    read -p "Type your first name and last name:" NAME SURNAME

#### Declarando variáveis

A declaração de variáveis **NÃO** usa cifrão (`$`), já no uso da variável, **TEM QUE USAR**. Exemplo:<br>

    echo ""
    VAR1=`cat /etc/passwd|wc -l`
    VAR2=$(date +%H)
    echo ""
    echo "O arquivo /etc/passwd possui $VAR1 linhas. A hora atual é $VAR2."

*Podemos colocar execução de comandos utilizando crase (\`) ou com a sitaxe `$()`
**A notação de crase é conhecida como **backtick**

##### Comprimento de uma variável
O comprimento de uma variável, ou seja, a quantidade de caracteres que ela contém, é retornado acrescentando-se um hash  `#`  antes do nome da variável. Esse recurso, no entanto, requer o uso da sintaxe das chaves para indicar a variável:

    $ OS=$(uname -o)
    $ echo $OS
    GNU/Linux
    $ echo ${#OS}
    9

##### Arrays (matriz unidimensionais)

O Bash também apresenta variáveis de matriz (array) unidimensionais, de forma que um conjunto de elementos relacionados pode ser armazenado com um único nome de variável. Cada elemento de uma matriz possui um índice numérico, que deve ser usado para escrever e ler valores no elemento correspondente. Ao contrário das variáveis comuns, as matrizes devem ser declaradas com o comando interno do Bash  `declare`. Por exemplo, para declarar uma variável chamada  `SIZES`  como uma matriz:

    $ declare -a SIZES

As matrizes também podem ser declaradas implicitamente quando preenchidas a partir de uma lista predefinida de itens, usando a notação de parênteses:

    $ SIZES=( 1048576 1073741824 )
    $ set | grep SIZES
    SIZES=([0]="1048576"   [1]="1073741824")

No exemplo, os dois grandes valores inteiros foram armazenados na matriz  `SIZES`. Os elementos da matriz devem ser referenciados usando chaves e colchetes, caso contrário o Bash não alterará nem exibirá o elemento corretamente. Como os índices da matriz começam em 0, o conteúdo do primeiro elemento está em  `${SIZES[0]}`, o segundo em  `${SIZES[1]}`  e assim por diante:

    $ echo ${SIZES[0]}
    1048576
    $ echo ${SIZES[1]}
    1073741824

Diferente da leitura, a alteração do conteúdo de um elemento da matriz é realizada sem as chaves (por exemplo,  `SIZES[0]=1048576`). Como no caso das variáveis comuns, o comprimento de um elemento em uma matriz é retornado com o caractere hash (por exemplo,  `${#SIZES[0]}`  para o comprimento do primeiro elemento da matriz  `SIZES`). O número total de elementos em uma matriz é retornado se  `@`  ou  `*`  forem usados como o índice:

    $ echo ${#SIZES[@]}
    2
    $ echo ${#SIZES[*]}
    2

As matrizes também podem ser declaradas usando-se, como elementos iniciais, a saída de um comando, por meio da substituição de comando. O exemplo a seguir mostra como criar uma matriz do Bash cujos elementos são os sistemas de arquivos suportados pelo sistema atual:

    $ FS=( $(cut -f 2 < /proc/filesystems) )

O comando  `cut -f 2 < /proc/filesystems`  exibe todos os sistemas de arquivos atualmente suportados pelo kernel em execução (listados na segunda coluna do arquivo  `/proc/filesystems`), de forma que a matriz  `FS`  agora contém um elemento para cada sistema de arquivos suportado. Qualquer conteúdo de texto pode ser usado para inicializar uma matriz, já que, por padrão, quaisquer termos delimitados por caracteres de  _espaço_,  _tabulação_  ou  _nova linha_  **se tornarão um elemento de matriz**.

>[!TIP]
>
>O Bash trata cada caractere do  `$IFS`  (_Input Field Separator_  ou separador de campos) de uma variável de ambiente como um delimitador. Para alterar o delimitador de campo apenas para caracteres de nova linha, por exemplo, a variável IFS deve ser redefinida com o comando  `IFS=$'\n'`.

#### Instruções condicionais (if e case)

Vejamos um exemplo:

    if [ -f /etc/bash.bashrc ]; then
	    .	/etc/bash.bashrc
	fi
ou

    if test -f /etc/bash.bashrc ; then
	    .	/etc/bash.bashrc
	fi
Ambas as instruções produzem o mesmo efeito. Para que a instrução aninhada no `if` execute, ela deve ser **verdadeira**, no caso o que estiver entre os colchetes, ou após a instrução `test`. <br>Nesse exemplo é testado se o arquivo `/etc/bash.bashrc` existe e é um arquivo regular.

- `-f`: testa se arquivo existe e é um arquivo regular;
- `-e`: testa apenas se arquivo existe;
- `-s`: verifica se o tamanho do arquivo é maior que 0 (zero)
- `-z`: verifica se o tamanho da string é zero (usado com variáveis)
- `-n`: verifica se o tamanho da string é diferente de zero (nonzero)

Vejamos outro exemplo

    if [ "`id -u`" -eq 0]; then
	    PS1='# '
	else
		PS1='$ '
	fi

Nesse caso verificar, por meio do comando `id -u`, se o retorno é igual a 0 (zero), caso seja, retorna `#`, senão `$`. No caso testa se o usuário é root. Lembrando que id 0 é do root. Lembrando também que podemos executar comandos com a crase e por meio do cifrão abrindo e fechando parênteses `$()`

O comando  `test`  avalia as expressões usando duas sintaxes diferentes: as expressões de teste podem ser dadas como um argumento para o comando  `test`  ou podem ser postas entre colchetes, caso em que o comando  `test`  é dado implicitamente. Assim, o teste para avaliar se  `/etc`  é um diretório válido pode ser escrito como  `test -d /etc`  ou como  `[ -d /etc]`:

    $ test -d /etc
    $ echo $?
    0
    $ [ -d /etc ]
    $ echo $?
    0

O comando `test` pode ser executado no terminal diretamente. Vejamos alguns exemplos:

- `test LPI1 = LPI1`: precisamo ver no **return code**. Basta executar `echo $?` (**0** é igual sucesso, **1** ou outro número informa que não é verdadeiro)
- `test LPI1 = LPI2`: return code será **1**
- `test -f /etc/profile`: testa se o arquivo `/etc/profile` existe. (**0** = existe, **1** = não existe)
- `test 10 -gt 20`: se 10 é maior que (**greater than**) 20 (retorna **1**, pois 10 não é maior que 20)

Supõe que a variável $VAR guarde um caminho para um arquivo ou diretório. Podemos ter as seguintes opções:

- `-a "$VAR"`: avalia se o caminho em  `VAR`  existe no sistema de arquivos e é um arquivo.
- `-b "$VAR"`: avalia se o caminho em  `VAR`  é um arquivo de bloco especial.
- `-c "$VAR"`: avalia se o caminho em  `VAR`  é um arquivo de caractere especial.
- `-d "$VAR"`: avalia se o caminho em  `VAR`  é um diretório.
- `-e "$VAR"`: avalia se o caminho em  `VAR`  existe no sistema de arquivos.
- `-f "$VAR"`: avalia se o caminho em  `VAR`  existe e é um arquivo regular.
- `-g "$VAR"`: avalia se o caminho em  `VAR`  tem permissão SGID.
- `-h "$VAR"`: avalia se o caminho em  `VAR`  é um link simbólico.
- `-L "$VAR"`: avalia se o caminho em  `VAR`  é um link simbólico (como  `-h`).
- `-k "$VAR"`: avalia se o caminho em  `VAR`  tem a permissão  _sticky bit_.
- `-p "$VAR"`: avalia se o caminho em  `VAR`  é um arquivo  _pipe_.
- `-r "$VAR"`: avalia se o caminho em  `VAR`  é legível pelo usuário atual.
- `-s "$VAR"`: avalia se o caminho em  `VAR`  existe e não está vazio.
- `-S "$VAR"`: avalia se o caminho em  `VAR`  é um arquivo de socket.
- `-t "$VAR"`: avalia se o caminho em  `VAR`  está aberto em um terminal.
- `-u "$VAR"`: avalia se o caminho em  `VAR`  tem permissão SUID.
- `-w "$VAR"`: avalia se o caminho em  `VAR`  é gravável pelo usuário atual.
- `-x "$VAR"`: avalia se o caminho em  `VAR`  é executável pelo usuário atual.
- `-O "$VAR"`: avalia se o caminho em  `VAR`  é de propriedade do usuário atual.
- `-G "$VAR"`: avalia se o caminho em  `VAR`  pertence ao grupo efetivo do usuário atual.
- `-N "$VAR"`: avalia se o caminho em  `VAR`  foi modificado desde o último acesso.
- `"$VAR1" -nt "$VAR2"`: avalia se o caminho em  `VAR1`  é mais recente que o caminho em  `VAR2`, de acordo com as datas de modificação respectivas.
- `"$VAR1" -ot "$VAR2"`: avalia se o caminho em  `VAR1`  é mais antigo que  `VAR2`.
- `"$VAR1" -ef "$VAR2"`: esta expressão avalia como True (Verdadeiro) se o caminho em  `VAR1`  é um link físico para  `VAR2`.

##### Também existem testes para variáveis de texto arbitrárias, descritos a seguir:

- `-z "$TXT"`: avalia se a variável  `TXT`  está vazia (tamanho zero).
- `-n "$TXT"`  ou  `test "$TXT"`: avalia se a variável  `TXT`  não está vazia.
- `"$TXT1" = "$TXT2"`  ou  `"$TXT1" == "$TXT2"`: avalia se  `TXT1`  e  `TXT2`  são iguais.
- `"$TXT1" != "$TXT2"`: avalia se  `TXT1`  e  `TXT2`  não são iguais.
- `"$TXT1" < "$TXT2"`: avalia se  `TXT1`  vem antes de  `TXT2`, em ordem alfabética.
- `"$TXT1" > "$TXT2"`: avalia se  `TXT1`  vem depois de  `TXT2`, em ordem alfabética.

- `$NUM1 -lt $NUM2`: avalia se  `NUM1`  é menor que  `NUM2`.
- `$NUM1 -gt $NUM2`: avalia se  `NUM1`  é maior que  `NUM2`.
- `$NUM1 -le $NUM2`: avalia se  `NUM1`  é menor ou igual a  `NUM2`.
- `$NUM1 -ge $NUM2`: avalia se  `NUM1`  é maior ou igual a  `NUM2`.
- `$NUM1 -eq $NUM2`: avalia se  `NUM1`  é igual a  `NUM2`.
- `$NUM1 -ne $NUM2`: avalia se  `NUM1`  não é igual a  `NUM2`.

Todos os testes podem receber os seguintes modificadores:

`! EXPR`

Avalia se a expressão  `EXPR`  é falsa.

`EXPR1 -a EXPR2`

Avalia se tanto  `EXPR1`  quanto  `EXPR2`  são verdadeiras.

`EXPR1 -o EXPR2`

Avalia se ao menos uma das duas expressões é verdadeira.



Outro exemplo interessante:<br>

    if [ "$BASH" ] && [ "$BASH" != "/bin/sh" ]; then
	    #executa rotina
	fi
No caso acima, verifica se a variável `$BASH` está declarada **e** se a variável `$BASH` é diferente de `/bin/sh`, então vai para a rotina.

Vejamos um exemplo que verifica se o diretório `/etc/profile.d` existe:<br>

    if [ -d /etc/profile.d ]; then
	    # executa rotina
	fi

Abaixo, outro exemplo um pouco mais complexo:

    if [ -z "${debian_chroot:-}"] && [ -r /etc/debian_chroot ]; then
	    debian_chroot=$(cat /etc/debian_chroot)
	fi
O `-z` significa se o tamanho (length) da string é zero e o `-r` quer dizer se o arquivo existe e se está com permissão de somente leitura.

##### Case
Exemplo1:<br>

    read VAR1
    case $VAR1 in
	    0)
		    echo "O valor digitado foi 0"
	    ;;
	    1|2|3|4|5)
		    echo "O valor digitado foi entre 1 e 5"
		    sleep 3
	    ;;
	    *)
		    echo "O valor digitado foi maior que 5"
	esac

Exemplo 2:<br>

    #!/bin/bash
    
    DISTRO=$1
    
    echo -n "Distribution $DISTRO uses "
    case "$DISTRO" in
    	debian | ubuntu | mint)
        echo -n "the DEB"
      ;;
    	centos | fedora | opensuse )
        echo -n "the RPM"
      ;;
    	*)
        echo -n "an unknown"
      ;;
    esac
    echo " package format."

Cada lista de padrões e comandos associados deve terminar com  `;;`,  `;&`, ou  `;;&`. O último padrão, um asterisco, será usado se não for encontrada uma correspondência para nenhum outro padrão anterior. A instrução  `esac`  (_case_  de trás pra frente) conclui a construção  `case`. Supondo que o script de amostra anterior se chame  `script.sh`  e seja executado com  `opensuse`  como primeiro argumento, a seguinte saída será gerada:

    $ ./script.sh opensuse
    Distribution opensuse uses the RPM package format.
>[!TIP]
>
>
> O Bash tem uma opção chamada `nocasematch` que ativa a correspondência de padrões sem distinção entre maiúsculas e minúsculas para a construção `case` e outros comandos condicionais. O comando interno `shopt` alterna os valores das configurações que controlam comportamentos opcionais do shell: `shopt -s` habilita (_set_) a opção fornecida e `shopt -u` desabilita (_unset_) a opção fornecida. Portanto, colocar `shopt -s nocasematch` antes da construção case permite encontrar padrões sem diferenciar maiúsculas de minúsculas. As opções modificadas por `shopt` afetarão apenas a sessão atual, de forma que as opções modificadas dentro de scripts em execução em um sub-shell — o que é a maneira padrão de executar um script — não afetarão as opções da sessão pai.

#### Loops

- `seq`: faz uma sequencia de acordo com o número que coloque.<br>
Ex.<br>
    $ seq 5
    1
    2
    3
    4
    5

- `expr`: faz conta aritmética<br>
Ex.<br>

    $ expr 1 + 2
    3

    $ expr 1 - 2
    -1

##### for

	read VAR1
    for i in 1 2 3 4 5
    do
	    j=`expr $i + $VAR1`
		echo "$i + $VAR1 = $j
	done

>[!TIP]
>
>O comando `expr` pode ser substituído por `$(())`, de forma que o exemplo anterior no laço `for` poderia ser reescrito como `j=$(( $i + $VAR1 ))`

>[!TIP]
>
>É possível escrever potenciação com o operador duplo asterisco (`**`). Ex.<br>

    $ echo $( (5**2 ) )
    25

Exemplo1:<br>

Usando o `seq`:

    read VAR1
    for i in `seq $1` # $1 = parâmetro 1
    do
	    j=`expr $i + $VAR1`
		echo "$i + $VAR1 = $j
		sleep 1
	done

Exemplo2:<br>

    #!/bin/bash
    
    SEQ=( 1 1 2 3 5 8 13 )
    
    for (( IDX = 0; IDX < ${#SEQ[*]}; IDX++ ))
    do
    	echo -n "${SEQ[$IDX]} is "
    	if [ $(( ${SEQ[$IDX]} % 2 )) -ne 0 ]
    	then
    		echo "odd."
    	else
    		echo "even."
      fi
    done

Este script gera exatamente a mesma saída do exemplo anterior. No entanto, em vez de usar a variável  `NUM`  para armazenar um item por vez, a variável  `IDX`  é empregada para rastrear o índice da matriz atual em ordem crescente, começando de 0 e continuando a adicionar enquanto esse número permanecer abaixo do número de itens na matriz  `SEQ`. O item em si é recuperado de sua posição na matriz com  `${SEQ[$IDX]}`.



##### while

    while [ $VAR1 -le $1 ] #enquanto o teste = Verdadeiro, faça...
    do
	    echo "O valor atual do \$VAR1 é: $VAR1"
	    VAR1=`expr $VAR1 + 1`
	    sleep 1
	done

##### until

    until [ $VAR1 = 0 ] #até que isso seja verdadeiro, faça...chegando no 0, não executa o looping
    do
	    echo "O valor atual do \$VAR1 é: $VAR1"
	    VAR1=`expr $VAR1 - 1`
	    sleep 1
	done

#### Execução sequencial de comandos

Ex. `cat teste | wc -l`: executa o primeiro comando e a saída do mesmo serve de entrada para o próximo comando, no caso `wc`.

Ex. `date ; ls -l ; teste2 ; echo Exemplo`: executa todos, mesmo que dê erro

Ex. `ls -ls teste && echo Exemplo`: só executa o segundo comando, se o primeiro der sucesso (caso exista o arquivo teste, senão seria erro, caso ele não exista - ou seja, o status de saída igual a `0`)

Ex. `ls -ls teste || echo Exemplo`: só executa o segundo comando, se o primeiro falhar. Executando o primeiro já encerra a execução.

Ex. `ls -ls teste || echo Exemplo || date`: é sequencial, na hora que chegar em um que executou com sucesso, ele para.

Exemplo de uso de `||`
Imagine uma checagem de um arquivo muito importante, caso ele desaparece, tenha qualquer problema, mudança de permissão, etc, avise o usuário administrador ou root sobre isso:

    ls -l arquivo_importante || mail -s "arquivo não existe mais" root < .
Se executar o comando acima e der sucesso, não faz nada. Mas se der erro, executa o segundo comando, no caso, enviar um email avisando que o arquivo não existe mais.

###$$ Saída do script (echo e printf)

Mesmo quando a finalidade de um script envolve apenas operações orientadas a arquivos, é importante exibir mensagens relacionadas ao progresso na saída padrão, para que o usuário seja informado sobre quaisquer problemas e possa, eventualmente, usar essas mensagens para gerar logs de operação.

O comando interno do Bash  `echo`  é comumente usado para exibir strings de texto simples, mas ele também oferece alguns recursos estendidos. Com a opção  `-e`, o comando  `echo`  é capaz de exibir caracteres especiais usando sequências de escape (uma sequência de barra invertida designando um caractere especial). Por exemplo:

    #!/bin/bash
    
    # Get the operating system's generic name
    OS=$(uname -o)
    
    # Get the amount of free memory in bytes
    FREE=$(( 1000 * `sed -nre '2s/[^[:digit:]]//gp' < /proc/meminfo` ))
    
    echo -e "Operating system:\t$OS"
    echo -e "Unallocated RAM:\t$(( $FREE / 1024**2 )) MB"

Embora o uso de aspas seja opcional ao se usar  `echo`  sem opções, é necessário adicioná-las ao incluir a opção  `-e`; caso contrário, os caracteres especiais podem não ser lidos corretamente. No script anterior, ambos os comandos  `echo`  usam o caractere de tabulação  `\t`  para alinhar o texto, resultando na seguinte saída:

    Operating system:       GNU/Linux
    Unallocated RAM:        1491 MB

O caractere de nova linha  `\n`  pode ser usado para separar as linhas da saída, de forma que exatamente a mesma saída é obtida combinando-se os dois comandos  `echo`  em um só:

    echo -e "Operating system:\t$OS\nUnallocated RAM:\t$(( $FREE / 1024**2 )) MB"

Embora adequado para exibir a maioria das mensagens de texto, o comando  `echo`  pode não ser o melhor para padrões de texto mais específicos. O comando interno do Bash  `printf`  oferece mais controle sobre a exibição das variáveis. O comando  `printf`  usa o primeiro argumento como formato da saída, onde os marcadores serão substituídos pelos argumentos seguintes na ordem em que aparecem na linha de comando. Assim, a mensagem do exemplo anterior poderia ser gerada com o seguinte comando  `printf`:

    printf "Operating system:\t%s\nUnallocated RAM:\t%d MB\n" $OS $(( $FREE / 1024**2 ))

O espaço reservado  `%s`  destina-se ao conteúdo de texto (será substituído pela variável  `$OS`) e o espaço reservado  `%d`  destina-se a números inteiros (será substituído pelo número resultante de megabytes livres na RAM). O  `printf`  não acrescenta um caractere de nova linha no final do texto, então o caractere de nova linha  `\n`  deve ser posto ao fim do padrão, se necessário. Todo o padrão deve ser interpretado como um único argumento e, portanto, deve ser posto entre aspas.

>[!TIP]
>
> O formato de substituição do espaço reservado realizada por  `printf`  pode ser personalizado com o mesmo formato usado pela função  `printf`  da linguagem de programação C. A referência completa para a função  `printf`  pode ser encontrada em sua página de manual, acessada com o comando  `man 3 printf`.

Com  `printf`, as variáveis são postas fora do padrão de texto, o que torna possível armazenar o padrão de texto em uma variável separada:

    MSG='Operating system:\t%s\nUnallocated RAM:\t%d MB\n'
    printf "$MSG" $OS $(( $FREE / 1024**2 ))

Este método é particularmente útil para exibir formatos de saída distintos, dependendo dos requisitos do usuário. Fica mais fácil, por exemplo, produzir um script que use um padrão de texto distinto se o usuário precisar de uma lista CSV (valores separados por vírgula) em vez de uma mensagem de saída padrão.
cho $TESTE`: lê o valor da variável TESTE
- `TESTE=valor1`: define um valor para a variável TESTE
- `env | grep TESTE`: não encontra nada da variável TESTE pois ela não foi exportada, está localmente apenas
- `set | grep TESTE`: mostra tanto as locais de ambiente, como as exportadas de usuário.

Se tivermos um script que lê essa variável TESTE, ao executá-lo ele não irá ler, pois quando é executado um script ele cria abre em uma nova sessão do shell/bash (processo filho do shell atual), logo essa variável teria que estar exportada.

É possível contornar isso com o comando **source**. Ele faz com que seja executado no mesmo shell da sessão atual, dessa forma retornando o valor de TESTE.

Outra forma é utilizar o ponto (.): `. script.sh` (faz rodar/executar localmente o script, sem chamar outra sessão de bash) (**NÃO** confundir com `./script.sh`)

Comando alias: cria alias para os comandos (sinônimos de comandos)

`alias dt="date +%H:%M"`: cria um alias chamado **dt** que vai executar o comando date mostrando apenas hora e minuto (se deslogar, perde a configuração, é apenas temporário)

Se digitar somente **alias**, é mostrado os alias cadastrados no bash atual.

**function**: usado para criar uma rotina de comandos.

Ex. Criando uma função e a chamando no final<br> 
```
$ function funcao1 {
>    date;
>   uptime;
>    uname -a
>    echo "Fim funcao";
>}

$ funcao1
```
Para visualizar a função é só digitar `set`

>[!NOTE]
>
>É possível começar uma função digitando tudo em uma linha ou omitindo a palavra `function`. Ex. `funcao3 () {date; uptime; }`

Para configuração/customização do ambiente shell, usamos os seguintes arquivos:
- `/etc/profile`: usado para quando um usuário faz o procedimento de login, seja por interface gráfica ou por terminal.
- `/etc/bash.bashrc`: aplicado quando se abre uma nova sessão de bash/shell (sempre que ver `algo.bashrc`, está ligado a um novo shell/bash e `algo.profile` é um novo login)

Por exemplo, caso adicionar uma variável no final do arquivo **/etc/profile**, chamada E**TCPROFILE=Valor1** e tentarmos com o **echo** ver o valor dessa variável, não será retornado nada. No entanto se for mudado para qualquer outro terminal (com CTRL+ALT+F1) e efetuar o login, e exibir a variável com o comando **echo**, a variável aparecerá. 
Isso deixa claro que **profile** está ligado com login realmente, no caso quando qualquer usuário fizer login.

Ainda no **/etc/profile** que é possível incluir um alias, uma função, para que seja comum a todos que se logarem no sistema.

É possível notar que ao se fazer o mesmo teste, agora com **/etc/bash.bashrc**, é possível perceber que a variável apenas irá aparecer quando for aberto um novo shell (e **NÃO** no shell atual) ou um novo login, que automaticamente irá abrir um novo shell.

Dentro de **/etc/profile.d/** há scripts que são carregados ao fazer login. Lembrando que o que foi visto é de definição geral, para todos os usuários.

Para configurações individuais de login (correspondente ao **/etc/profile**), geralmente em **/home** de cada usuário, temos os arquivos, nessa ordem, e logo que um é encontrado e executado, os outros são ignorados:
- `~/.bash_profile`
- `~/.bash_login` (caso não exista `~/.bash_profile`)
- `~/.profile` (mais comum)

Já o correspondente ao **/etc/bash.bashrc**, temos o (nova sessão, novo shell):
- **~/.bashrc**

Dentro do **/home** do usuário há ainda um arquivo chamado **.bash_logout** que é executado ao fazer logout do usuário.

- `~/.bash_logout`: se existir, este arquivo específico do Bash faz algumas operações de limpeza ao sair do shell. Isso pode ser conveniente em certos casos, como as sessões remotas.

Em **/etc/inputrc** temos a opção de editar as definições de input do terminal. Por exemplo, o que fará a combinação de Ctrl + alguma tecla específica, como limpar tela, e etc.

>[!WARNING]
>
>Lembre-se, devido à ordem em que os arquivos são executados, os arquivos **locais** têm precedência sobre os **globais**.

Em **/etc/skel** (de esqueleto): toda vez que criar um usuário, a base de arquivos básicos do usuário será pega daqui, arquivos esses que irão fazer parte do usuário. (será pego desse "esqueleto" de arquivos).<br>
Se criarmos um arquivo qualquer, como **touch teste-skel**, quando criarmos um novo usuário, esse arquivo ficará disponível no **/home** do novo usuário. Isso se torna interessante quando é necessário colocar alguma configuração específica para todo usuário durante sua criação.

Principais Variáveis de Ambiente
É importante conhecer a função de algumas variáveis de ambiente existentes no sistema, as principais são:

- **DISPLAY**: Indica às aplicações gráficas onde as janelas deverão ser exibidas. Será estudado no Tópico 106
- **HISTFILE**: Arquivo do histórico de comandos
- **HISTFILESIZE**: Quantidade de linhas/comandos armazenados no arquivo de histórico
- **HOME**: Indica o diretório do usuário atual
- **LANG**: Definição do idioma
- **LOGNAME** e **USER**: Nome do usuário atual
- **PATH**: Diretórios em que o Linux irá procurar por arquivos executáveis
- **PS1**: Aparência do prompt do shell.
- **PWD**: Diretório atual
- **OLDPWD**: Diretório anterior

Outro comando interessante e que alguns alunos já reportaram ter caído nos exames é o **chsh**.

O **chsh** serve simplesmente para alterar o shell utilizado pelo usuário. Por exemplo:
```
1.  $ chsh
2.  Senha:
3.  Mudando o shell de login para ricardo
4.  Informe o novo valor ou pressione ENTER para aceitar o padrão
5.    Shell de Login  [/bin/sh]:  /bin/bash
```

Ainda sobre terminais, podemos dizer se estiver usando uma interface gráfica, muito provavelmente estará em uso de algum emulador de terminal na GUI, ou um shell **pts**, como gnome-terminal ou konsole (são mais ricos em recursos e fáceis de usar).<br>
Agora se estiver lidando com console do sistema, ou tty, trata-se de um terminal baseado em texto.<br>
Pode-se alternar, como já vimos, com as teclas Ctrl+Alt+F1-F6, sendo o F7 normalmente a sssão que leva à interface gráfica.

>[!NOTE]
>
>**tty** significa teletypewritter (teletipo); **pts** é a abreviação de pseudo terminal slave (pseudo terminal escravo). Para saber mais: **man tty** e **man pts**

#### Lançando shells com o bash
Após fazer o login, digite **bash** em um terminal para abrir um novo shell. Tecnicamente, este shell é um processo filho do shell atual.

Ao iniciar o processo filho bash, podemos especificar diversas opções para definir que tipo de shell queremos iniciar. Eis algumas opções importantes de invocação no bash:

- **bash -l** ou **bash --login**: invoca um shell de login.
- **bash -i**: invoca um shell interativo.
- **bash --noprofile**: com shells de login, ignora o arquivo de inicialização do sistema /etc/profile e os arquivos de inicialização em nível de usuário ~/.bash_profile, ~/.bash_login e ~/.profile.
- **bash --norc**: com shells interativos, ignora tanto o arquivo de inicialização do sistema /etc/bash.bashrc quanto o arquivo de inicialização em nível de usuário ~/.bashrc.
- **bash --rcfile** <file>: com shells interativos, considera <file> como arquivo de inicialização, ignorando os arquivos de inicialização do sistema /etc/bash.bashrc e em nível de usuário ~/.bashrc

#### #### Iniciando shells com  `su`  e  `sudo`

- `su`: muda o ID de user ou o torna superusuário
- `su - user2`, `su -l user2` ou `su --login user2`: iniciam um shell de login interativo com **user2**
- `su user2`: inicia um shell sem login interativo como **user2**
- `su - root` ou `su -`: inicia um shell de login interativo como **root**
- `su root` ou `su` inicia um shell interativo sem login como `root`

`sudo`: executa comandos como outro usuário (incluindo o superusuário). Como este comando é usado principalmente para obter privilégios de root temporariamente, o usuário que o emprega deve estar no arquivo  `sudoers`. Para adicionar usuários a  `sudoers`, precisamos nos tornar  `root`  e então executar:

    # usermod -aG sudo user2

Assim como o  `su`, o  `sudo`  permite invocar shells de login e sem login:
-   `sudo su - user2`,  `sudo su -l user2`  ou  `sudo su --login user2`  iniciam um shell de login interativo como  `user2`.   
-   `sudo su user2`  inicia um shell sem login interativo como  `user2`.
-   `sudo -u user2 -s`  inicia um shell sem login interativo como  `user2`.
-   `sudo su - root`  ou  `sudo su -`  inicia um shell de login interativo como  `root`.
-   `sudo -i`  inicia um shell de login interativo como  `root`.
-   `sudo -i <algum_comando>`  inicia um shell de login interativo como  `root`, executa o comando e retorna ao usuário original.
-   `sudo su root`  ou  `sudo su`  inicia um shell sem login interativo como  `root`.
-   `sudo -s`  ou  `sudo -u root -s`  iniciam um shell sem login como  `root`.

Ao usar `su` ou `sudo`, é importante considerar o contexto particular antes de iniciar um novo shell: Precisamos ou não do ambiente do usuário de destino? Se a resposta for sim, usaríamos as opções que invocam shells de login; se não, as que invocam shells sem login.

- `echo $0`: mostra qual tipo de shell está sendo usado no momento

#### Ver a quantidade de shells

`ps aux | grep bash`: supondo a seguinte saída<br>

    user2@debian:~$ **ps aux | grep bash**
    user2       5270  0.1  0.1  25532  5664 pts/0    Ss   23:03   0:00 bash
    user2       5411  0.3  0.1  25608  5268 tty1     S+   23:03   0:00 -bash
    user2       5452  0.0  0.0  16760   940 pts/0    S+   23:04   0:00 grep --color=auto bash
    
A usuária `user2` em `debian` se logou em uma sessão GUI (ou X Window System) e abriu _gnome-terminal_, depois pressionou Ctrl+Alt+F1 para entrar em uma sessão de terminal `tty`. Finalmente, ela retornou à sessão GUI pressionando Ctrl+Alt+F7 e digitou o comando `ps aux | grep bash`. Assim, a saída mostra um shell sem login interativo por meio do emulador de terminal (`pts/0`) e um shell de login interativo por meio do terminal baseado em texto (`tty1`). Note também como o último campo de cada linha (o comando) é `bash` para o primeiro e `-bash` para o último.

- `-bash`  ou  `-su`: Interativo de login
- `bash`  or  `/bin/bash`: Interativo sem login
- `<nome_do_script>`: Não-interativo sem login (scripts)

### 106.1 Instalar e configurar o X11

Em cima do X ou X11, que roda os gerenciadores de janela, como gnome, kde, xfce, etc.
Display Manager: aquela tela de login inicial.<br>
O servidor X funciona como um modelo cliente-servidor. Os apps que são executados são clientes do servidor X, que provê as disponibilidades gráficas. Assim como a calculadora, que também é um cliente do servidor X.

Normalmente as configurações ficam em `/etc/X11/xorg.conf` (por padrão já nem vem mais com as distros, tendo em vista que tudo já vem muito bem configurado.). No entanto, para explorar, teria que criar o arquivo `xorg.conf` manualmente.

Trecho LPI: [Tradicionalmente, o principal arquivo de configuração usado para configurar um servidor X é o arquivo `/etc/X11/xorg.conf`. Nas distribuições Linux modernas, o servidor X configura a si mesmo em tempo de execução quando é iniciado e, portanto, nenhum arquivo `xorg.conf` pode existir.]

O arquivo  `xorg.conf`  é dividido em estrofes separadas chamadas  _seções_. Cada seção começa com o termo  `Section`  e, após este termo está o  _nome da seção_, que se refere à configuração de um componente. Cada  `Section`  é encerrada por uma  `EndSection`  correspondente. Um arquivo  `xorg.conf`  típico contém as seguintes seções:

- `InputDevice`: usada para configurar um modelo específico de teclado ou mouse.
- `InputClass`: InputClass Nas distribuições Linux modernas, esta seção é tipicamente encontrada em um arquivo de configuração à parte, localizado em  `/etc/X11/xorg.conf.d/`.  `InputClass`  é usada para configurar uma classe de dispositivos de hardware como teclados e mouses, e não um componente específico de hardware. Veja abaixo um exemplo de arquivo  `/etc/X11/xorg.conf.d/00- keyboard.conf`:

    Section "InputClass"
            Identifier "system-keyboard"
            MatchIsKeyboard "on"
            Option "XkbLayout" "us"
            Option "XkbModel" "pc105"
    EndSection

A opção de  `XkbLayout`  determina a disposição das teclas de um teclado, como Dvorak, canhoto ou destro, QWERTY e idioma. A opção de  `XkbModel`  é usada para definir o tipo de teclado utilizado. Há uma tabela de modelos, layouts e suas descrições em  `xkeyboard-config(7)`. Os arquivos associados aos layouts de teclado podem ser encontrados em  `/usr/share/X11/xkb`. Um layout de teclado grego politônico em um computador Chromebook apareceria desta maneira:

    Section "InputClass"
            Identifier "system-keyboard"
            MatchIsKeyboard "on"
            Option "XkbLayout" "gr(polytonic)"
            Option "XkbModel" "chromebook"
    EndSection

Alternativamente, o layout de um teclado pode ser modificado durante uma sessão X em execução com o comando  `setxkbmap`. Eis um exemplo desse comando para configurar o layout grego politônico em um computador Chromebook:

    $ setxkbmap -model chromebook -layout "gr(polytonic)"

Essa configuração só permanecerá ativa enquanto a sessão X estiver em uso. Para que essas alterações se tornem permanentes, modifique o arquivo  `/etc/X11/xorg.conf.d/00-keyboard.conf`  de forma a incluir as configurações necessárias.

>[!NOTE]
>
>O comando  `setxkbmap`  utiliza a X Keyboard Extension (XKB). Este é um exemplo da funcionalidade aditiva do X Window System por meio do uso de extensões.

As distribuições Linux modernas fornecem o comando  `localectl`  através do  `systemd`, que também pode ser usado para modificar um layout de teclado e cria automaticamente o arquivo de configuração  `/etc/X11/xorg.conf.d/00-keyboard.conf`. Novamente, eis um exemplo de configuração de um teclado grego politônico em um Chromebook, desta vez com o comando  `localectl`:

    $ localectl --no-convert set-x11-keymap "gr(polytonic)" chromebook

A opção  `--no-convert`  é usada aqui para impedir que o  `localectl`  modifique o mapa do teclado no console do hospedeiro.

- `Monitor`: a seção  `Monitor`  descreve o monitor físico utilizado e onde está conectado. Eis um exemplo de configuração que mostra um monitor de hardware conectado à segunda porta de vídeo e usado como monitor principal.

    Section "Monitor"
            Identifier  "DP2"
            Option      "Primary" "true"
    EndSection

- `Device`: a seção  `Device`  descreve a placa de vídeo física utilizada. A seção também contém o módulo do kernel usado como driver para a placa de vídeo, junto com sua localização física na placa-mãe.

    Section "Device"
            Identifier  "Device0"
            Driver      "i915"
            BusID       "PCI:0:2:0"
    EndSection

- `Screen`: a seção  `Screen`  reúne as seções  `Monitor`  e  `Device`. Um exemplo de seção  `Screen`  seria semelhante ao seguinte:

    Section "Screen"
            Identifier "Screen0"
            Device     "Device0"
            Monitor    "DP2"
    EndSection

-`ServerLayout`: a seção  `ServerLayout`  agrupa todas as seções como mouse, teclado e telas em uma única interface do X Window System.

    Section "ServerLayout"
    	Identifier   "Layout-1"
    	Screen       "Screen0" 0 0
    	InputDevice  "mouse1"  "CorePointer"
    	InputDevice  "system-keyboard"  "CoreKeyboard"
    EndSection

>[!NOTE]
>
>Nem todas as seções estão presentes em um arquivo de configuração. Nos casos em que uma seção está ausente, os valores padrão são fornecidos pela instância do servidor X em execução.

Os arquivos de configuração específicos ao usuário também residem em `/etc/X11/xorg.conf.d/`. Os arquivos de configuração fornecidos pela distribuição localizam-se em `/usr/share/X11/xorg.conf.d/`. Os arquivos de configuração localizados em `/etc/X11/xorg.conf.d/` são analisados antes do arquivo `/etc/X11/xorg.conf` se ele existir no sistema.

O comando  `xdpyinfo`  é usado em um computador para exibir informações sobre uma instância do servidor X em execução. Veja abaixo um exemplo de saída do comando (determinar quais extensões Xorg estão disponíveis em um sistema):

    $ xdpyinfo
    name of display:    :0
    version number:    11.0
    vendor string:    The X.Org Foundation
    vendor release number:    12004000
    X.Org version: 1.20.4
    maximum request size:  16777212 bytes
    motion buffer size:  256
    bitmap unit, bit order, padding:    32, LSBFirst, 32
    image byte order:    LSBFirst
    number of supported pixmap formats:    7
    supported pixmap formats:
        depth 1, bits_per_pixel 1, scanline_pad 32
        depth 4, bits_per_pixel 8, scanline_pad 32
        depth 8, bits_per_pixel 8, scanline_pad 32
        depth 15, bits_per_pixel 16, scanline_pad 32
        depth 16, bits_per_pixel 16, scanline_pad 32
        depth 24, bits_per_pixel 32, scanline_pad 32
        depth 32, bits_per_pixel 32, scanline_pad 32
    keycode range:    minimum 8, maximum 255
    focus:  None
    **number of extensions:    25
        BIG-REQUESTS
        Composite
        DAMAGE
        DOUBLE-BUFFER
        DRI3
        GLX
        Generic Event Extension
        MIT-SCREEN-SAVER
        MIT-SHM
        Present
        RANDR
        RECORD
        RENDER
        SECURITY
        SHAPE
        SYNC
        X-Resource
        XC-MISC
        XFIXES
        XFree86-VidModeExtension
        XINERAMA
        XInputExtension
        XKEYBOARD
        XTEST
        XVideo
    default screen number:    0
    number of screens:    1
    
    screen #0:
      dimensions:    3840x1080 pixels (1016x286 millimeters)
      resolution:    96x96 dots per inch
      depths (7):    24, 1, 4, 8, 15, 16, 32**
      root window id:    0x39e
      depth of root window:    24 planes
      number of colormaps:    minimum 1, maximum 1
      default colormap:    0x25
      default number of colormap cells:    256
      preallocated pixels:    black 0, white 16777215
      options:    backing-store WHEN MAPPED, save-unders NO
      largest cursor:    3840x1080
      current input event mask:    0xda0033
        KeyPressMask             KeyReleaseMask           EnterWindowMask
        LeaveWindowMask          StructureNotifyMask      SubstructureNotifyMask
        SubstructureRedirectMask PropertyChangeMask       ColormapChangeMask
      number of visuals:    270
    ...

As partes mais relevantes da saída estão em negrito, como o nome da tela (que é idêntico ao conteúdo da variável de ambiente  `DISPLAY`), as informações de versão do servidor X em uso, o número e a listagem das extensões do Xorg em uso e mais informações sobre a tela em si.

Com `ps axu | grep X`, podemos ver o processo `/usr/lib/xorg/Xorg`, que roda no terminal **tty7**. E para gerar o `xorg.conf`, é necessário parar esse processo, logo terá que mudar para o **tty1** (`Ctrl+Alt+F1`), acessar como root e parar o processo **Xorg**.

É necessário mudar para o modo de multiusuários, mas sem interface gráfica, por meio do comando: `# systemctl isolate multi-user.target`. Confirme com `ps axu | grep X`, e verá que o servidor X não está mais rodando.

Agora resta executar o comando `Xorg -configure` (ubuntu 16.04) que irá gerar um arquivo `xorg.conf` em `/root`. Copie esse arquivo para `/etc/x11/xorg.conf`. Rode `startx` para subir o servidor X (mas sem a tela de login), para sair basta fazer um logout. Volte para a interface gráfica padrão executando o comando `systemctl default`. O `xorg.conf` é separado por seções, com identificadores e opções, para mouse, teclado, telas, fontes (que podem ser remotas inclusive), etc.

Vejamos algumas:

- **Module**: carregamento dinâmico de módulos.

Exemplo:  

    _Section "Module"  
    Load "glx"  
    Load "dbe"  
    Load "extmod"  
    EndSection  

_ **Files**: caminhos para alguns arquivos e diretórios utilizados pelo servidor X, como módulos mas principalmente as  **fontes**.

Exemplos:

    _Section "Files"  
    ModulePath "/usr/lib/xorg/modules"  
    FontPath "/usr/share/fonts/X11/misc"  
    FontPath "/usr/share/fonts/X11/Type1"  
    FontPath "/usr/share/fonts/X11/100dpi"  
    FontPath "/usr/share/fonts/X11/75dpi"  
    FontPath "built-ins"  
    FontPath "unix:/7100"  
    FontPath "tcp/fonts.server.com:7100"  
    EndSection_
  
- **InputDevice**: contêm configurações referentes aos dispositivos de entrada, principalmente  **mouse** e  **teclado**.  _Identifier_ e  _Driver_  são parâmetros obrigatórios utilizados para especificar o dispositivo. Além disso parâmetros  _Option_ podem ser adicionados para implementar configurações específicas

Exemplo:

    _Section "InputDevice"  
    Identifier "Keyboard0"  
    Driver "kbd"  
    Option "XkbModel" "pc105"  
    Option "XkbLayout" "us"  
    Option "AutoRepeat" "500 200"  
    EndSection_

      _Section "InputDevice"  
    Identifier "Mouse0"  
    Driver "mouse"  
    Option "Protocol" "auto"  
    Option "Device" "/dev/input/mice"  
    Option "Emulate3Buttons" "no"  
    Option "ZAxisMapping" "4 5"  
    EndSection_

  
- **Device**: seção utilizada principalmente para configuração da  **placa de vídeo**. Semelhante ao InputDevice, tem os parâmetros  _Identifier_ e  _Driver_ como obrigatórios.

Exemplo:

    _Section "Device"  
    Identifier "VideoCard0"  
    Driver "nv"  
    VendorName "nVidia"  
    BoardName "GeForce 6100"  
    VideoRam 131072  
    EndSection_

  
- **Monitor**: configurações específicas do monitor utilizado, como  _HorizSync_ e  _VertRefresh_.

Exemplo:

    _Section "Monitor"  
    Identifier "Monitor0"  
    VendorName "Monitor Vendor"  
    ModelName "Monitor Model"  
    HorizSync 30.0 - 83.0  
    VertRefresh 55.0 - 75.0  
    EndSection_

  
- **Screen**: a seção screen é uma combinação entre o monitor e a placa de vídeo, dizendo ao X quais os modos que ele pode trabalhar. Na sub-seção  **Display**, são informados por exemplo as  **resoluções** suportadas,  **color depth** (bits por pixel), e etc.

    _Section "Screen"  
    Identifier "Screen0"  
    Device "Card0"  
    Monitor "Monitor0"  
    SubSection "Display"  
    Viewport 0 0  
    Depth 1  
    EndSubSection  
    SubSection "Display"  
    Viewport 0 0  
    Depth 4  
    EndSubSection  
    SubSection "Display"  
    Depth 24  
    Modes "1920x1080" "1280x1024" "1024x768"  
    EndSubSection  
    SubSection "Display"  
    Depth 8  
    Modes "1024x768" "800x600" "640x480"  
    EndSubSection  
    EndSection_

  
- **ServerLayout**: esta seção agrega as outras definições da configuração do X, associando principalmente as informações do Screen e InputDevices.

Exemplo:

    _Section "ServerLayout"  
    Identifier "X.org Configured"  
    Screen 0 "Screen0" 0 0  
    InputDevice "Mouse0" "CorePointer"  
    InputDevice "Keyboard0" "CoreKeyboard"  
    EndSection_

#### Uso da variável $DISPLAY

`$Display` mostra, normalmente, a seguinte informação:<br>

    :0.0

    hostname:displaynumber.screennumber

O nome de exibição também informa a um aplicativo gráfico onde ele deve ser renderizado e em qual hospedeiro (no caso de uma conexão X remota).

O  `hostname`  refere-se ao nome do sistema que exibirá o aplicativo. Se o nome de exibição não contiver o nome do hospedeiro, o host local será pressuposto.

O  `displaynumber`  faz referência à coleção de “telas” que estão em uso, seja uma única tela de laptop ou diversas telas em uma estação de trabalho. Cada sessão do servidor X em execução recebe um número de exibição começando em  `0`.

O  `screennumber`  padrão é  `0`. Esse pode ser o caso se apenas uma tela física ou diversas telas físicas estiverem configuradas para funcionar como uma só tela. Quando todas as telas de uma configuração de múltiplos monitores são combinadas em uma única tela lógica, as janelas do aplicativo podem ser movidas livremente entre as telas. Em situações em que cada tela é configurada para funcionar independentemente uma da outra, cada tela abrigará as janelas dos aplicativos que forem abertos dentro delas e as janelas não podem ser movidas de uma tela para outra. A cada tela independente será atribuído seu próprio número. Se houver apenas uma tela lógica em uso, o ponto e o número da tela serão omitidos.

Para iniciar um aplicativo em uma tela específica, atribua o número da tela à variável de ambiente  `DISPLAY`  antes de iniciar o aplicativo: $

    $ DISPLAY=:0.1 firefox &

Esse comando iniciaria o navegador Firefox na tela à direita do diagrama acima. Alguns kits de ferramentas também oferecem opções de linha de comando para instruir um aplicativo a ser executado em uma tela especificada. Procure por  `--screen`  end  `--display`  na página do manual de  `gtk-options(7)`  para ver um exemplo..

O nome de exibição de uma sessão X em execução é armazenado na variável de ambiente  `DISPLAY`:

    $ echo $DISPLAY
    :0

A saída detalha o seguinte:

1.  O servidor X em uso está no sistema local, portanto não há nada impresso à esquerda dos dois pontos.
    
2.  A sessão atual do servidor X é a primeira indicada por  `0`  imediatamente após os dois pontos.
    
3.  Há apenas uma tela lógica em uso, portanto um número de tela não é visível.

Quando não há nada antes dos dois pontos (`:`), considera-se que o valor é `localhost`. Para executar algum app em outro computador, precisa-se mudar o valor da variável de ambiente DISPLAY:<br>

    export DISPLAY="192.168.0.100:0.0"

No host que irá receber a abertura do programa escolhido, é preciso liberá-lo para essa conexão. Por meio do comando `xhost` é possível verificar quem que está autorizado a permitir essa conexão. Para liberar o acesso, digite o comando:<br>

    xhost +192.168.0.99

Digite `xhost` novamente para confirmar que realmente foi liberado. Para liberar completamente o controle de acesso, digite `xhost +` (comando para restringir novamente é: `xhost -`)

Ainda assim não será possível realizar a tarefa, pois o **Display Manager** está bloqueando. No caso, seria o **lightdm**. Se olhar no processo Xorg (`ps axu | grep X`), é possível notar que **lightdm** está rodando com a opção `-nolisten tcp`, e é necessário mudar essa opção (isso para distros baseadas no Debian/Ubuntu).

Vá até `/usr/share/lightdm/lightdm.conf.d`, e edite o arquivo `50-xserver-command.conf`e adicione `xserver-allow-tcp=true` no final do arquivo. Reinicie o `lightdm: systemctl restart lightdm`. Se olhar no processo Xorg **NÃO** terá mais o `-nolisten tcp`

Agora do computador que irá executar o comando para abertura de algum app, execute **xcalc** ou qualquer outro aplicativo para abrir no outro computador.<br>
*O processamento todo está sendo feito pelo PC que abriu a aplicação, no caso o PC de origem. O de destino apenas está gerando a parte gráfica.

#### X11 e o Desktop Environment

Desktop Environment: é um **conjunto de aplicações**, com a finalidade de prover uma interface gráfica amigável ao usuário.<br>
Exemplos: KDE, GNOME, MATE, Cinnamon, LXDE, Xfce

##### Gerenciador de Janelas (Window Manager)

- Controla a criação e fechamento das janelas no ambiente, além do posicionamento e aparência
- São clientes X
- Podem ser parte integrada de um DE ou independentes
- Exemplos: mutter (GNOME), KWin (DKE), Muffin (Cinnamon), Xfwm (XFCE), enligntenment, window maker, Openbox, etc
*É requisito ter um **Window Manager** dentro do **Desktop Environment**

- `update-alternatives --display x-window-manager`: verifica qual é o gerenciador de janelas, ou com o comando:
- `ls -l /etc/alternatives/ | grep window`

##### Interface Gráfica (GUI)

Quando falamos qual interface gráfica você usa? E respondemos KDE, GNOME, etc. Na realidade tecnicamente estamos falando de **Desktop Environment (DE)**.

Já a Interface Gráfica em que o usuário interage, que é o que é usado pelo usuário, é chamado de, por exemplo, do KDE é o KDE Plasma. Do GNOME, é o GNOME Shell, etc

Portanto, a interface gráfica é um dos muitos componentes dentro do DE.

Se estiver usando o GNOME, faça o teste:

- `ps axu | grep gnome`: lista diversas aplicações, como gnome-settings, gnome-software, etc. Essas são aplicações que fazem parte do DE. Uma delas vai ser o `gnome-shell`, que no caso é a interface gráfica.
 
##### Display Managers (DM)

- Interface para realização do login
- Exemplos: GDM (GNOME), LightDM (XFCE), XDM, LXDM
*Geralmente termina em DM (Display Manager)

##### Wayland

É uma alternativa ao X11, criado pelo xorg.

- Protocolo que especifica a comunicação entre o servidor gráfico (Compositor Wayland) e os clientes
- Criado com a intenção de substituir o X, com uma arquitetura diferente visado melhor performance geral
- Atualmente utilizando por padrão no Fedora com GNOME, mas é uma opção em todos os DE
- Projeto em Desenvolvimento

#### Comandos e Arquivos

Em `/usr/share/X11/xorg.conf.d` ficam alguns arquivos de configuração de aplicativos ligados ao hardware, como GPUs, com padrão Section e EndSection

Todos os usuário terão em seu diretório padrão o arquivo `.xsession-errors`, que é um arquivo de log para guardar os erros que ocorrem relacionados à interface gráfica

O acesso remoto que foi feito usando **xhost**, pode ser feito usando o `xauth list`, pegando o magic cookie do computador que quer executar os aplicativos, e adicionando esse magic coockie no computador que irá realizar o acesso, usando o comando:

- `xauth add 192.168.0.100 MIT-MAGIC-COOKIE-1 hash_gerada`

### 106.2 Desktops gráficos

Desktops Environments: GNOME, KDE, MATE, Cinnamon, XFCE, LXDE

- **GNOME**: forte associação ao Projeto GNU, usa biblioteca gráfica **GTK**, Window Manager: mutter.
- **KDE**: pode ser usado em Linux, FreeBSD, Solaris, Windows e Mac OS X, usa biblioteca gráfica **Qt**, Window Manager: KWin
- **MATE**: derivado do GNOME 2, utiliza biblioteca GTK, Window Manager: marco
- **Xfce**: pretende ser rápido e leve, utiliza biblioteca GTK, Window Manager: xfwm

*O **LXDE** é um ambiente de desktop adaptado para baixo consumo de recursos, sendo assim uma boa escolha para instalação em equipamentos mais antigos ou computadores de placa única. Embora não ofereça todas as capabilidades dos ambientes de trabalho mais pesados, o LXDE inclui todos os recursos básicos esperados de uma interface gráfica de usuário moderna

#### Protocolos para acesso remoto a Desktops

- **XDMCP** (X Display Manager Control Protocol)
	- Protocolo nativo do X
	- Implementado pelo Display Manager
	- Não implementa segurança/criptografia
	- Não faz compressão (ocupa bastante banda  )

Para conexão remota utilizando XDMCP, configure o arquivo `/etc/lightdm/lightdm.conf` de maneira que habilite o XDMCPServer:<br>

    [XDMCPServer]
    enable=true

Em outro terminal, execute: `Xorg -terminate -query 192.168.0.100 :1`

- **VNC** (Virtual Networking Computing)
	- utiliza o protocolo RFB (Remote Framebuffer Protocol)
	- Não é totalmente seguro, mas as senhas são criptografadas
	- É possível executar muitos servidores VNC na mesma máquina, mas cada servidor VNC precisa de uma porta TCP exclusiva na interface de rede que aceite solicitações de sessão de entrada. Por convenção, o primeiro servidor VNC deve usar a porta TCP 5900, o segundo deve usar 5901 e assim por diante

- **SPICE** (Simple Protocol for Independent Computing Environment)
	- solução open source completa para acesso remoto
	- solução mais segura

- **RDP** (Remote Desktop Protocol): é usado sobretudo para acessar remotamente a área de trabalho de um sistema operacional _Microsoft Windows_ por meio da porta de rede TCP 3389
	- utilizado para o Microsoft Terminal Service

### 106.3 Acessibilidade

Acessibilidade também é chamada de **AccessX**. Pode ser alterado com a linha de comando: `xkbset`

Locais para acesso: O módulo de configurações de acessibilidade é chamado de _Acesso universal_ na área de trabalho do Gnome, enquanto que no KDE ele está em _Configurações do sistema_, _Personalização_, _Acessibilidade_. Outros ambientes de desktop, como o _Xfce_, também o chamam de _Acessibilidade_ em seu gerenciador de configurações gráficas. Porém, de maneira geral eles oferecem um conjunto reduzido de funcionalidades em comparação com o Gnome e o KDE.

- `sticky keys` (teclas de aderência): é para quem não consegue apertar mais de uma tecla ao mesmo tempo (Ex. shift + A ou S, etc). Se habilitar, basta apertar a tecla do atalho e a outra sequencial (sem necessidade de segurar) - (O KDE também oferece a opção de _Teclas de bloqueio_: se habilitada, as teclas Alt, Ctrl e Shift permanecerão “apertadas” se o usuário as pressionar duas vezes, semelhante ao comportamento da tecla Caps lock) - (o recurso de teclas de aderência será ativado pressionando-se a tecla Shift cinco vezes consecutivas. Para ativar o recurso de teclas lentas, a tecla Shift deve ser mantida pressionada por oito segundos consecutivos)
- `slow keys`(teclas lentas): usado por quem tem problema motor, as teclas lentas exigem que o usuário mantenha a tecla pressionada por um período de tempo especificado antes de ela ser aceita
- `bouce keys`(teclas de repercussão): serve para inibir pressionamentos de tecla não intencionais adicionando um tempo de latência entre eles (se precisar digitar a mesma tecla, precisa aguardar o delay)
- `mouse emulation`: para usar o mouse com o teclado numérico da direita. (Ex. 8=cima, 2=baixo, 6=direita e 4=esquerda, 5=pressionar - clique esquerdo)
- `Preferências do mouse  na janela de configuração do sistema`: se o usuário não conseguir pressionar um ou mais botões do mouse, os cliques podem ser simulados usando diferentes técnicas. Na seção  _Assistência de clique_  do  _Acesso Universal_  do Gnome, a opção  _Clique secundário simulado_  simula um clique com o botão direito se o usuário pressionar e segurar o botão esquerdo do mouse. Com a opção  _Clique flutuante_  habilitada, um evento de clique será disparado quando o usuário segurar o mouse sem movê-lo. No KDE, o aplicativo  _KMouseTool_  fornece esses mesmos recursos para facilitar as ações com o mouse.
- `GOK (Gnome On-board Keyboard)`: teclado virtual On-board
- `KMag`: screen magnifier (ampliador de tela - LUPA)
- `Orca e emacspeak`: leitor de tela, sendo o Orca o principal
- `BRLTTY`: app do Linux para entender e usar o [Braille Display](https://www.google.com/search?q=braille+display&oq=brai&gs_lcrp=EgZjaHJvbWUqBggAEEUYOzIGCAAQRRg7MgYIARBFGDkyBggCEEUYPDIGCAMQRRg8MgYIBBBFGEEyBggFEEUYQTIGCAYQRRhBMgYIBxAuGEDSAQgzODQ5ajBqMagCALACAA&sourceid=chrome&ie=UTF-8)]

#### Reconhecimento de voz

Software capaz de executar comandos através do reconhecimento de voz. Diversos projetos Open Source em desenvolvimento (além dos principais para dispositivos móveis, como Siri, Cortana, etc.
- CMUSphinx
- Simon (KDE)
- Julius

Pergunta interessante na [lpi.org](https://learning.lpi.org/pt/learning-materials/102-500/106/106.3/106.3_01/) citando o Orca<br>
De que forma o aplicativo  _Orca_  pode ajudar usuários com deficiência visual a interagir com o ambiente de trabalho?
O Orca é um leitor de tela que gera uma voz sintetizada que descreve os eventos na tela e lê o texto sob o cursor do mouse. Ele também funciona com dispositivos chamados de  _visores braille atualizáveis_, permitindo ao usuário identificar o texto com padrões táteis.

### 107.1 Administrar contas de usuário, grupos e arquivos de sistema relacionados

Cada usuário tem, obrigatoriamente, seu grupo padrão. E pode estar em vários grupos, ou seja, o mesmo usuário pode estar em vários grupos, facilitando para o administrador de sistemas.

- `/etc/passwd`: principal arquivo que contém todos os usuários do sistema
	- `id` e `gid`: id e id do grupo padrão do usuário (**root SEMPRE será id igual a 0 zero, assim como seu gid**)

Se observar há diversos usuários de sistema, como por exemplo o **daemon**. No Linux, para poder criar um processo ou gerar um arquivo, é preciso ter um usuário, no mínimo. Por isso a necessidade de aplicações terem seu usuário

Normalmente (varia de distro para distro), ids a partir de 1000 são os de usuário, abaixo de 1000 são os de sistema. Lembrando que isso é mais comum, mas pode variar, pois é totalmente configurável.

Por convenção, em `/etc/passwd`, é recomendado sempre utilizar caracteres minúsculos, pois haveria distinção de um usuário chamado rodrigo e Rodrigo, pois é case sensitive. Portanto, é recomendado seguir o padrão.

#### Entendendo cada campo do /etc/passwd
Ordem dos campos:<br>
1. nome do usuário
2. senha do usuário: que armazena em `/etc/shadow`. Antigamente armazenava aqui mesmo
3. id do usuário
4. grupo padrão do usuário: que por padrão usa o mesmo nome do usuário, mas também é configurável e possível alterar
5. descrição: normalmente o nome do usuário, mas isso não é regra.
6. home do usuário: local onde usuário poderá gravar sem restrições, e onde também o usuário cai ao fazer login
7. shell padrão do usuário, que é aberto após login. Quando tem `/bin/false`, significa que **NÃO** é um usuário que irá se logar. Assim como quando tiver `/usr/sbin/nologin`.<br>
*Internamente o Linux sempre trabalha com o `id`.<br>
**Pode-se ter dois usuários com o mesmo id, no entanto o Linux tratará os dois como se fosse um só.<br>
***Pode-se alterar o arquivo `/etc/passwd` diretamente, mas não é recomendado, pois há comandos para isso (e pense que o `/etc/passwd` é ligado com o `/etc/shadow`, e mudar uma coisa em um, geraria inconsistência no outro). Ex. Poderia alterar o id de qualquer usuário para o `id = 0`, e esse usuário se comportaria como root. No entanto não é recomendado.

#### Entendendo cada campo do /etc/shadow

Contém as senhas dos usuário<br>
Ordem dos campos:<br>
1. usuário propriamente dito
2. hash da senha (**quando não** tem senha definida, fica um ponto de exclamação - `!`)

#### Entendendo cada campo do /etc/group

Contém os grupos dos usuário<br>
Ordem dos campos:<br>
1. nome do grupo
2. senha (sim, grupo também pode ter senha, que fica em `/etc/gshadow`)
3. ids do grupo
4. usuários que fazem parte do grupo

#### Entendendo cada campo do /etc/login.defs

Contém as definições de login de cada usuário. No caso, aqui também tem as definições de ids dos usuários (fica próximo da linha 172). Por exemplo:<br>

    # Min/max values for automatic uid selection in useradd
    171 #
    172 UID_MIN                  1000
    173 UID_MAX                 60000

Lembrando que é uma convenção, o Linux, por exemplo, pode ter mais que 60k usuários.

É nesse arquivo também que podemos alterar a variável `DEFAULT_HOME` para `yes` para criar o `/home` dos usuários.

Mais algumas diretivas importantes:<br>

- `UID_MIN`  e  `UID_MAX`: O intervalo de IDs de usuário que podem ser atribuídos a novos usuários comuns.
- `GID_MIN`  e  `GID_MAX`: O intervalo de IDs de grupo que podem ser atribuídos a novos grupos comuns.

- `CREATE_HOME`: Especifica se um diretório pessoal deve ser criado por padrão para novos usuários.
- `USERGROUPS_ENAB`: Especifica se o sistema deve, por padrão, criar um novo grupo para cada nova conta de usuário com o mesmo nome do usuário, e se, ao deletar a conta do usuário, o grupo primário do usuário também deve ser removido, caso não contenha mais membros.

- `MAIL_DIR`: O diretório de spool de email.
- `PASS_MAX_DAYS`: O número máximo de dias que uma senha pode ser usada.
- `PASS_MIN_DAYS`: O número mínimo de dias permitido entre mudanças de senha.
- `PASS_MIN_LEN`: O comprimento mínimo aceitável da senha.
- `PASS_WARN_AGE`: O número de dias de aviso antes que uma senha expire.

>[!TIP]
>
>Ao gerenciar usuários e grupos, sempre verifique este arquivo para visualizar e, eventualmente, alterar o comportamento padrão do sistema, se necessário.

#### 107.1 Gerenciamento de Usuários e Grupos - useradd, userdel, usermod, passwd

Basicamente são:<br>
- `useradd`: adiciona usuário
- `userdel`: exclui usuário
- `usermod`: altera configurações usuário

##### useradd
- `useradd usuário1`: cria o **usuário1**, e em `/etc/passwd`, cria uma linha referente a esse usuário. Algumas distros antigas tinham um bug que não informava o shell a ser utilizado, ficando em branco, e tendo que alterar manualmente (é possível mudar com o comando `chsh`)

Exemplo com várias opções:<br>

    useradd -c "Nome do Usuario" -s /bin/bash -g 1001 -G 1010

- `-c`(`--comment`):  string de texto com o comentário do usuário (geralmente nome completo do usuário
- `-s`(--shell): shell padrão desejado pelo novo usuário
- `-g`(`--gid`): grupo primário (padrão) do novo usuário
- `-G` (`--group`): grupo(s) secundários do novo usuário (outros grupos que o usuário vai pertencer)
- `-e` (`--expiredate`) (YYYY-MM-DD): define um tempo que a conta será desabilitada
- `-f`: cria uma nova conta de usuário definindo o número de dias após a expiração de uma senha durante os quais o usuário deve atualizar a senha (caso contrário, a conta será desabilitada).
- `-k`: cria uma nova conta de usuário copiando os arquivos de esqueleto de um diretório personalizado específico (esta opção só é válida se a opção  `-m`  ou  `--create-home`  for especificada).

Outras opções importantes:
- `-d` (`--home-dir`): definir um `/home` para usuário (não precisa ser o padrão)
- `-m` (`--create-home`): caso no `/etc/user.defs` esteja para não criar `/home` por padrão, pode-se usar essa opção para "forçar" criar o `/home` do usuário (conforme definido no skeleton directory) 
- `-M` (`--no-create-home`): não cria o `/home`
- `-p` (`--password`): define a senha. Mas precisa ser em hash, que pode ser criado por outro comando.
- `-u` (`--uid`): id deseja que o usuário tenha

##### userdel

Supõe que **usuario1** tenha entrada referente a ele em `/etc/passwd`, `/etc/shadow`, `/etc/group` e ele possua um diretório em `/home`, sendo `/home/usuario1`. Se executar:<br>

    userdel usuario1

Será apagado as entradas nos três arquivos, mas **não apagará** a pasta `/home/usuario1`. Para apagar, tem que usar a opção `-r`:
- `-r` (`--remove`): remove o /home do usuário

##### usermod

Basicamente muda o que poderia ser definido com o `useradd`. Supõe que usuario1 não tem comentário, podemos adicionar um comentário com o comando:<br>

    usermod -c "Nome usuario 1" usuario1

Mudar o shell do usuário1:<br>

    usermod -s /sbin/ksh usuario1

`usermod -g suporte usuario1`: muda para **suporte** o grupo padrão do **usuario1** (originalmente, quando criado, o grupo padrão (`-g`) do **usuario1** era **usuario1**. Confirme com um `cat /etc/passwd` para ver o id do grupo do **usuario1**.

Repare na similaridade dos dois comandos a seguir:<br>


`usermod -G devops usuario1`: define o grupo **devops** como grupo secundário do **usuario1**. Repare que em `/etc/passwd`, ainda continuar sendo o grupo padrão o grupo `suporte` (considerando a mudança no comando do parágrafo anterior. No entanto o **usuario1** também pertence agora ao grupo **devosp**.

`usermod -G qateams usuario1`: define o grupo **qateams** como grupo secundário do **usuario1**. Repare que em `/etc/passwd`, ainda continuar sendo o grupo padrão o grupo `suporte` (considerando a mudança no comando do parágrafo anterior. No entanto o **usuario1** também pertence agora ao grupo **qateams**. NO ENTANTO, o usuario1 não faz mais parte do grupo suporte (imagine que o limite de grupos secundários seja 1 grupo por vez), mas podemos podemos manter o grupo secundário com o argumento `-a`, que no caso vai adicionando os grupos. Ficando o comando:<br>

    usermod -G -a qateams usuario1

ou

    usermod -aG qateams usuario1
- `-a` ou `--append`

- `-l` ou `--login`: altera o nome de login da conta de usuário especificada.
- `-L`ou `--lock`:  bloqueia a conta de usuário especificada. Um ponto de exclamação é posto na frente da senha criptografada dentro do arquivo  `/etc/shadow`, desabilitando assim o acesso com senha para esse usuário. (Note: if you wish to lock the account (not only access with a password), you should also set the EXPIRE_DATE to 1).
- `-U`ou `--unlock`: desbloqueia a conta de usuário especificada. Remove o ponto de exclamação na frente da senha criptografada no arquivo  `/etc/shadow`.

>[!TIP]
>
>Lembre que, ao alterar o nome de login de uma conta de usuário, você provavelmente deve renomear o diretório pessoal desse usuário e outros itens relacionados a ele, como arquivos de spool de email. Lembre também que, ao alterar o UID de uma conta de usuário, provavelmente será preciso corrigir a propriedade dos arquivos e diretórios que estejam fora do diretório inicial do usuário (o ID do usuário é alterado automaticamente na caixa de email do usuário e em todos os arquivos pertencentes ao usuário e localizados no diretório inicial do usuário).

##### passwd

Usado para alterar/criar senha para usuários (precisa ser root)

    passwd usuario1 #troca a senha do usuario1
    passwd #troca a senha do usuario root

Lembre-se que ao criar um usuário, no campo referente à senha lá no arquivo `/etc/shadow`, vai ficar com um ponto de exclamação (`!`), indicando que não foi definido uma senha. Após criar uma senha com o comando `passwd`, uma hash entrará no lugar do ponto de exclamação.

    su usuario1 #troca para o usuario1

Mais algumas opções para o uso de `passwd`:<br>

- `-d`: apaga a senha de uma conta de usuário (desabilitando o usuário).
- `-e`:  força a conta de usuário a alterar a senha.
- `-i`:  define o número de dias de inatividade após a expiração de uma senha, durante os quais o usuário deve atualizar a senha (caso contrário, a conta será desabilitada).
- `-l`: bloqueia a conta de usuário (a senha criptografada é prefixada com um ponto de exclamação no arquivo  `/etc/shadow`).
- `-n`: define o tempo de vida mínimo da senha.
- `-S`: exibe informações sobre o status da senha de uma conta de usuário específica.
- `-u`: desbloqueia a conta do usuário (o ponto de exclamação é removido do campo de senha no arquivo  `/etc/shadow`).
- `-x`: define o tempo de vida máximo da senha.
- `-w`: define o número de dias de aviso antes que a senha expire, durante os quais o usuário é advertido de que a senha deve ser alterada.

>[!NOTE]
>
>Os grupos também podem ter uma senha, que pode ser definida usando o comando  `gpasswd`. Os usuários que não são membros de um grupo mas conhecem a senha podem ingressar nele temporariamente usando o comando  `newgrp`.  `gpasswd`  também é usado para adicionar e remover usuários de um grupo e para definir a lista de administradores e membros comuns do grupo.

> [!IMPORTANT] 
>
>Há o comando `adduser`, que na realidade é um script que vai interagindo para criação do usuário. A nível de LPI, focar no `useradd`.

#### 107.1 Gerenciamento de Usuários e Grupos - groupadd, groupdel, groupmod

- `groupadd`: adiciona grupo
- `groupdel`: exclui grupo
- `groupmod`: altera configurações do grupo

##### groupadd

- `groupadd suporte`: cria o grupo **suporte**
- `groupadd -g 2000 dev`: cria o grupo **dev** com id 2000

##### groupdel

- `groupdel suporte`: exclui o grupo suporte

##### groupmod

É possível mudar o id e o nome do grupo. No exemplo abaixo está mudando o nome do grupo de **suporte** para **devops**:

- `groupmod -n devops suporte`(`-n` ou `--new-name`): altera o nome do grupo de suporte para devops
- `groupmod -g 2001 suporte`(`-g` ou `--gid`): altera o id do grupo para 2001

*Não é possível excluir um grupo caso se trate do grupo principal de uma conta de usuário. Portanto, é preciso remover o usuário antes de remover o grupo. Quanto aos usuários, se você excluir um grupo, os arquivos pertencentes a esse grupo permanecerão em seu sistema de arquivos e não serão excluídos ou atribuídos a outro grupo.

##### newgrp

Comando faz com que o usuário atual assuma determinado grupo durante a sessão de login.

- `newgrp suporte`: supõe que está logado com **usuario1**, e que esse usuário também faça parte do grupo **suporte**, além de seu próprio (grupo **usuario1**). Ao executar o comando no começo da frase, ele assume o grupo **suporte** como padrão, e arquivos criados serão do grupo **suporte**.

##### senhas nos grupos

Seria uma situação que o usuário não faz parte de um grupo, se tentar, por exemplo, com o comando: `newgrp devops`, e o usuário não fizer parte do grupo, vai pedir uma senha, e somente será admitido ao grupo se souber a senha.

Primeiramente é necessário criar uma senha para o grupo, com o comando:<br>

    gpasswd nome_grupo

Lembrando que se pode observar os grupos que têm senha olhando o arquivo `/etc/gshadow`

Para acessar o grupo, basta usar o comando `newgrp nome_grupo`

> [!CAUTION]
> 
>Utilizar senha em grupo não é recomendado, e é pouquíssimo ou quase não utilizado.

#### 107.1 Gerenciamento de Usuários e Grupos - id, groups, getent e chage

- `id`: imprime o id do usuário e o id dos grupos pertencentes a esse usuário (usuário atual). Ou pode usar colocando o usuário como parâmetro: `id usuario1`

Sequencialmente seria: 
- **id do usuário**; 
- **id do grupo padrão do usuário**;
- **grupos secundários que esse usuário pertence**.

- `groups`: mesmo conceito que no comando `id`, que irá listar os grupos do usuário logado. Podendo também especificar um usuário. Ex. `groups usuario1`<br>
Ex.<br>

```
    $ groups rodrigo
    rodrigo adm cdrom sudo dip plugdev users lpadmin sambashare
```
`getent`: pega informações de grupos/usuários (esse comando exibe entradas de bancos de dados suportados pelas bibliotecas _Name Service Switch_ (NSS) e requer o nome do banco de dados e uma chave de pesquisa)

- `getent passwd rodrigo`: pega informação do usuário rodrigo em `/etc/passwd` (como se fosse um `cat /etc/passwd | grep rodrigo`)
- `getent group suporte`: pega informações do usuário suporte no `/etc/group`

>[!NOTE]
>
>Lembre-se de que o `getent` só pode acessar os bancos de dados configurados no arquivo `/etc/nsswitch.conf`.

##### chage (change age - alterar idade)

`chage`: mostra as propriedades do usuário: quando a senha vai expirar ou ficar ativa/inativo, número máximo entre dias para alterar senha, última vez que usuário mudou a senha, etc
- `chage -l rodrigo`: mostra propriedades do usuário rodrigo (apenas **root** pode ver as propriedades de todos os usuários, os demais somente suas próprias informações)
- `chage -M 60 rodrigo`: força que o usuário troque de senha a cada 60 dias. Execute `chage -l rodrigo` para saber se aplicou mesmo.
- `chage -d "2024-11-13" rodrigo`: (ou `--lastday`): muda a data que da última vez que o usuário mudou a senha. (isso implica se, por exemplo, foi configurado para trocar a senha a cada x dias. Se for 10 dias, e voltar mais de 10 dias da última troca, vai ter que cadastrar uma nova senha, pois a senha é considerada expirada).
- - `chage -E "2024-12-12" rodrigo`: (ou `--expiredate`): define uma data para a conta expirar. Se expirar, ao logar, vai informar que a conta foi expirada, que é preciso falar com o administrador do sistema
- `chage -E -1 rodrigo`: volta a conta ao normal, em referências ao comando anterior.
- `chage -d0 rodrigo`: força o usuário a trocar senha no próximo login (**root enforced**)
- `-I`: define o número de dias de inatividade após a expiração de uma senha, durante os quais o usuário deve atualizar a senha (caso contrário, a conta será desabilitada).
- `-W`: define o número de dias de aviso antes que a senha expire, durante os quais o usuário é advertido de que a senha deve ser alterada.

>[!NOTE]
>
>A sequencias mostrada no comando `chage`, é a mesma dentro do arquivo `/etc/shadow`. Inclusive a última coluna, é o número de dias, desde 1970. (Nos sistemas mais novos não foi percebido essa informação).

##### Exercícios interessantes no site lpi.org

Comandos aleatórios:<br>
|   |   |
|---|---|
| `usermod -L` | Bloquear a conta de usuário |
| `passwd -u` | Desbloquear a conta de usuário |
| `chage -E` | Definir a data de expiração da conta de usuário |
| `groupdel` | Excluir o grupo  |
| `useradd -s` |Criar uma nova conta de usuário com um shell de login específico |
| `groupadd -g` | Criar um novo grupo com um GID específico |
| `userdel -r` | Remover a conta de usuário e todos os arquivos em seu diretório inicial, o próprio diretório inicial e o spool de email do usuário |
| `usermod -l` | Alterar o nome de login da conta de usuário |
| `groupmod -n` | Alterar o nome do grupo |
| `useradd -m` | Criar uma nova conta de usuário e seu diretório inicial  |

Comandos correspondentes:<br>

|   |   |
|---|---|
| `passwd -n` | `chage -m` |
| `passwd -x` | `chage -M` |
| `passwd -w` | `chage -W` |
| `passwd -i` | `chage -I` |
| `passwd -S` | `chage -l` |

No Linux, podemos usar o comando `passwd -n` (ou `chage -m`) para definir o número mínimo de dias entre as mudanças de senha, o comando `passwd -x` (ou `chage -M`) para definir o número máximo de dias durante os quais uma senha é válida, o comando `passwd -w` (ou `chage -W`) para definir o número de dias de aviso antes que a senha expire, o comando `passwd -i` (ou `chage -I`) para definir o número de dias de inatividade durante os quais o usuário deve alterar a senha e o comando `passwd -S` (ou `chage -l`) para exibir informações breves sobre a senha da conta de usuário.

Comando para bloquear e desbloquear usuários<br>
`usermod --lock` e `passwd -l`. 
Já para desbloqueá-la, os comandos seriam `usermod -U`, `usermod --unlock` e `passwd -u`.

***O comando `usermod` não inclui a opção de remover apenas um grupo; portanto, você precisa especificar todos os grupos secundários aos quais o usuário pertence.

    # usermod -G administrators,web-designers kevin

Questão 6:<br>
Usando o comando  `chage`, primeiro verifique a data de expiração da conta de usuário  `kevin`  e depois altere-a para 31 de dezembro de 2022. Que outro comando pode ser usado para alterar a data de expiração de uma conta de usuário?

    # chage -l kevin | grep "Account expires"
    Account expires		: never
    # chage -E 2022-12-31 kevin
    # chage -l kevin | grep "Account expires"
    Account expires		: dec 31, 2022

O comando  `usermod`  com a opção  `-e`  equivale a  `chage -E`.

Questão 7:<br>
Adicione uma nova conta de usuário chamada  `emma`  com UID 1050 e defina  `administrators`  como seu grupo principal e  `developers`  e  `web-designers`  como seus grupos secundários.

    # useradd -u 1050 -g administrators -G developers,web-designers emma
    # id emma
    uid=1050(emma) gid=1028(administrators) groups=1028(administrators),1029(developers),1031(web-designers)

## 107.2 Automatizar e agendar tarefas administrativas de sistema

#### Cron

É um daemon, um processo que fica rodando, de agendamento do sistema (normalmente do sistema). Verificar se está rodando com `systemctl status cron`

O arquivo `/etc/crontab` é onde ficam as tarefas de agendamento, que é executado pelo usuário **root** (a tabela de tarefas `cron` é comumente chamado de `contrabs`, que contêm os chamdos `cron jobs` - trabalho cron)

>[!NOTE]
>
>No Linux, também existe o recurso `anacron`, adequado para sistemas que podem ser desligados (como computadores de mesa ou laptops). Ele só pode ser usado pelo root. Se a máquina estiver desligada quando os trabalhos de `anacron` tiverem de ser executados, isso ocorrerá na próxima vez em que se ligar a máquina. O `anacron` está fora do escopo da certificação LPIC-1.

Os 5 primeiros campos são delimitados questões do tempo, sendo, sequencialmente: <br>
**minuto da hora (0-59)** | **hora do dia (0-23)** | **dia do mês - dom (1-31)** | **mês do ano -mon (1-12)** | **dia da semana - dow (0-7 com Domingo=0 ou Domingo=7)**

*Para o mês do ano e o dia da semana, podemos usar as três primeiras letras do nome em vez do número correspondente.

- supõe que esteja com o valor 17 no campo **m** (**minute**), significa que vai executar todo minuto 17.
- `*` = qualquer valor. qualquer minuto, qualquer hora, qualquer dia do mês, etc. Outra forma que facilitar a leitura do asterisco é interpretá-lo como "**seja o dia/hora/mes que for** ou **qualquer valor**"
- **dow (day of week):**
	-  `7` e `0` = domingo, logo: 
	- `1`= segunda-feira, 
	- `2`= terça-feira, etc

- `,`: especifica uma lista de valores possíveis
- `-`(hífen): especifica um intervalor de valores possiveis
- `/`: especifica valores escalonados

A primeira entrada no arquivo `/etc/crontab`:

    17 *	* * *	root	cd / && run-parts --report /etc/cron.hourly

Nesse caso, executa em todo minuto 17, em todas as horas, em todos os dias do mês, todo mês, todos os dias da semana, o que estiver dentro de `/etc/cron.hourly`. A execução de todos os arquivos se deve ao programa `run-parts`.

A sintaxe dos crontabs de sistema é semelhante à dos crontabs de usuário, porém ela requer um campo adicional obrigatório que especifica **qual usuário executará o cron job**. Portanto, cada linha em um crontab de sistema contém sete campos separados por um espaço:

-   O minuto da hora (0-59).
-   A hora do dia (0-23).
-   O dia do mês (1-31).
-   O mês do ano (1-12).
-   O dia da semana (0-7 com Domingo=0 ou Domingo=7).
-   O nome da conta de usuário a ser usada ao executar o comando.
-   O comando a executar.
    
Quanto aos crontabs do usuário, podemos especificar mais de um valor nos campos de tempo usando os operadores  `*`,  `,`  ,  `-`  e  `/`. Também é possível indicar o mês do ano e o dia da semana com as três primeiras letras do nome em vez do número correspondente.

- **crontab de sistema**: `/etc/crontab` e `/etc/cron.d`
	- `/etc/cron.hourly` (de hora em hora)
	- `/etc/cron.daily` (diariamente)
	- `/etc/cron.weekly` (semanalmente)
	- `/etc/cron.monthly` (mensalmente)
- **crontab de usuário**: `/var/spool/cron`

>[!WARNING]
>
>Algumas distribuições usam `/etc/cron.d/hourly`, `/etc/cron.d/daily`, `/etc/cron.d/weekly` e `/etc/cron.d/monthly`. Lembre-se de sempre conferir os diretórios corretos nos quais colocar os scripts que o cron deve executar.

### Especificações de tempo particulares

Ao editar os arquivos crontab, podemos usar atalhos especiais nas primeiras cinco colunas em vez das especificações de tempo:

- `@reboot`: roda a tarefa especificada uma vez após a reinicialização.
- `@hourly`: roda a tarefa especificada uma vez por hora no início da hora.
- `@daily`  (ou  `@midnight`): roda a tarefa especificada uma vez por dia à meia-noite.
- `@weekly`: roda a tarefa especificada uma vez por semana, à meia-noite de domingo.
- `@monthly`: roda a tarefa especificada uma vez por mês, à meia-noite do primeiro dia do mês.
- `@yearly`  (ou  `@annually`): roda a tarefa especificada uma vez por ano, à meia-noite de 1º de janeiro.

**Exemplos**

-   **`@reboot`**
    -   Executa a tarefa apenas uma vez, sempre que o sistema é inicializado.
    -   Exemplo:
        ```
        bash
        
        Copiar código
        
        `@reboot /path/to/script.sh` 
        ```
        
        Uso comum: Iniciar serviços personalizados ou scripts após reiniciar o servidor.
        
-   **`@hourly`**
    -   Executa a tarefa uma vez por hora, no minuto 0.
    -   Equivalente a:
        ```
        `0 * * * *` 
        ```
    -   Exemplo:
        ```
        bash
        
        `@hourly /path/to/script.sh` 
        ```
        
-   **`@daily` (ou `@midnight`)**
    
    -   Executa a tarefa uma vez por dia, à meia-noite.
    -   Equivalente a:
        ```
        `0 0 * * *` 
        ```
    -   Exemplo:
        ```
        bash
        
        `@daily /path/to/script.sh` 
        ```
        
-   **`@weekly`**
    
    -   Executa a tarefa uma vez por semana, no primeiro minuto do domingo.
    -   Equivalente a:
        ```
        `0 0 * * 0` 
        ```
    -   Exemplo:
        ```
        bash
        
        `@weekly /path/to/script.sh` 
        ```
        
-   **`@monthly`**
    
    -   Executa a tarefa uma vez por mês, no primeiro minuto do primeiro dia.
    -   Equivalente a:
        ```
        `0 0 1 * *` 
        ```
    -   Exemplo:
        ```
        bash
        
        `@monthly /path/to/script.sh` 
        ```
        
-   **`@yearly` (ou `@annually`)**
    
    -   Executa a tarefa uma vez por ano, no primeiro minuto do primeiro dia do ano.
    -   Equivalente a:
        ```
        `0 0 1 1 *` 
        ```
    -   Exemplo:
	   ```
        bash
        
        `@yearly /path/to/script.sh`
	```

#### Variáveis no crontab

Dentro de um arquivo crontab, pode haver atribuições de variáveis definidas antes que as tarefas agendadas sejam declaradas. As variáveis de ambiente comumente definidas são:

- `HOME`: o diretório no qual o  `cron`  invoca os comandos (por padrão, o diretório inicial do usuário).
- `MAILTO`: o nome do usuário ou o endereço para o qual a saída e o erro padrão são enviados (por padrão, o proprietário do crontab). Diversos valores separados por vírgulas também são permitidos, e um valor vazio indica que nenhum email deve ser enviado.
- `PATH`: o caminho no qual os comandos podem ser encontrados.
- `SHELL`: o shell a ser usado (por padrão  `/bin/sh`).

No `crontab`, variáveis como `HOME`, `MAILTO`, `PATH`, e `SHELL` são usadas para definir o ambiente no qual os comandos serão executados. Aqui está uma explicação detalhada e exemplos para cada uma:

---

### 1. **`HOME`**
   - Define o diretório de trabalho padrão para os comandos executados pelo `crontab`.
   - Se não for especificado, o valor padrão geralmente é o diretório home do usuário que criou o crontab.
   - Exemplo:
     ```bash
     HOME=/home/usuario
     @daily /path/to/script.sh
     ```
     Aqui, o script será executado com `/home/usuario` como diretório de trabalho.

---

### 2. **`MAILTO`**
   - Define o endereço de email para o qual serão enviados os logs de saída e erros dos comandos executados.
   - Se definido como vazio (`MAILTO=""`), o email não será enviado.
   - Exemplo:
     ```bash
     MAILTO=admin@exemplo.com
     @hourly /path/to/script.sh
     ```
     Aqui, os logs da execução do script serão enviados para `admin@exemplo.com`.

---

### 3. **`PATH`**
   - Define os diretórios onde o `crontab` buscará os comandos executados.
   - Por padrão, o `PATH` do cron é mais restrito que o de um shell interativo, frequentemente algo como `/usr/bin:/bin`.
   - Exemplo:
     ```bash
     PATH=/usr/local/bin:/usr/bin:/bin
     @daily script.sh
     ```
     Aqui, o cron poderá localizar `script.sh` se ele estiver em qualquer um dos diretórios especificados.

---

### 4. **`SHELL`**
   - Define qual shell será usado para executar os comandos.
   - O valor padrão geralmente é `/bin/sh`.
   - Exemplo:
     ```bash
     SHELL=/bin/bash
     @reboot /path/to/script.sh
     ```
     Aqui, o script será executado usando o Bash em vez do shell padrão.

---

### Exemplo Completo
```bash
SHELL=/bin/bash
HOME=/home/usuario
MAILTO=admin@exemplo.com
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin

@hourly /home/usuario/scripts/backup.sh
@daily /home/usuario/scripts/limpeza.sh
```

### O que acontece aqui:
1. O `backup.sh` será executado a cada hora.
2. O `limpeza.sh` será executado diariamente.
3. Os logs dessas tarefas serão enviados para o email `admin@exemplo.com`.
4. Os comandos serão executados no diretório `/home/usuario` usando o Bash.

---

### Dicas Adicionais
- Se seus scripts dependem de variáveis de ambiente específicas (como `JAVA_HOME`), você pode defini-las no início do arquivo `crontab`.
- Teste seus comandos ou scripts manualmente para evitar problemas de execução devido a configurações de ambiente no cron. 

### uso interessante para o dia a dia

    @daily /path/to/script.sh >> /var/log/script.log 2>&1
    
Executa diariamente o script script.sh e joga a saída de sucesso ou de erro no arquivo script.log (2>&1 indica para jogar as duas saídas no arquivo script.log)

Outro exemplo interessante, executar o script  `barfoo.sh`  localizado no diretório  `/root`  todos os dias à 01:30, abra  `/etc/crontab`  com seu editor preferido e adicione a seguinte linha:

    30 01 * * * root /root/barfoo.sh >>/root/output.log 2>>/root/error.log

No exemplo acima, a saída do job é anexada a  `/root/output.log`, enquanto os erros são anexados a  `/root/error.log` (`2>` é a saída padrão para erro, usando `2>>` vai concatenar os valores).

>[!WARNING]
>
>Exceto nos casos em que a saída é redirecionada para um arquivo, como no exemplo acima (ou se a variável `MAILTO` estiver definida como um valor em branco), toda a saída de um trabalho cron será enviada ao usuário via email. Uma prática comum é redirecionar a saída padrão para `/dev/null` (ou para um arquivo, para revisão posterior, se necessário) e não redirecionar o erro padrão. Desta forma, o usuário é notificado imediatamente por email sobre eventuais erros.

### Cron para usuários

Para listar os agendamentos do seu usuário: `contrab -l -u rodrigo`. Se tentar listar agendamentos de outro usuário, se deparará com a mensagem que a opção `-u` deve ser com usuário privilegiado (root ou usuário com privilégio de root).

    must be privileged to use -u

- `crontab -e`: entra no modo de edição do crontab. (primeiro acesso lhe pergunta qual editor que usa). O formato é parecedo com o crontab que foi visto anteriormente, apenas com a exceção que não tem o campo de usuário.

Vejamos um exemplo:<br>

    #m	h	dia	mes	diasemana	comando/script
    15	13	1,10,20,30	* 1-5	/home/rodrigo/Scripts/script.sh >> /tmp/teste-cron.txt

Acima temos:<br>
nos dias 1,10,20,30 às 13h15m, em todo/qualquer mês (`*`), de segunda à sexta-feira (1=segunda, 5=sexta-feira), execute o script em `/home/rodrigo/Scripts/script.sh` e grava a saída do `script.sh` no arquivo `/tmp/teste-cron.txt`<br>
**Observação**: se os dias 1, 10, 20, ou 30 caírem em um sábado ou domingo, o script.sh não vai rodar.

Outro exemplo:

    #m		h	dia		mes	diasemana	comando/script
    */10	*	*		* 	*			/ cd /tmp ; rm -f teste

Nesse caso, a cada 10 minutos o comando será executado. (A `/` significa **a cada**). Se usar `*/5` no dia, seria a cada 5 dias, etc

Mais um exemplo para ilustrar:

    #m		h	dia		mes	diasemana	comando/script
	0		0	1		1	* /usr/bin/fogo-artificio.sh

No dia 1 de Janeiro, de todo ano, às meia noite (hora = 0 e minuto = 0), executa o script `fogos-artificio.sh`

Exemplo com range:<br>

    #m		h		dia		mes	diasemana	comando/script
    20		9-18	*		*	1-5 		/home/usuario/relatorio.sh

Em todo minuto 20, das horas entre 9h e 18h (horário comercial), qualquer dia, qualquer mês, de segunda à sexta-feira, executa o script `relatorio.sh`<br>
Observação: Lembrando que isso é referente ao usuário atual, e os scripts precisam ter permissão de execução.

- `crontab -r`: remove toda configuração do crontab.
- `# crontab -r -u lpi2`: (só root pode) remover crontab de outro usuário
- `crontab -u`: especifica o nome do usuário cujo crontab precisa ser modificado. Esta opção requer privilégios de root e permite que o usuário root edite os arquivos crontab do usuário.

Há possibilidade de criar um arquivo separado contendo as regras da crontab, e importar com o comando: `crontab arquivo_com_contrab`. Confirme com `contrab -l`

Essas modificações, tanto em sistema (`/etc/cron`) como a de usuário, são permanentes, e o(s) arquivo(s) do(s) usuário(s) fica(m) em `/var/spool/cron/crontabs` (precisa ser acesso como **root**). Em algumas distros pode ser que o diretório `crontabs` seja apenas `cron`.

Usuário root pode determinar quem pode e quem não pode utilizar crontab. Isso se baseia nos arquivos:
- /etc/cron.allow ou
- /etc/cron.deny

*Pode ser que esses arquivos não existam, sendo necessário criá-los. A lista de usuários é comum, linha a linha. O `cron.allow` tem prioridade em cima do `cron.deny` (caso tenha os mesmos usuários nas duas listas.

>[!NOTE]
>
>Há uma diferença no comportamento dos arquivos  **/etc/cron.allow**  e  **/etc/cron.deny**  entre sistemas baseados em Debian e RedHat.<br>
No Debian, e distribuições baseadas como o Ubuntu que usamos nesse curso, se ambos arquivos não existem, o uso dos recursos da cron é liberado para todos os usuários.<br>
No entanto, em sistemas baseados em RedHat, como o CentOS, na inexistência dos arquivos, o uso é bloqueado a todos os usuários, exceto para o usuário root.

#### Exercício interessante no lpi.org

Crie um job agendado simples que execute o comando  `date`  todas as sextas-feiras às 13h. Onde você poderia ver o resultado deste trabalho?

    00 13 * * 5 date

A saída é enviada ao usuário; para visualizá-la, use o comando  `mail`(no caso, é possível ver a saída com esse comando, mas precisa ter o pacote **mailutils** instalado (`apt install mailutisl`)

#### Exercício com MAILTO

Como é possível enviar a saída e os erros do seu trabalho agendado para a conta de usuário  `emma`  via email? E como evitar o envio da saída padrão e erros por email?

Para enviar a saída padrão e o erro para  `emma`, definimos a variável de ambiente  `MAILTO`  em nosso arquivo  `crontab`  desta forma:

    MAILTO="emma"

Para dizer ao  `cron`  que nenhum email deve ser enviado, atribuímos um valor vazio à variável de ambiente  `MAILTO`.

    MAILTO=""

### at (agendamento de uma execução)

Tipo de agendamento em determinada hora/momento (executa apenas uma vez)

    at now +2hour
    at> echo "Hora cafe"

Executa o echo `"Hora do café"` daqui duas horas, e poderia ir adicionando comandos. No final use `Ctrl+D` para adicionar essa tarefa (job).<br>
**(Como no caso do `cron`, a saída padrão e o erro são enviados por email)<br>
***Observe que o daemon `atd` precisará estar rodando no sistema para ser possível usar o agendamento de tarefas `at`

>[!NOTE]
>
>No Linux, o comando `batch` é semelhante a `at`, porém os jobs `batch` são executados apenas quando a carga do sistema está baixa o suficiente para permiti-lo.

- `atq` ou `at -l`: mostra os jobs que estão aguardando (vem de `queue`).

>[!NOTE]
>
>Se você executar `atq` como root, ele exibirá os trabalhos na fila para todos os usuários.

```
at 13:20
at> echo "Hora do almoço
```

Executa o echo às `13:20`. Caso já tenha passado esse horário, o at agenda para o dia seguinte. (para especificar quando um job `at` determinado deve ser executado, use o formato `HH:MM`, seguido opcionalmente por **AM** ou **PM** no caso do formato de 12 horas)

Formatos aceitos para passar uma data após a hora:
- `MMDDYY`
- `MM/DD/YY`
- `DD.MM.YY` e
- `YYYY-MM-DD`

- `at midnight`: agenda para meia noite
- `at teatime`: agenda para às 16h ou 4PM (hora do chá)
- `at noon`: agenda para hora do almoço - meio-dia
- `now`: para agora

- `at 02:20pm 05202024`: agenda para dia 20/05/2024 às 14:20

Para **remover** algum job feito pelo at: `atrm 10` ou `at -d 10`: remove o job 10.

>[!NOTE]
>
>O usuário que rodar `atrm` como root pode excluir os jobs de todos os outros usuários.

- `/etc/at.allow`: permite quais usuário usar o `at`
- `/etc/at.deny`: nega quais usuário a usar o `at` (esse já vem criado, preenchido com usuários do sistema, permitindo somente usuários comuns utilizar)

**As opções mais importantes do comando**  `at`  são:

- `-c`: imprime os comandos de um ID de trabalho específico na saída padrão.
- `-d`: exclui trabalhos com base em seu ID de trabalho. É um alias para  `atrm`.
- `-f`: lê o job em um arquivo em vez da entrada padrão.
- `-l`: lista as tarefas pendentes do usuário. Se o usuário for root, todos os trabalhos de todos os usuários serão listados. É um alias para  `atq`.
- `-m`: envia um email para o usuário no final do trabalho, mesmo se não houver saída.
- `-q`: especifica uma fila na forma de uma única letra de  `a`  a  `z`  e de  `A`  a  `Z`  (por padrão,  `a`  para  `at`  e  `b`  para  `batch`). Os jobs nas filas com as letras mais altas são executados com um valor nice maior. Os jobs enviados a uma fila com uma letra maiúscula são tratados como trabalhos em lote (`batch`).
- `-v`: mostra a hora em que o trabalho será executado antes de ler o trabalho.

Leia o arquivo `timespec` na árvore `/usr/share` para saber mais sobre a definição exata das especificações de data e hora.

#### Agendamento de Tarefas - systemd timer

- `systemct list-timers`: lista os agendamentos que já estão no sistema, no caso `UNITs`, com sufixo  (terminam com)`.timer`, ligadas às `ACTIVATES`, com sufixo (terminam com) `.service` (Por padrão, um `timer` ativa um serviço com o mesmo nome, exceto pelo sufixo).
- `systemct list-timers --all`: mostra agendamentos que possam estar inativas
- `systemctl list-units --type=timer`: lista as unidades do tipo `timer`

Para observar uma unit, é possível pode meio do comando:<br>
- `systemct list-timers`

```
$ systemctl status apt-daily-upgrade.timer 
● apt-daily-upgrade.timer - Daily apt upgrade and clean activities
     Loaded: loaded (/usr/lib/systemd/system/apt-daily-upgrade.timer; enabled; preset: enabled)
     Active: active (waiting) since Fri 2024-11-08 16:41:52 -03; 5 days ago
    Trigger: Fri 2024-11-15 06:13:26 -03; 16h left
   Triggers: ● apt-daily-upgrade.service

Nov 08 16:41:52 OptiPlex-3080 systemd[1]: Started apt-daily-upgrade.timer - Daily apt upgrade and clean activities.
```

Na terceira linha, é mostrado onde está configurado o `.timer`, no caso: `/usr/lib/systemd/system/apt-daily-upgrade.timer`(esse arquivo que seria alterado para definir novo agendamento). Sendo em um formato normal de unit, com sua descrição, e demais itens.

O que é interessante é a parte de `[Timer]`, onde tem a opção `onCalendar`, com a seguinte sintaxe:
- `OnCalendar= *-*-* 6:00`: sendo qualquer ano (*), qualquer mês (*), qualquer dia (*) às 6 horas.
- `OnCalendar= *-*-* 6..18:00,30 `: sendo qualquer ano (*), qualquer mês (*), qualquer dia (*) das 6 até às 18h, no minuto 00 e minuto 30. Se preferir, pode adicionar dois pontos (`:`) e informar os segundos, ou `*` para qualquer segundo.
- `OnCalendar=Mon..Fri *-*-* 6:00`: caso queira colocar de segunda à sexta-feira (entre dois valores para indicar um intervalo contíguo)
- `OnCalendar=Sat,Sun *-*-* 6:00`: caso queira colocar sábado e domingo (padrão para **Debian** e derivados - **RedHat** seria `Mon-Fri`)

- `RandomizedDelaySec=60m`: nessa faixa de 60 minutos, a execução pode fica aleatória dentro desse tempo, para que não tenha várias coisas executando ao mesmo tempo, achando um gap melhor para essa execução.
- `Persistend=true`: grava caso o `.service` seja executado manualmente. E considera essa informação para a próxima execução.

Na Unit do `.service`, é basicamente um `.service` comum, que é descrito o que será executado no `ExecStart`.<br>
Mais detalhes em `man systemd.timer`. Mais detalhes de como especificar a data e hora no calendar, usar: `man systemd.time`

Vejamos o exemplo de `systemd-tmpfiles-clean.timer`:<br:
- executa `systemctl status systemd-tmpfiles-clean.timer` para saber onde está carregado esse arquivo, no caso é em `/usr/lib/systemd/system/systemd-tmpfiles-clean.timer`, tendo como conteúdo:
```
[Unit]
Description=Daily Cleanup of Temporary Directories
Documentation=man:tmpfiles.d(5) man:systemd-tmpfiles(8)
ConditionPathExists=!/etc/initrd-release

[Timer]
OnBootSec=15min
OnUnitActiveSec=1d
```
Em `OnUnitActiveSec`, é informado que se a unidade estiver ativa, para executar o serviço a cada 1 dia. Em `OnBootSec` é nítido que será executado após 15 minutos. Isso é para casos que o sistema não é desligado.

**Outro exemplo interessante listado nas lições da lpi.org**

Por exemplo, para rodar o serviço  `/etc/systemd/system/foobar.service`  às 05:30 da primeira segunda-feira do mês, adicionamos as seguintes linhas no arquivo de unidade  `/etc/systemd/system/foobar.timer`  correspondente:

    [Unit]
    Description=Run the foobar service
    
    [Timer]
    OnCalendar=Mon *-*-1..7 05:30:00
    Persistent=true
    
    [Install]
    WantedBy=timers.target

Depois de criar o novo temporizador, você pode ativá-lo e iniciá-lo executando os seguintes comandos como root:

    # **systemctl enable foobar.timer**
    # **systemctl start foobar.timer**

Podemos alterar a frequência do trabalho agendado modificando o valor  `OnCalendar`  e, em seguida, digitando o comando  `systemctl daemon-reload`.

Finalmente, se você quiser ver a lista de temporizadores ativos ordenados pelo momento em que terminam, use o comando  `systemctl list-timers`. A opção  `--all`  exibe também as unidades de temporizador inativas.

>[!NOTE]
>
>Lembre-se de que os temporizadores são registrados no diário (journal) do systemd e você pode rever os registros das diferentes unidades usando o comando  `journalctl`. Além disso, se estiver trabalhando como um usuário comum, será preciso usar a opção  `--user`  dos comandos  `systemctl`  e  `journalctl`.

##### Criando um agendamento

1. criar um **serviço**, dentro de `/etc/systemd/system`:
	1.1 usar `vim exemplo.servce`
```
[Unit]
Description=Exemplo systemd-timer

[Service]
Type=oneshot
ExecStart=/bin/sh -c '/bin/date >> /tmp/exemplo-system.txt'
```

2. criar um **timer**, dentro de `/etc/systemd/system`:
	2.1 usar `vim exemplo.timer` (usar o mesmo nome, mudando só o final)
```
[Unit]
Description=Teste de systemd

[Timer]
OnCalendar=*-*-* *:*:10 # toda hora, todo min, no segundo 10

AccuracySec=1us # 1 micro segundo ou 1ms, que é a margem para executar com precisão. Se for muito alto, lembrar que tem prioridade.

Unit=teste.service
```

No `OnCalendar`, pode informar só a hora: `OnCalendar=*:*:10`<br>
No `AccuracySec` lembrar da prioridade, se colocar tempo muito alto e se estiver tendo muita execução, vai utilizar um tempo random dentro do intervalo colocado

Se rodar `systemctl list-timer`, o timer feito não aparece. Portanto é preciso iniciar o timer criado: `systemctl start exemplo.timer`. Executando novamente `systemctl list-timer`, já vai aparecer na lista. É interessante também recarregar as informações do daemon do systemctl, com o comando `systemctl daemon-reload`

Em vez da forma normalizada mais longa mencionada acima, é possível usar algumas expressões especiais que descrevem frequências específicas para a execução de um job:

- `hourly`: roda a tarefa especificada uma vez por hora, no início da hora.
- `daily`: roda a tarefa especificada uma vez por dia à meia-noite.
- `weekly`: roda a tarefa especificada uma vez por semana, na meia-noite de segunda-feira.
- `monthly`: roda a tarefa especificada uma vez por mês, na meia-noite do primeiro dia do mês.
- `yearly`: roda a tarefa especificada uma vez por ano, na meia-noite de 1º de janeiro.

Consulte as páginas de manual para ver a lista completa de especificações de hora e data em  `systemd.timer(5)`.

No **`systemd`**, os **timers** substituem ou complementam o uso do `cron` para agendamento de tarefas, proporcionando maior flexibilidade e integração com o sistema. Aqui estão os equivalentes aos atalhos do `crontab` usando **`systemd.timer`**:

---

### Estrutura de um Timer no `systemd`
Um timer no `systemd` geralmente é composto por dois arquivos:

1. **Arquivo de Serviço (`.service`)**
   - Define o que será executado.
2. **Arquivo de Timer (`.timer`)**
   - Define quando será executado.

---

### Equivalentes no `systemd.timer`
Os timers no `systemd` usam o campo `[Timer]` para configurar os intervalos de execução. Aqui estão os exemplos:

1. **`@reboot` (ao iniciar o sistema)**
   - Use o parâmetro **`OnBootSec`** no arquivo `.timer`.
   - Exemplo:
     ```ini
     [Timer]
     OnBootSec=1min
     ```
     Este timer executará a tarefa 1 minuto após o sistema inicializar.

2. **`@hourly` (uma vez por hora)**
   - Use **`OnCalendar`** com o valor `hourly`.
   - Exemplo:
     ```ini
     [Timer]
     OnCalendar=hourly
     ```
     Este timer será acionado no início de cada hora.

3. **`@daily` (uma vez por dia, à meia-noite)**
   - Use **`OnCalendar`** com o valor `daily`.
   - Exemplo:
     ```ini
     [Timer]
     OnCalendar=daily
     ```
     O timer será acionado diariamente à meia-noite.

4. **`@weekly` (uma vez por semana, no domingo)**
   - Use **`OnCalendar`** com o valor `weekly`.
   - Exemplo:
     ```ini
     [Timer]
     OnCalendar=weekly
     ```
     O timer será acionado no primeiro minuto de cada domingo.

5. **`@monthly` (uma vez por mês, no primeiro dia)**
   - Use **`OnCalendar`** com o valor `monthly`.
   - Exemplo:
     ```ini
     [Timer]
     OnCalendar=monthly
     ```
     O timer será acionado no primeiro minuto do dia 1 de cada mês.

6. **`@yearly` (ou `@annually`)**
   - Use **`OnCalendar`** com o valor `yearly`.
   - Exemplo:
     ```ini
     [Timer]
     OnCalendar=yearly
     ```
     O timer será acionado no primeiro minuto do primeiro dia de cada ano.

---

### Exemplo Completo
Aqui está um exemplo completo para criar um serviço e um timer que executam um script diariamente.

### Arquivo de Serviço (`exemplo.service`)
```ini
[Unit]
Description=Executa o script de exemplo

[Service]
ExecStart=/path/to/script.sh
```

### Arquivo de Timer (`exemplo.timer`)
```ini
[Unit]
Description=Executa o script de exemplo diariamente

[Timer]
OnCalendar=daily

[Install]
WantedBy=timers.target
```

#### Comandos para Ativar
1. Coloque os arquivos em `/etc/systemd/system/`.
2. Habilite o timer:
   ```bash
   sudo systemctl enable exemplo.timer
   ```
3. Inicie o timer:
   ```bash
   sudo systemctl start exemplo.timer
   ```

---

### Vantagens do `systemd.timer`
- Integração nativa com o `systemd` (logs em `journalctl`).
- Opções adicionais, como **`AccuracySec`** (ajustar precisão) e **`Persistent`** (executar tarefas perdidas durante períodos de inatividade).

Isso torna o `systemd` uma alternativa poderosa ao `cron` para tarefas agendadas! 

##### systemd-run (equivalente ao at)

Normalmente ele é usado para criar uma unidade transiente de temporizador para que um comando seja executado em um momento específico sem a necessidade de se criar um arquivo de serviço

Por exemplo, atuando como root, você pode executar o comando  `date`  às 11h30 em 06/10/2019 usando o seguinte:

    # **systemd-run --on-calendar='2019-10-06 11:30' date**

Se quiser executar o script  `foo.sh`, localizado em seu diretório atual, depois de dois minutos, use:

    # **systemd-run --on-active="2m" ./foo.sh**

- `system-run --on-active=60s /bin/touch /tmp/exemplo-run.txt`: roda após **60 segundos** o comando `touch` que criar o arquivo `exemplo-run.txt` em `/tmp`
- `system-run --on-active=60s --time-property=AccuracySec=1ms /bin/touch /tmp/exemplo-run.txt`: faz o mesmo do comando anterior, mas em system-run também tem a questão de prioridade, e se quiser com precisão, precisar incluir o argumento `--time-property`

É possível observar que após rodar o `system-run` acima, será retornado um run, que no caso é algo parecido com isso: `run-sequecia-caracteres.timer`

Se pegar esse `.timer` e olhar no `journalctl`, com a opção `-u` `--unit`, mais o `run` (`journalctl -u run-sequecia-caracteres.timer`), é possível notar que já está rodando (mas o comando ainda não foi executado - lembre-se, foi configurado para 60 segundos).

Se olhar no `systemctl list-timers` o `run-sequecia-caracteres.timer` que foi criado, vai estar listado, mostrando quanto tempo falta para sua hora de executar.

Depois que passar os 60 segundos, ele irá executar, e **não** irá mais aparecer no `systemctl list-timers`. Mostrando que fez 1 execução apenas. É possível ter certeza verificando o .service dele, com o comando `journalctl -u run-sequecia-caracteres.service`

Consulte as páginas de manual para aprender todos os usos possíveis de  `systemd-run`  com  `systemd-run(1)`.

>[!NOTE]
>
>Os temporizadores são registrados no diário do systemd e você pode rever os registros das diferentes unidades usando o comando `journalctl`. Além disso, se estiver trabalhando como um usuário comum, precisará usar a opção `--user` dos comandos `systemctl` e `journalctl`.

## 107.3 Localização e internacionalização

Para o Linux, o horário padrão é o UTC (Tempo Universal Coordenado). O UTC substituiu o GMT (Greenwich Meridian Time) ou Z (Zulu), que se baseava na hora local de Greenwich. Depois disso ele pega e converte para o que foi configurado de acordo com a localização.

- `timedatectl`: (disponível em distribuições que usam o `systemd`) é um date melhorado, mais completo, que descreve a **data/hora** em diferentes formatos (embora o `date` também mostre o deslocamento em relação a UTC.)

Tudo isso fica configurado em `/etc/localtime` (é um arquivo que não tem como ler, nele fica configurado a questão do **timezone**, horário de verão - **daylight saving time**). Lembrando que `/etc/localtime` aponta para `/usr/share/zoneinfo/America/Sao_Paulo` (a depender da sua localização).

    ls -l /etc/localtime 
    lrwxrwxrwx 1 root root 37 Nov  8 16:21 /etc/localtime -> /usr/share/zoneinfo/America/Sao_Paulo

Vendo em `/usr/share/zoneinfo/Brazil` é possível notar onde `/etc/localtime` está apontando:

    ls -l /usr/share/zoneinfo/Brazil/
    total 0
    lrwxrwxrwx 1 root root 21 Nov  8 16:20 Acre -> ../America/Rio_Branco
    lrwxrwxrwx 1 root root 18 Nov  8 16:20 DeNoronha -> ../America/Noronha
    lrwxrwxrwx 1 root root 20 Nov  8 16:20 East -> ../America/Sao_Paulo
    lrwxrwxrwx 1 root root 17 Nov  8 16:20 West -> ../America/Manaus

Em `/etc/timezone` está contido o fuso horário padrão padrão do sistema: (se der um `cat` nesse arquivo, retorna `America/Sao_Paulo`)

Os nomes genéricos de fusos horários indicados pela diferença em relação a UTC devem incluir  `Etc`  na primeira parte do nome. Assim, para definir o fuso horário padrão como GMT+3, o nome do fuso horário deve ser  `Etc/GMT+3`:

    $ **cat /etc/timezone**
    Etc/GMT+3

- `tzselect`: usado para ajudar a selecionar o **timezone** correto/desejado. (Também é possível especificar o fuso horário com coordenadas geográficas ou com a notação de deslocamento, também conhecida como _formato Posix TZ_)

Para alterar o timezone apenas da sessão atual, pode-se alterar a variável `$TZ`:<br>

    - export TZ=America/Chicago<br>

*Faça um date antes e depois de alterar o timezone para perceber as mudanças:<br>

    $ date
    Mon Nov 18 20:22:49 AM -03 2024
    $ export TZ=America/Los_Angeles
    $ date
    Mon Nov 18 15:23:05 AM PST 2024

*Lembrando que isso apenas está traduzindo o que está internamente no UTC. Para voltar a data no timezone que estava antes, basta executar: `unset TZ`.

Ainda alterando o `TZ`, se criar um arquivo, a data de criação atualiza caso o `TZ` seja alterado. Isso se torna interessante quando há usuário de diferentes timezones, para que possa ajustar de acordo com a localização (ajustar no `.bashrc`, por exemplo - ou até mesmo para todos os usuário, em `/etc/profile`).

>[!NOTE]
>
>Só o território brasileiro abrange quatro fusos horários.

A mudança por meio da variável prevalece a configuração em `/etc/localtime`. Podemos preencher da forma por extenso também:

    TZ=:/usr/share/zoneinfo/America/Sao_Paulo

Para alterar por meio do `/etc/localtime`, basta remover o link atual, e apontar para um novo (esse novo é possível consultar por meio das opções que há em `/usr/share/zoneinfo`)

    $ ls -l /etc/localtime
    /etc/localtime -> /usr/share/zoneinfo/America/Sao_Paulo
    
    rm -f /etc/localtime
    
    ln -s /usr/share/zoneinfo/Asia/Bangkok /etc/localtime

Confirme as mudanças com os comandos `date` e `timedatectl`. As mudanças são refletidas de imediato.

Uma máquina conectada pode ser acessada de diferentes partes do mundo, de forma que é aconselhável definir o relógio do hardware para UTC (o fuso horário GMT+0) e deixar a escolha do fuso horário para cada caso particular. Os serviços em nuvem, por exemplo, costumam ser configurados para usar UTC, o que pode ajudar a mitigar eventuais inconsistências entre o horário local e o horário dos clientes ou de outros servidores. Por outro lado, os usuários que abrem uma sessão remota no servidor podem querer usar seu fuso horário local. Assim, caberá ao sistema operacional configurar o fuso horário correto de acordo com cada caso.

### Localização e Internacionalização - Idioma, Linguagem e Codificação

- `locale`: lista informações específicas de acordo com locais, países no mundo, tais como: sistema monetário, se usa vírgula ou ponto, formato de datas, etc, assim como o tipo de codificação de caracteres. (tudo isso são variáveis de ambiente - vide `env | grep "^LC"`, perceba que há uma chamada `LC_ALL`, que sobrescreve todas as demais).

É possível configurar pelo `.bashrc` ou `/etc/profile`, definindo diretamente as variáveis por sessão ou para todos os usuários, respectivamente.

Por exemplo, caso esteja utilizando o modelo brasileiro de representação dos números, em uma moeda, e queira mudar para o modelo dos Estados Unidos, use: `export  LC_AL=en_US.UTF-8`. Para remover, `unset LC_ALL`.

Ex. **en_US.UTF-8** ou **pt_BR.UTF-8** (codificação usada na instalação)

- `locale -a` (`--all-locales`): lista os modelos disponíveis para o uso.

### Conversão de codificação

O primeiro mais antigo é o ASCII (_American Standard Code for Information Interchange_), depois foi melhorado para ISO/IEC 8859-1, e UTF-8 é o mais recente/utilizado. Se escrever um arquivo com caracteres especiais no Windows, e abrir no Linux, vai haver divergência (lembrando que para verificar a codificação do arquivo, pode-se utilizar o comando `file nome_arquivo`)

- `iconv -f ISO-8859-1 -t UTF-8 nome_do_arquivo`: (`-f` ou `--from-code` e `-t` ou `--to-encode`) converte o arquivo, que antes estava na decodificação do Windows, para a codificação que o Linux entende. (para casos que um texto no Windows não leia no Linux)
Para listar todas as codificações suportadas pelo comando `iconv`, usamos o comando `iconv -l` ou `iconv --list`. Ao invés de usar o redirecionamento de saída, como no exemplo, a opção `-o converted.txt` ou `--output converted.txt` também faz o serviço.

#### Exercicio sobre iconv

Os caracteres dos arquivos de texto podem não ser exibidos corretamente em um sistema com uma codificação de caracteres diferente da usada na criação do documento de texto. Como o  `iconv`  pode ser usado para converter o arquivo  `old.txt`, codificado em WINDOWS-1252, no arquivo  `new.txt`, que usa a codificação UTF-8?

O comando  `iconv -f WINDOWS-1252 -t UTF-8 -o new.txt old.txt`  realizará a conversão desejada.


>[!TIP]
>
>O comando `localectl`, disponível em sistemas que empregam o _systemd_ como gerenciador de sistema, também pode ser usado para consultar e alterar a localidade do sistema. Por exemplo: `localectl set-locale LANG=en_US.UTF-8`.

Além da variável  `LANG`, outras variáveis de ambiente afetam aspectos específicos da localidade, como o símbolo monetário ou o separador de milhar correto para números:
- `LC_COLLATE`: define a ordem alfabética. Uma de suas finalidades é definir a ordem em que os arquivos e diretórios são listados.
- `LC_CTYPE`: define como o sistema tratará certos conjuntos de caracteres. Ele define, por exemplo, quais caracteres considerar como  _maiúsculas_  ou  _minúsculas_.
- `LC_MESSAGES`: define o idioma para exibir as mensagens de programas (principalmente programas do GNU).
- `LC_MONETARY`: define a unidade monetária e o formato da moeda.
- `LC_NUMERIC`: define o formato numérico para valores não-monetários. Sua finalidade principal é definir os separadores de milhar e decimais.
- `LC_TIME`: define o formato de hora e data.
- `LC_PAPER`: define o tamanho padrão do papel.
- `LC_ALL`: sobrepõe todas as outras variáveis, incluindo  `LANG`.

O comando  `locale`  mostra todas as variáveis definidas na configuração de localidade atual:

    $ **locale**
    LANG=pt_BR.UTF-8
    LC_CTYPE="pt_BR.UTF-8"
    LC_NUMERIC=pt_BR.UTF-8
    LC_TIME=pt_BR.UTF-8
    LC_COLLATE="pt_BR.UTF-8"
    LC_MONETARY=pt_BR.UTF-8
    LC_MESSAGES="pt_BR.UTF-8"
    LC_PAPER=pt_BR.UTF-8
    LC_NAME=pt_BR.UTF-8
    LC_ADDRESS=pt_BR.UTF-8
    LC_TELEPHONE=pt_BR.UTF-8
    LC_MEASUREMENT=pt_BR.UTF-8
    LC_IDENTIFICATION=pt_BR.UTF-8
    LC_ALL=

A única variável indefinida é  `LC_ALL`, que pode ser usada para substituir temporariamente todas as outras configurações locais. O exemplo a seguir mostra como o comando  `date` — sendo executado em um sistema configurado para a localidade  `pt_BR.UTF-8` — modifica sua saída de forma a cumprir a nova variável  `LC_ALL`:

    $ **date**
    seg out 21 10:45:21 -03 2019
    $ **env LC_ALL=en_US.UTF-8 date**
    Mon Oct 21 10:45:21 -03 2019

A modificação da variável `LC_ALL` fez com que ambas as abreviações de dia da semana e nome do mês fossem mostradas em inglês americano (`en_US`). Não é obrigatório, entretanto, definir a mesma localidade para todas as variáveis. É possível, por exemplo, ter a linguagem definida como `pt_BR` e o formato numérico (`LC_NUMERIC`) no padrão americano.

Algumas configurações de localização alteram a forma como os programas lidam com a ordem alfabética e formatos de numeração. Embora os programas convencionais geralmente sejam capazes de escolher corretamente uma localidade comum para essas situações, os scripts podem se comportar de forma inesperada ao tentar ordenar corretamente uma lista de itens em ordem alfabética, por exemplo. Por este motivo, recomenda-se definir a variável de ambiente `LANG` para a localidade comum `C`, como em `LANG=C`, para que o script produza resultados inequívocos, independentemente das definições de localização usadas no sistema onde é executado. A localidade C realiza apenas uma comparação simples de bytes e, portanto, também terá um desempenho melhor do que as outras.

## 108.1 Manutenção da data e hora do sistema

### Manutenção do Horário do Sistema - Relógios e os comandos date e hwclock

**hardware clock**: relógio da BIOS (aquela que usa bateria para armazenar data/hora)

**software clock**: relógio do Linux propriamente dito, depois que o SO sobe

Em linhas gerais, o hardware e software clock não são sincronizados pois são independentes. Isso fica nítido quando o computador está ligado por muito tempo.

- `date`: retorna a hora no sistema
- `date -u`: retorna data/hora UTC (GMT0)
- `date 12251200`: ajusta o relógio para 12 de dezembro às 12:00 (o ano é opcional). Opção com ano seria: `date 122512002024` (precisa ser como root).
- `date --set="11 Nov 2011 11:11:11"`: também redefine o horário. Neste caso, é necessário ter privilégios de root para definir a data. Também podemos optar por alterar a hora ou data independentemente:
```
    # date +%Y%m%d -s "20111125"
```
Aqui, devemos especificar as sequências para que nossa string seja analisada corretamente. Por exemplo,  `%Y`  refere-se ao ano e, portanto, os primeiros quatro dígitos  `2011`  serão interpretados como o ano de 2011. Da mesma forma,  `%T`  é a sequência de hora, como demonstrado aqui ao definirmos a hora (`-s` ou `--set`):
```
# date +%T -s "13:11:00"
```
Depois de alterar a hora do sistema, é recomendável também definir o relógio do hardware para que os relógios do sistema e do hardware estejam sincronizados:
```
# hwclock --systohc
```
Outras opções comumente usadas retornam a hora local em um formato RFC aceito:
- `-I`:  data/hora no formato ISO 8601. Anexar  `date`  (`-Idate`) limita a saída apenas à data. Outros formatos são  `hours`,  `minutes`,  `seconds`  e  `ns`  (para nanossegundos).
- `-R`:  retorna data e hora no formato RFC 5322.
- `--rfc-3339`:  retorna data e hora no formato RFC 3339.

O formato de  `date`  pode ser personalizado pelo usuário com as sequências especificadas na página de manual. Por exemplo, a hora atual pode ser formatada como tempo do Unix da seguinte maneira:

    $ date +%s
    1574014515

Na página de manual de  `date`, podemos ver que  `%s`  se refere ao tempo do Unix.

O tempo do Unix é usado internamente na maioria dos sistemas baseados em Unix. Ele armazena a hora UTC como o número de segundos desde a  _Época_, que foi definida como 1º de janeiro de 1970.

>[!NOTE]
>
>O número de bits necessários para armazenar a hora Unix no momento atual é de 32 bits. No futuro, 32 bits se tornarão insuficientes para conter a hora atual no formato Unix. Isso causará problemas sérios para qualquer sistema Linux de 32 bits. Felizmente, isso não ocorrerá até 19 de janeiro de 2038.

A opção  `--debug`  é muito útil para garantir que uma data possa ser analisada com sucesso. Observe o que acontece ao passarmos uma data válida para o comando:

    $ date --debug --date="Fri, 03 Jan 2020 14:00:17 -0500"
    date: parsed day part: Fri (day ordinal=0 number=5)
    date: parsed date part: (Y-M-D) 2020-01-03
    date: parsed time part: 14:00:17 UTC-05
    date: input timezone: parsed date/time string (-05)
    date: using specified time as starting value: '14:00:17'
    date: warning: day (Fri) ignored when explicit dates are given
    date: starting date/time: '(Y-M-D) 2020-01-03 14:00:17 TZ=-05'
    date: '(Y-M-D) 2020-01-03 14:00:17 TZ=-05' = 1578078017 epoch-seconds
    date: timezone: system default
    date: final: 1578078017.000000000 (epoch-seconds)
    date: final: (Y-M-D) 2020-01-03 19:00:17 (UTC)
    date: final: (Y-M-D) 2020-01-03 14:00:17 (UTC-05)

Essa é uma ferramenta útil para a resolução de problemas em um aplicativo que gera uma data.

- `hwclock` (`apt install util-linux-extra`): mostra o relógio do BIOS

O `hwclock` serve ainda para sincronizar o horário do sistema igual ao do horário do hardware, ou vice-versa.

- `hwclock -w` ou `--systohc` (**hc**=**hardware clock**): pega o horário do sistema e sincroniza com o relógio no BIOS: Sys->Bios
- `hwclock -s` ou `--hctosys`: faz o contrário, pega o horário do BIOS e sincroniza com o relógio do Linux: Bios->Sys

- `hwclock --set --date "12/25/2024 14:00"`: define o horário na BIOS<br>
**Na aula o comando acima retorna erro, formato inválido para a data. Procurando no man , o formato usado é: <br>
```
    sudo hwclock --set --date "YYYY-MM-DD HH:MM:SS"
```
- `hwclock  --verbose`: retorna mais resultados, que podem ser úteis para solucionar problemas. Observe o `Calculated Hardware Clock drift`. Esta saída informa se a hora do sistema e a hora do hardware estão divergindo uma da outra.

>[!NOTE]
>
>Para fins de logs, é utilizado o horário do sistema.

>[!NOTE]
>
>Alguns processos internos (principalmente em distros baseadas em Ubuntu), a hora é atualizada automaticamente.

- `timedatectl`  é um comando que pode ser usado para verificar o status geral de hora e data, incluindo se a hora da rede foi ou não sincronizada (na próxima lição, trataremos do Network Time Protocol).

Por padrão,  `timedatectl`  retorna informações semelhantes a  `date`, mas com a adição da hora RTC (hardware), bem como o status do serviço NTP:

    $ timedatectl
                   Local time: Thu 2019-12-05 11:08:05 EST
               Universal time: Thu 2019-12-05 16:08:05 UTC
                     RTC time: Thu 2019-12-05 16:08:05
                    Time zone: America/Toronto (EST, -0500)
    System clock synchronized: yes
                  NTP service: active
              RTC in local TZ: no

Se o NTP não estiver disponível, recomenda-se usar  `timedatectl`  em vez de  `date`  ou  `hwclock`  para definir a hora:

    # **timedatectl set-time '2011-11-25 14:00:00'**

O processo é semelhante ao de  `date`. O usuário também pode definir a hora independentemente da data com o formato **HH:MM:SS**

### Definindo o fuso horário com timedatectl

`timedatectl`  é a melhor maneira de configurar o fuso horário local nos sistemas Linux baseados em  `systemd`  quando não existe GUI.  `timedatectl`  lista os fusos horários possíveis e, a partir daí, o fuso horário pode ser definido usando um deles como argumento.

Primeiro, listamos os fusos horários possíveis:

    $ **timedatectl list-timezones**
    Africa/Abidjan
    Africa/Accra
    Africa/Algiers
    Africa/Bissau
    Africa/Cairo
    ...

A lista de fusos horários possíveis é longa, por isso o uso do comando  `grep`  é recomendado neste caso.

Em seguida, podemos definir o fuso horário usando um dos elementos da lista retornada:

    $ timedatectl set-timezone Africa/Cairo
    $ timedatectl
                   Local time: Thu 2019-12-05 18:18:10 EET
               Universal time: Thu 2019-12-05 16:18:10 UTC
                     RTC time: Thu 2019-12-05 16:18:10
                    Time zone: Africa/Cairo (EET, +0200)
    System clock synchronized: yes
                  NTP service: active
              RTC in local TZ: no

Lembre-se de que o nome do fuso horário deve ser exato.  `Africa/Cairo`, por exemplo, muda o fuso horário, mas  `cairo`  ou  `africa/cairo`  não.

### Desativando o NTP com timedatectl

Em alguns casos, pode ser necessário desativar o NTP. Podemos fazer isso com  `systemctl`, mas vamos demonstrar o procedimento com  `timedatectl`:

    # timedatectl set-ntp no
    $ timedatectl\
                 Local time: Thu 2019-12-05 18:19:04 EET Universal time: Thu 2019-12-05 16:19:04 UTC
                   RTC time: Thu 2019-12-05 16:19:04
                  Time zone: Africa/Cairo (EET, +0200)
                NTP enabled: no
           NTP synchronized: no
            RTC in local TZ: no
                 DST active: n/a

### Definindo o fuso horário sem timedatectl

A definição do fuso horário é uma etapa padrão ao se instalar o Linux em uma nova máquina. Se houver um processo de instalação gráfico, isso provavelmente será feito sem nenhuma ação adicional do usuário.

O diretório  `/usr/share/zoneinfo`  contém informações sobre os diferentes fusos horários possíveis. No diretório  `zoneinfo`, há subdiretórios com o nome dos continentes, bem como outros links simbólicos. Recomenda-se encontrar o  `zoneinfo`  da sua região começando por seu continente.

Os arquivos  `zoneinfo`  contêm as regras necessárias para calcular a diferença de horário local em relação a UTC e também são importantes se a sua região segue o horário de verão. O conteúdo de  `/etc/localtime`  será lido quando o Linux precisar determinar o fuso horário local. Para definir o fuso horário sem o uso de uma GUI, o usuário deve criar um link simbólico de  `/usr/share/zoneinfo`  para  `/etc/localtime`  informando sua localização. Por exemplo:

    $ **ln -s /usr/share/zoneinfo/Canada/Eastern /etc/localtime**

Depois de definir o fuso horário correto, recomenda-se executar:

    # **hwclock --systohc**

Isso configurará o  _relógio do hardware_  a partir do  _relógio do sistema_  (ou seja, o relógio em tempo real será configurado para a mesma hora que  `date`). Note que este comando é executado com privilégios de root; neste caso, você está logado como root.

`/etc/timezone`  é semelhante a  `/etc/localtime`. É uma representação de dados do fuso horário local e, como tal, pode ser lido usando  `cat`:

$ **cat /etc/timezone**
America/Toronto

Observe que este arquivo não é usado por todas as distribuições Linux.

### Configurando data e hora sem timedatectl

>[!NOTE]
>
>A maioria dos sistemas Linux modernos usa o  `systemd`  para sua configuração e serviços; assim, não é recomendado usar  `date`  ou  `hwclock`  para definir a hora. O  `systemd`  emprega para isso o  `timedatectl`. No entanto, é importante conhecer esses comandos legados no caso de você precisar administrar um sistema mais antigo.

**Exercício interessante Timezone**

Existe um local chamado  `eucla`. De que continente ele faz parte? Use o comando  `grep`  para descobrir.

`timedatectl list-timezones \| grep -i eucla`
ou
`grep -ri eucla /usr/share/zoneinfo`

Defina seu fuso horário atual para  `eucla`.

`timedatectl set-timezone 'Australia/Eucla'`
ou
`ln -s /usr/share/zoneinfo/Australia/Eucla /etc/localtime`

#### Protocolo NTP (Network Time Protocol)

Alguns desses termos aparecem nos comandos que usamos para rastrear o status do NTP em nossas máquinas:

- **Deslocamento (offset)**: Refere-se à diferença absoluta entre a hora do sistema e a hora NTP. Por exemplo, se o relógio do sistema marca 12:00:02 e o horário NTP é 11:59:58, o deslocamento entre os dois relógios é de quatro segundos.
- **Salto (step)**: Se o deslocamento de tempo entre o provedor NTP e um consumidor for maior que 128ms, o NTP executará uma única alteração significativa na hora do sistema, em vez de desacelerar ou acelerar o relógio do sistema. Isso é chamado de  _stepping_.
- **Ajuste gradativo (slew)**: Slew refere-se às alterações feitas na hora do sistema quando o deslocamento entre a hora do sistema e o NTP é menor que 128ms. Se esse for o caso, as alterações serão feitas gradualmente. Isso é conhecido como  _slewing_.
- **Relógio insano**: Se o deslocamento entre a hora do sistema e a hora NTP for maior que 17 minutos, o tempo do sistema é considerado  _insano_  e o daemon NTP não introduzirá nenhuma alteração no relógio do sistema. Será preciso tomar medidas especiais para trazer a hora do sistema até menos de 17 minutos da hora correta.
- **Escorregamento ou deslizamento (drift)**: O escorregamento se refere ao fenômeno em que dois relógios ficam fora de sincronia com o tempo. Essencialmente, se dois relógios são inicialmente sincronizados, mas vão ficando fora de sincronia com o passar do tempo, está ocorrendo um escorregamento do relógio.
- **Variação (jitter)**: A variação refere-se à quantidade de escorregamento desde a última vez em que um relógio foi consultado. Portanto, se a última sincronização com o NTP ocorreu há 17 minutos, e o deslocamento entre o provedor NTP e o consumidor é de 3 milissegundos, então 3 milissegundos é a variação.

Protocolo que usa a porta **123** via UDP (pode ser visto no arquivo `/etc/services`, que lista as portas)

Primeiro é preciso instalar os pacotes: `apt install ntp ntpdate`. Depois de instalador, pode verificar se o daemon do ntp está executando com o comando `ps axu | grep ntp`

O arquivo de configuração do NTP é `/etc/ntp.conf`. Dentro desse arquivo têm listado as pools com endereços NTP. Essas pools precedem da palavra reservada `pool` ou `server`.

- `ntpq -p`ou`--peers`: (é um utilitário para monitorar o status do NTP. Uma vez que o daemon NTP foi iniciado e configurado, usamos `ntpq` para verificar seu status) lista as pools (peers) com diversas estatísticas de cada pool ou server. Com `-n` não resolve os nomes, traz só os IPs. As colunas são:

- `remote`: nome do host do provedor NTP.
- `refid`:  ID de referência do provedor NTP.
- `st`: estrato do provedor.
- `when`: número de segundos desde a última consulta.
- `poll`: número de segundos entre as consultas.
- `reach`: ID de status para indicar se um servidor foi alcançado. As conexões bem-sucedidas aumentam este número em 1.
- `delay`: tempo em ms entre a consulta e a resposta do servidor.
- `offset`: tempo em ms entre a hora do sistema e a hora NTP.
- `jitter`: deslocamento em ms entre a hora do sistema e o NTP na última consulta.

`ntpq`  também inclui um modo interativo, que é acessado quando ele é executado sem opções ou argumentos. A opção  `?`  retorna uma lista de comandos reconhecidos pelo  `ntpq`.



- `ntpdate 3.pt.pool.ntp.org` (`apt install ntpsec-ntpdate -y`): vai até o NTP de Portugal e atualiza o horário (de acordo com NTP de Portugal)<br>
**O comando acima não altera para o horário de Portugal, na realidade vai pegar o horário de lá, e de acordo com as configurações de timezone do sistema, vai ajustar de acordo com o timezone.

- `ntpdate -q 3.pt.pool.ntp.org`: (`-q` ou `--query`): consulta se o servidor está funcionando.

Durante a configuração inicial, a hora do sistema e o NTP podem ser seriamente dessincronizados. Se o  _deslocamento_  entre o sistema e a hora NTP for maior que 17 minutos, o daemon NTP não fará alterações na hora do sistema. Neste caso, será necessária uma intervenção manual.

Primeiramente, se  `ntpd`  estiver rodando, será necessário  _interromper_  o serviço. Use  `systemctl stop ntpd`  para fazer isso.

Em seguida, use  `ntpdate pool.ntp.org`  para realizar uma sincronização inicial única, onde  `pool.ntp.org`  se refere ao endereço IP ou URL de um servidor NTP. Pode ser necessária mais de uma sincronização.

#### chrony e timedatect

- **chrony**: funciona melhor em ambientes instáveis. Precisa instalar: `apt install chrony`. Confirmar com `ps axu | grep chrony` e `systemctl status chrony`.

O arquivo de configuração ficam `/etc/chrony/chrony.conf`, podendo ainda usar igual ao ntp, com a palavra `pool` ou `server` para indicar o servidor a ser consultado

#### chronyc (é o cli do chrony)

- `chrony` é outra forma de implementar o NTP. Ele é instalado por padrão em alguns sistemas Linux, mas está disponível para download em todas as principais distribuições. 
- `chronyd` é o daemon chrony e `chronyc` é a interface de linha de comando
---
- `chronyc tracking`: fornece informações sobre o NTP e a hora do sistema que está configurado (vê um status geral)
Essa saída contém muitas informações, mais do que as que estão disponíveis em outras implementações.

- `Reference ID`: O ID de referência e o nome ao qual o computador está sincronizado no momento.
- `Stratum`: Número de passos até um computador com um relógio de referência anexado.
- `Ref time`: Esta é a hora UTC em que a última medição da fonte de referência foi feita.
- `System time`: Atraso do relógio do sistema do servidor sincronizado.
- `Last offset`: Deslocamento estimado da última atualização do relógio.
- `RMS offset`: Média de longo prazo do valor do deslocamento.
- `Frequency`: Esta é a taxa na qual o relógio do sistema estaria errado se o chronyd não o estivesse corrigindo. É fornecida em ppm (partes por milhão).
- `Residual freq`: Frequência residual indicando a diferença entre as medições da fonte de referência e a frequência atualmente sendo usada.
- `Skew`: Limite de erro estimado da frequência.
- `Root delay`: Total de atrasos do caminho de rede até o computador do estrato a partir do qual o computador está sendo sincronizado.
- `Leap status`: Este é o status de intercalação, que pode ter um dos seguintes valores: normal, inserir segundo, excluir segundo ou não sincronizado.
---

- `chronyc sources`: retorna informações sobre os servidores NTP usados para sincronizar a hora
- `chronyc sources -v`:  this command displays information about the current time sources that chronyd is accessing. Mostra se é um server (`^`), se é um peer (`=`) ou se se é o relógio local (`#`). Mostra também se está sincronizado (`*`), se está combinado (`+`) ou se está não está combinado (`-`)
- `chronyc activity`: mostra status das atividades, mostrando se está com status 200 OK, por exemplo<br>
*Se digitar só `chronyc`, entra no modo de cli, e os comandos anteriores podem ser digitados diretamente.
- `chrony ntpdate`: usado para ver informações detalhadas sobre a última atualização válida do NTP


A título de curiosidade, o **systemd** tem uma forma de sincronia por meio do serviço `systemd-timesyncd.service`, que pode conflitar com o ntp. Vide o comando `timedatectl`, que apresenta informações de `network time on` e `NTP synchronized`. Para evitar seria interessante usar o comando: `timedatectl set-ntp false`, assim, vai deixar como **no**, a opção `network time on`

O ntpd usa a porta **123** e o chrony usa a **323**.

NTP Pool recomendado: https://www.ntppool.org/en/

## 108.2 Sistema de Logs - Rsyslog

- **syslog**: derivado dos sistemas unix, bsd, e posteriormente nos sistemas linux.
- **rsyslog**: melhoramento do syslog (mais cobrado na LPI) e (mais veloz para processamento de log, e trouxe melhorias importantes como suporte a RELP - _Reliable Event Logging Protocol_: Protocolo confiável de registro de eventos em log, e estende a funcionalidade do protocolo syslog de maneira a assegurar a entrega de mensagens)
- **syslog-ng**: mesmo padrão do syslog, mas muda a implementação (ng = new generation)
- **systemd-journal**: recurso do systemd, para gerenciar logs (depois do rsyslog, é bem implementado)

>[!NOTE]
>
>Normalmente em `/var/log`. No entanto, alguns serviços cuidam de seus próprios logs (por exemplo, o servidor web Apache HTTPD ou o sistema de impressão CUPS). Da mesma forma, o kernel do Linux usa um buffer de anel na memória para armazenar suas mensagens de log.

O `rsyslog` usa um modelo cliente-servidor. O cliente e o servidor podem existir no mesmo host ou em máquinas diferentes. As mensagens são enviadas e recebidas em um formato específico e podem ser mantidas em servidores `rsyslog` centralizados em redes IP. O daemon do rsyslog —`rsyslogd`— trabalha junto com o `klogd` (que gerencia as mensagens do kernel). Nas próximas seções, discutiremos o `rsyslog` e sua infraestrutura de registro de eventos.

#### Tipos de log

Como os logs são dados  _variáveis_, costumam ser encontrados em  `/var/log`. Grosso modo, podem ser classificados em  _logs do sistema_  e  _logs de serviços ou programas_.

Vamos conhecer alguns logs do sistema e as informações que eles preservam:

- `/var/log/auth.log`: atividades relacionadas aos processos de autenticação: usuários registrados, informações de  `sudo`, cron jobs, tentativas de login malsucedidas etc.
- `/var/log/syslog`: um arquivo centralizado para praticamente todos os logs capturados pelo  `rsyslogd`. Por incluir muitas informações, os logs são distribuídos por outros arquivos de acordo com a configuração fornecida em  `/etc/rsyslog.conf`.
- `/var/log/debug`: informações de depuração dos programas.
- `/var/log/kern.log`: mensagens do kernel.
- `/var/log/messages`: mensagens informativas que não estão relacionadas ao kernel, mas a outros serviços. **É também o destino padrão do log do cliente remoto em uma implementação de servidor de log centralizado**.
- `/var/log/daemon.log`: informações relacionadas aos daemons ou serviços em execução em segundo plano.
- `/var/log/mail.log`: informações relacionadas ao servidor de email, por exemplo o postfix.
- `/var/log/Xorg.0.log`: informações relacionadas à placa de vídeo.
- `/var/run/utmp`  e  `/var/log/wtmp`:  Logins bem-sucedidos.
- `/var/log/btmp`: tentativas de login malsucedidas, por exemplo ataques de força bruta via ssh.
- `/var/log/faillog`: tentativas de autenticação malsucedidas.
- `/var/log/lastlog`: data e hora dos logins recentes do usuário.

Vejamos agora alguns exemplos de logs de serviço:

- `/var/log/cups/`: diretório para logs do  _Common Unix Printing System_. Geralmente inclui os seguintes arquivos de log padrão:  `error_log`,  `page_log`  e  `access_log`.
- `/var/log/apache2/`  or  `/var/log/httpd`: diretório para logs do  _Apache Web Server_. Geralmente inclui os seguintes arquivos de log padrão:  `access.log`,  `error_log`  e  `other_vhosts_access.log`.
- `/var/log/mysql`: diretório para logs do  _MySQL Relational Database Management System_. Geralmente inclui os seguintes arquivos de log padrão:  `error_log`,  `mysql.log`  e  `mysql-slow.log`.
- `/var/log/samba/`: diretório para logs do protocolo  _Session Message Block_  (SMB). Geralmente inclui os seguintes arquivos de log padrão:  `log.`,  `log.nmbd`  and  `log.smbd`.

>[!NOTE]
>
>O nome e o conteúdo exatos dos arquivos de log podem variar de acordo com as distribuições Linux. Existem também logs específicos para distribuições específicas como  `/var/log/dpkg.log`  (contendo informações relacionadas aos pacotes  `dpkg`) no Debian GNU/Linux e seus derivados.

- `/etc/rsyslog.conf`: arquivo principal de configuração do rsyslog. A primeira vista temos os módulos (`module(load="imuxsock")`), que nesse caso serve para comunicação do `rsyslog` com `systemd-journal`, eles se comunicam. (isso nos sistemas baseados em Debian, já em Redhat muito provável que o nome do módulo seja `imjournal` - ambos tem as mesmas funções)

As configurações serão obtidas em `/etc/rsyslog.d/*.conf`(informado na última linha de `/etc/rsyslog.conf`)

Conforme for instalando aplicações, muito provável que elas criarão uma entrada no arquivo `50-default.conf`:<br>
Nesse arquivo o padrão de entrada é: `facility.priority`(facility é quem está gerando o log, qual aplicação, e priority é o nível do log (em ordem ascendente/crescente):<br>
- `debug`: muitos registros, mas não tão importantes
- `info`
- `notice`
- `warn` ou `warning`
- `err` ou `error`
- `crit`: poucos registros, mas precisa ser olhado
- `alert`
- `emerg` ou `panic`
- `*`=todos, qualquer nível de debug<br>
Exemplo: `mail.err` (`mail` é a facility e `err` é a priority)<br>
Como é em ordem crescente, no caso do mail acima, tudo que vir acima de `err`, vai ser criado log (`crit`, `alert` e `emerg`)

Se quiser priorizar **apenas** `err`, use `mail.=err`

Depois da coluna de `facility.priority`, seria onde se destina o log, no caso pode ser um caminho (`/var/log/syslog`, por exemplo) ou pode ser para um determinado usuário (`lpi1,lpi2` - separado pode vírgula) ou ainda para todos os usuário, usando o asterisco (`*`). Há possibilidade de mandar remotamente para outro servidor, usando a notação `@10.0.0.1`, por exemplo (precisa ser um servidor de logs - útil quando tiver muitos servidores, e para descentralizar a geração de logs).

A segunda linha é bem interessante:<br>

    auth,authpriv.*				var/log/auth.log
    *.*;auth,authpriv.none		-/var/log/syslog

*O `-` em frente ao caminho, significa prioridade para performance, que nesse caso com o traço (evita gravações em disco excessivas), **não** precisa ser registrado imediatamente.

No caso, a 2ª linha indica que tudo (`*`), relacionado à facility e priority (`*.*` - qualquer facility e qualquer priority), exceto `;auth,authpriv.none`, irão gerar log em `/var/log/syslog` (em Redhat seria em `/var/log/messages`)

*Todas as configurações vistas serão as mesmas no **syslog**.

É possível criar sua própria configuração:<br>
Em `/etc/rsyslog.d` crie no final do arquivo `50-default.conf`<br>

    local0.warn			/var/log/teste-rsyslog.out

Reinicie o **rsyslog**: `systemctl restart rsyslogd`

Para gerar o log, pode-se utilizar a ferramenta `logger`, com o seguinte comando:<br>

    logger -p local0.err "Teste de Rsyslog"
    # -p = --priority

Depois de executar o comando, é para ter gerado o arquivo `teste-rsyslog.out` dentro de `/var/log`. Executando um `cat` no arquivo criado, é possível verificar a mensagem de log que acabou de ser realizada.

Lembrando que o `rsyslog` é a evolução do `syslog`, caso queira usar o `syslog`, instalar o pacote `inetutils-syslog`. O arquivo de configuração do syslog fica geralmente em `/etc/syslog.conf` (`syslog` não cai no exame, apenas `rsyslog`)

Para leitura do log, usar `less` ou `more`. Se tiver compactado, usar `zless` ou `zmore`. Pode usar também `tail` ou `head`. Para filtrar, usar o `grep`:<br>

       # grep "dhcpclient" /var/log/syslog
        Sep 13 11:58:48 debian dhclient[448]: DHCPREQUEST of 192.168.1.4 on enp0s3 to 192.168.1.1 port 67
    Sep 13 11:58:49 debian dhclient[448]: DHCPACK of 192.168.1.4 from 192.168.1.1
    Sep 13 11:58:49 debian dhclient[448]: bound to 192.168.1.4 -- renewal in 1368 seconds.

Como você deve ter notado, a saída é impressa no seguinte formato:

-   Carimbo de data/hora
-   Nome do host a partir do qual a mensagem se originou
-   Nome do programa/serviço que gerou a mensagem
-   O PID do programa que gerou a mensagem
-   Descrição da ação que ocorreu

Existem alguns exemplos em que os registros não são em forma de texto, mas arquivos binários e — conseqüentemente — você deverá usar comandos especiais para analisá-los:

`/var/log/wtmp`

Use  `who`  (ou  `w`):

    root@debian:~# **who**
    root    pts/0        2020-09-14 13:05 (192.168.1.75)
    root    pts/1        2020-09-14 13:43 (192.168.1.75)

`/var/log/btmp`

Use  `utmpdump`  ou  `last -f`:

    root@debian:~# **utmpdump /var/log/btmp**
    Utmp dump of /var/log/btmp
    [6] [01287] [    ] [dave     ] [ssh:notty   ] [192.168.1.75        ] [192.168.1.75   ] [2019-09-07T19:33:32,000000+0000]

`/var/log/faillog`

Use  `faillog`:

    root@debian:~# **faillog -a | less**
    Login       Failures Maximum Latest                   On
    
    root            0        0   01/01/70 01:00:00 +0100
    daemon          0        0   01/01/70 01:00:00 +0100
    bin             0        0   01/01/70 01:00:00 +0100
    sys             0        0   01/01/70 01:00:00 +0100
    sync            0        0   01/01/70 01:00:00 +0100
    games           0        0   01/01/70 01:00:00 +0100
    man             0        0   01/01/70 01:00:00 +0100
    lp              0        0   01/01/70 01:00:00 +0100
    mail            0        0   01/01/70 01:00:00 +0100
    (...)

`/var/log/lastlog`

Use  `lastlog`:

    root@debian:~# **lastlog | less**
    Username         Port     From             Latest
    root                                       **Never logged in**
    daemon                                     **Never logged in**
    bin                                        **Never logged in**
    sys                                        **Never logged in**
    (...)
    sync                                       **Never logged in**
    avahi                                      **Never logged in**
    colord                                     **Never logged in**
    saned                                      **Never logged in**
    hplip                                      **Never logged in**
    carol            pts/1    192.168.1.75     Sat Sep 14 13:43:06 +0200 2019
    dave             pts/3    192.168.1.75     Mon Sep  2 14:22:08 +0200 2019

>[!NOTE]
>
> Também existem ferramentas gráficas para ler arquivos de log, como  `gnome-logs`  e  `KSystemLog`.

#### Entradas manuais no log do sistema:  `logger`

O comando  `logger`  é prático para scripts do shell ou para testes. O  `logger`  anexa todas as as mensagens recebidas a  `/var/log/syslog`  (ou a  `/var/log/messages`  quando o registro for feito em um servidor de log remoto centralizado, como veremos mais adiante):

carol@debian:~$ **logger this comment goes into "/var/log/syslog"**

Para imprimir a última linha de  `/var/log/syslog`, use o comando  `tail`  com a opção  `-1`:

root@debian:~# **tail -1 /var/log/syslog**
Sep 17 17:55:33 debian carol: this comment goes into /var/log/syslog

#### Como as mensagens são transformadas em logs

O processo a seguir ilustra como uma mensagem é gravada em um arquivo de log:

1.  Aplicativos, serviços e o kernel gravam mensagens em arquivos especiais (sockets e buffers de memória), por exemplo,  `/dev/log`  ou  `/dev/kmsg`.
2.  O  `rsyslogd`  obtém as informações dos sockets ou buffers de memória.
3.  Dependendo das regras encontradas em  `/etc/rsyslog.conf`  e/ou dos arquivos em  `/etc/ryslog.d/`, o  `rsyslogd`  move as informações para o arquivo de log correspondente (normalmente encontrado em  `/var/log`).
    

>[!NOTE]
>
>Um socket é um arquivo especial usado para transferir informações entre diferentes processos. Para listar todos os sockets em seu sistema, você pode usar o comando  `systemctl list-sockets --all`.

### logrotate (rotacionamento de logs)

Imagine o cenário que os logs começam a crescer com o passar do tempo, ao ponto de encher o disco. Aí que entra o rotacionamento de logs.

Um exemplo é executar o comando: `# ls -ltr /var/log/syslog*`

    -rw-r----- 1 syslog adm  130685 Nov 10 00:00 /var/log/syslog.3.gz
    -rw-r----- 1 syslog adm   88855 Nov 17 00:00 /var/log/syslog.2.gz
    -rw-r----- 1 syslog adm 2870981 Nov 24 00:00 /var/log/syslog.1
    -rw-r----- 1 syslog adm 1246647 Nov 25 08:19 /var/log/syslog

É possível perceber que o log do `syslog` vai rotacionando, de `syslog` vira `syslog.1`, depois é compactado, e o último é excluído, tudo isso configurável no `logrotate`.

- `/etc/logrotate.conf`: arquivo de configuração do logrotate. Aqui é uma configuração mais geral e genérica, e que incluir o diretório `/etc/logrotate.d`, que possui as configurações separadamente.

O **logrotate** não é um **daemon** que fica rodando, na realidade é executado pelo crontab (geralmente em `/etc/cron.daily`).

Alguns valores do logrotate nos arquivos de configuração:
- `rotate 4`: Preserva 4 semanas de logs.
- `weekly`: Rotaciona arquivos de log semanalmente.
- `missingok`: Não emite uma mensagem de erro se o arquivo de log estiver ausente; simplesmente passa para o seguinte.
- `notifempty`: Não rotaciona o log se estiver vazio.
- `compress`: Compacta arquivos de log com o  `gzip`  (padrão).
- `delaycompress`: Adia a compactação do arquivo de log anterior para o próximo ciclo de rotação (válido apenas quando usado em combinação com compress). Útil quando um programa não pode ser instruído a fechar seu arquivo de log e, portanto, pode continuar gravando no arquivo de log anterior por algum tempo.
- `sharedscripts`: Relacionado aos scripts  _prerotate_  e  _postrotate_. Para evitar que um script seja executado várias vezes, esse comando executa os scripts apenas uma vez, independentemente de quantos arquivos de log correspondem a um determinado padrão (por exemplo,  `/var/log/mail/*`). Porém, os scripts não serão executados se nenhum dos logs no padrão requerir a rotação. Além disso, se os scripts forem encerrados com erros, as ações restantes não serão executadas em nenhum log.
- `postrotate`: Indica o início de um script  _postrotate_.
- `invoke-rc.d rsyslog rotate > /dev/null`: Usa  `/bin/sh`  para executar  `invoke-rc.d rsyslog rotate > /dev/null`  depois de rotacionar os logs.
- `endscript`: Indica o fim do script  _postrotate_.

>[!NOTE]
>
>Para uma lista completa de diretrizes e explicações, consulte a página de manual de `logrotate.conf`.

#### O buffer de anel do kernel

Uma vez que o kernel gera diversas mensagens antes de  `rsyslogd`  se tornar disponível na inicialização, torna-se necessário um mecanismo para registrar essas mensagens. É aqui que o  _buffer de anel do kernel_  entra em ação. Trata-se de uma estrutura de dados de tamanho fixo e — portanto — à medida que novas mensagens são gravadas, as mais antigas vão desaparecendo.

O comando  `dmesg`  imprime o buffer de anel do kernel. Devido ao tamanho do buffer, este comando é normalmente usado em combinação com o utilitário de filtragem de texto  `grep`. Por exemplo, para pesquisar mensagens relacionadas a dispositivos Universal Serial Bus:

    root@debian:~# dmesg | grep "usb"
    [    1.241182] usbcore: registered new interface driver usbfs
    [    1.241188] usbcore: registered new interface driver hub
    [    1.250968] usbcore: registered new device driver usb
    [    1.339754] usb usb1: New USB device found, idVendor=1d6b, idProduct=0001, bcdDevice= 4.19
    [    1.339756] usb usb1: New USB device strings: Mfr=3, Product=2, SerialNumber=1
    (...)

#### systemd-journal

Monitora as entradas do sistema, gerando registro de logs, em uma base de dados interna (trabalha diferente do **rsyslog**). Logo são 2 tipos de registros, uma pelo **rsyslog** e outra pelo **systemd-journal**.

- `/etc/systemd/journald.conf`: arquivo de configuração do systemd-journal

É muito recomendado olhar o `man journald.conf` para aprofundar nas opções que ele oferece.

Os logs ficam em `/var/log/journal`, no entanto é criado um arquivo de base de dados interna, que não é possível ler com `cat` ou `less`.

Para realizar a leitura, é preciso usar o comando `journalctl`. Ele sozinho sendo executado, mostra todos os dados que já foram para o log do **journal** (muitos dados, que precisam ser filtrados) imprimirá todo o diário em ordem cronológica (com as entradas mais antigas listadas primeiro - se usar `-r` imprime na ordem reversa). Olhar `journalctl --help` para ver os filtros

- `journalctl -n10`: mostra as 10 últimas linhas
- `journalctl -f`: igual ao `tail -f`
- `journalctl -b` ou `--boot`: mensagens de log relacionadas ao boot do sistema
- `journalctl _TRANSPORT=kernel`: mostra tudo que tiver origem do kernel
- `journalctl _UID=0`: tudo que for referente ao usuário root (id=0)
- `journalctl --since "today"` ( `-S` ou `--since` ): todos os logs que aconteceram hoje
- `journalctl --since "1 hour ago"`: todos os logs que aconteceram há 1 dia
- `journalctl --since "2024-11-20" --until "2024-11-21"` (`-U` ou `--until`): todos os logs que aconteceram entre os dias 20 e 21 de novembro e 2024.
- `journalctl --verify`: verifica os logs, se não há nada corrompido.
- `journalctl --sync`: grava em disco tudo que ainda está em memória.

Mais algumas opções de palavras-chave:
- `yesterday`: A partir de meia-noite do dia anterior ao dia atual.
- `today`: A partir de meia-noite do dia atual.
- `tomorrow`: A partir de meia-noite do dia seguinte ao dia atual.
- `now`: A hora atual.

Exemplo: Vamos ver todas as mensagens desde a meia-noite passada até hoje às 21:00:

    root@debian:~# journalctl --since "today" --until "21:00:00"

Para ver as mensagens do diário relacionadas a um **executável** específico, a seguinte sintaxe é usada:  `journalctl  _/path/to/executable_`:

    root@debian:~# **journalctl /usr/sbin/sshd**
    -- Logs begin at Sat 2019-10-12 20:45:29 CEST, end at Sat 2019-10-12 21:54:49 CEST. --
    Oct 12 21:16:28 debian sshd[1569]: Accepted password for carol from 192.168.1.65 port 34050 ssh2

Para ver da mesma forma, mas com **unidades** (units), usa o `-u`:

    root@debian:~# **journalctl -u ssh.service**
    -- Logs begin at Sun 2019-10-13 10:50:59 CEST, end at Sun 2019-10-13 12:22:59 CEST. --
    Oct 13 10:51:00 debian systemd[1]: Starting OpenBSD Secure Shell server...

>[!NOTE]
>
>Para imprimir todas as unidades carregadas e ativas, use `systemctl list-units`; para ver todos os arquivos de unidade instalados, use `systemctl list-unit-files`.


#### Para navegar pela saída do diário, usamos:

-   Teclas `PageUp`, `PageDown` e as setinhas para nos mover para cima, para baixo, a direita e a esquerda.
-   `>`  para ir ao final da saída.
-   `<`  para ir ao início da saída.
    
Você pode pesquisar strings para a frente e para trás a partir de sua posição atual:
-   **Busca para a frente**: Pressione  `/`  e insira a string a pesquisar, depois dê Enter.
-   **Busca para trás**: Pressione  `?`  e insira a string a pesquisar, depois dê Enter.
    
Para navegar pelas correspondências nas pesquisas, use  `N`  para ir para a próxima ocorrência e  `Shift+N`  para ir para a anterior.

#### ver o tamanho dos logs

Supõe que esteja em `/var/log/`, execute `du -sh .`

#### túnel de dados (socket)

Como já vimos em `/etc/rsyslog.conf`, tem o uso de módulos, no caso o `imuxsock`, que vai servir como um túnel de dados entre o **journalctl** e o **rsyslog**.

Em `systemctl status rsyslog`, podemos obter o arquivo que carrega o **rsyslog**, no caso `rsyslog.service`. E se executar um `cat` nele (`cat /lib/systemd/system/rsyslog.service`) é possível ver ele requer (no campo **Requires**) o socket `syslog.socket` (que é uma unit do systemd - podendo ser verificada com o comando `systemctl status syslog.socket` - aqui é possível ver onde ele foi carregado).

Dando um cat onde está o socket visto anteriormente, `cat /lib/systemd/system/syslog.socket`, no campo **ListenDatagram**, mostra o que o syslog está ouvindo, que no caso é `/run/systemd/journal/syslog`. Nesse caso o rsyslog usa esse socket, por conta do módulo `imuxsock` que ouve  o **systemd journal**.

Para confirmar o socket, liste os arquivos em `/run/systemd/journal` (os arquivos **socket** e **stdout**, que começam com s nas permissões)

    cd /run/systemd/journal/
    root@PC:/run/systemd/journal# ls -l
    total 8
    srw-rw-rw- 1 root root    0 Nov  8 16:41 dev-log
    -rw-r--r-- 1 root root    0 Nov  8 16:41 flushed
    srw------- 1 root root    0 Nov  8 16:41 io.systemd.journal
    -rw-r--r-- 1 root root    8 Nov  8 16:41 kernel-seqnum
    -rw-r--r-- 1 root root   24 Nov  8 16:41 seqnum
    srw-rw-rw- 1 root root    0 Nov  8 16:41 socket
    srw-rw-rw- 1 root root    0 Nov  8 16:41 stdout
    drwxr-xr-x 2 root root 1160 Nov 25 10:32 streams
    srw-rw-rw- 1 root root    0 Nov  8 16:41 syslog


#### systemd-cat (parecido com logger)

Execute o `journalctl -f` para ficar logando as entradas (igual ao `tail -f`) em um terminal, e em outro use o `systemd-cat`, que vai mandar o output do comando diretamente para o **journal**.

Ex. `systemd-cat ls -ls rsyslog.conf`: manda a saída do comando `ls` diretamente no journal (onde deixou rodando o comando `journalctl -f`)

Pode usar também dessa forma: `echo "Mensagem de teste" | systemd-cat`

#### ver o tamanho dos logs journal

Supõe que esteja em `/var/log/journal`, execute `journalctl --disk-usage`

#### limpar logs

- `journalctl --vacuum-size=200M`: limpa 200 MB os arquivos de logs (archived apenas, não os ativos). Pode usar `--vacuum-time` e `--vacuum-files`

Voltar depois nesse tópico e no de mail e impressoras


## 109.1 Fundamentos dos protocolos de internet

- **TCP/IP**: Conjunto de Protocolos de comunicação entre computadores
- Engloba os protocolos IP, TCP, UDP, ICMP, entre outras

- **IP**: é o protocolo responsável pelo endereçamento lógico. Cada dispositivo em uma rede deve possuir um endereço IP único

- O endereço IP (IPv4) é formado por 32 bits, separados em 4 grupos de 8 bits, representados de maneira decimal.
	- 192.168.10.20 = 10000000.10101000.00001010.00010100
	- 0.0.0.0 = 00000000.00000000.00000000.0000000
	- 255.255.255.255 = 11111111.11111111.11111111.11111111

#### Classes

| Classe | 1º Octeto | Range |
| -------- | ----- | ----------- |
| A | 1-126 | 1.0.0.0 - 126.255.255.255 |
| B | 128-191 | 128.0.0.0 - 191.255.255.255 |
| C | 192-223 | 192.0.0.0 - 223.255.255.255 |

Exemplos:
- Classe A - 10.25.13.10 - 110.14.20.12
- Classe B - 141.150.200.1 / 172.168.1.1
- Classe C - 192.168.20.30 / 200.178.12.242

#### Endereços: Privado vs Público

| Classe | 1º Octeto | Range | IPs Privados |
| -------- | ----- | ---------- | ------------ |
| A | 1-126 | 1.0.0.0 - 126.255.255.255 | 10.0.0.0 - 10.255.255.255 |
| B | 128-191 | 128.0.0.0 - 191.255.255.255 | 172.16.0.0 - 172.31.255.255 |
| C | 192-223 | 192.0.0.0 - 223.255.255.255 | 192.168.0.0 - 192.168.255.255 |

#### Máscara

- utilizada em conjunto com o endereço IP para determinar a segmentação de rede
- também composta de 32 bits em 4 grupos de 8:
	- 255.0.0.0 = 11111111.00000000.00000000.00000000 = /8
	- 255.255.0.0 = 11111111.11111111.00000000.00000000 = /16
	- 255.255.255.0 = 11111111.11111111.11111111.00000000 = /24
	- 255.255.255.255 = 11111111.11111111.11111111.11111111 = /32
- 1s identificam a rede
- 0s identificam os hosts

| Classe | 1º Octeto | Range | Máscara Padrão |
| -------- | ----- | ---------- | ------------ |
| A | 1-126 | 1.0.0.0 - 126.255.255.255 | 255.0.0.0 /8 |
| B | 128-191 | 128.0.0.0 - 191.255.255.255 | 255.255.0.0 /16 |
| C | 192-223 | 192.0.0.0 - 223.255.255.255 | 255.255.255.0 /24 |

Exemplos:
- Classe A - `110`.14.20.12
- Classe B - `172.168`.1.1
- Classe C - `200.178.12`.242

#### sub-redes

| Máscara | CIDR | Hosts | Sub-rede |
| -------- | ----- | ---------- | ------------ |
| 255.255.255.0 | 24 | 254 | 1 |
| 255.255.255.128 | 25 | 126 | 2 |
| 255.255.255.192 | 26 | 62 | 4 |
| 255.255.255.224 | 27 | 30 | 8 |
| 255.255.255.240 | 28 | 14 | 16 |
| 255.255.255.248 | 29 | 6 | 32 |
| 255.255.255.252 | 30 | 2 | 64 |

#### Rota padrão (gateway)

Duas sub-redes distintas, caso precisem se comunicar, terá que ter um gateway para realizar o intermédio entre essas redes (precisa de uma rota padrão).

#### IPv6

- IPv6 é um novo padrão de endereçamento IP
- cada endereço possui 128 bits, divididos em 8 grupos de 16 bits, representados por 4 números hexadecimais
- Exemplo: `2001:0db8:85a3:08d3:1319:8a2e:0370:7344`

#### abreviações

- 2001:0db8:85a3`:0000:0000:0000:0000:`7344
- 2001:0db8:85a3`:0:0:0:0:`7344
- 2001:0db8:85a3`::`7344
<br>
- 2001:0db8:85a3`:0000:0000:`1319`:0000:`7344
- 2001:0db8:85a3`:0:0:`1319`:0:`7344
- 2001:0db8:85a3`::`1319`:0:`7344

<br>

- **Unicast**: identifica uma única interface
- **Multicast**: identifica um conjunto de interfaces. Um pacote é enviado para cada interface
- **Anycast**: identifica um conjunto de interfaces. Um pacote e enviado para'uma única interface, normalmente a mais próxima

#### Diferenças entre IPv4 e IPv6

Além do endereço, diversas outras diferenças podem ser apontadas entre as versões 4 e 6 do IP. Eis algumas delas:
-   As portas de serviço seguem os mesmos padrões e protocolos (TCP, UDP); a diferença está apenas na representação do IP e no conjunto de portas. No IPv6, o endereço IP deve ser protegido com  `[]`  (colchetes):
    
   - IPv4:  `200.216.10.15:443`
   - IPv6:  `[2001:0db8:85a3:08d3:1319:8a2e:0370:7344]:443`
    
-   O IPv6 não implementa o recurso de broadcast (transmissão) da mesma maneira que o IPv4. Porém, o mesmo resultado pode ser obtido enviando-se o pacote para o endereço  `ff02::1`, que alcança todos os hosts da rede local — semelhante a usar  `224.0.0.1`  no IPv4 para uma transmissão multicast.
-   Por meio do recurso SLAAC (_Stateless Address Autoconfiguration_), os hosts IPv6 podem se autoconfigurar.
-   O campo TTL (_Time to Live_) do IPv4 foi substituído pelo “Hop Limit” (limite de saltos) no cabeçalho do IPv6.
-   Todas as interfaces IPv6 têm um endereço local, denominado endereço de link local, prefixado com  `fe80::/10`.
-   O IPv6 implementa o  _Neighbor Discovery Protocol_  (NDP), semelhante ao ARP usado pelo IPv4, mas com muito mais funcionalidades.

Que tipo de informação o Neighbour Discovery Protocol (NDP) pode descobrir?

O NDP é capaz de obter diversas informações da rede, incluindo outros nós, endereços duplicados, rotas, servidores DNS, gateways, etc.

#### TCP

- **TCP**: Transmission Control Protocol: protocolo de transporte orientado a conexões. Garante a entrega dos pacotes na ordem correta. O pacote é retransmitido em caso de erros na rede. Usado por serviços como FTP, SMTP, HTTP, POP3, IMAP, SSH, etc

#### UDP

- **UDP**: User Datagram Protocol: protocolo de transporte não  orientado a conexões. Não oferece garantia de entrega dos pacotes, assim tem melhor performance na transmissão de dados. Usado por serviços como DHCP, DNS, NFS e NTP.

#### ICMP

- **ICMP**: Internet Control Message Protocol: utilizado para transmitir informações de controle entre os elementos de rede, por exemplo:
	- controle de volume de tráfego
	- detecção de destinos nao atingíveis
	- redirecionamento de rotas
	- verificação de status de hosts remotos
- utilizado em comandos como o `ping` e `traceroute`

#### Portas e Serviços

- cada serviço é provido por meio de uma porta
- portas possuem 16 bits, ou seja, um máximo de 65535
- as primeiras 1024 portas são reservadas a serviços conhecidos (_portas privilegiadas_, por ter acesso de root ao sistema)
- as demais são utilizadas para serviços específicos ou para a porta de socket (_portas não privilegiadas_ ou portas de socket) de uma conexão (quando um cliente se conecta a um servidor http, o servidor normalmente usa a porta 80, já no cliente é configurado um socket/porta aleatório, como 42222, por exemplo. Essa porta é chamada de socket)
- toda conexão é composta de IP de **destino** e **origem**, assim como a porta de **destino** e **origem** (socket)
- As portas usadas por cada tipo de serviço são padronizadas e controladas pela IANA (_Internet Assigned Numbers Authority_). Assim, em qualquer sistema, a porta 22 é usada pelo serviço SSH, a porta 80 pelo serviço HTTP e assim por diante.
- Em um sistema Linux, as portas de serviço padrão são listadas no arquivo `/etc/services`.

<br>

Exemplo:
- `200.20.125.60`:25 (serviço SMTP)
- `172.168.8.10`:80 (serviço HTTP)
- `[2001:0db8:85a3:0000:0000:1319:0000:7344]`:80

| Porta(s) | Serviço |
| -------- | ----- |
| 20 e 21 | FTP |
| 22 | SSH |
| 23 | Telnet |
| 25 e 465 | SMTP e SMTPs |
| 53 | DNS |
| 67 e 68 | DHCP |
| 80 e 443 | HTTP e HTTPS |
| 110 e 995 | POP3 e POP3S |
| 123 | NTP |
| 139 | Netbios |
| 143 e 993 | IMAP e IMAPS |
| 161 e 162 | SNMP |
| 389 e 636 | LDAP e LDAPS |


## 109.2 Configuração de rede persistente

- `/etc/hostname`: define o nome da máquina (assim como digitar `hostname` vai mostrar o nome da máquina)
- `hostnamectl`: mostra mais informações do host
- `hostnamectl set-hostname novo_nome`: altera o hostname da máquina (altera também lá no `/etc/hostname`)

Uma configuração funcional de TCP/IP é apenas o primeiro passo para a usabilidade total da rede. Além de ser capaz de distinguir os nós da rede por seus números IP, o sistema deve poder identificá-los com nomes mais facilmente compreensíveis por seres humanos.

O nome pelo qual o sistema se identifica é personalizável e é aconselhável fazê-lo, mesmo se a máquina não for destinada a se conectar a uma rede. O nome local geralmente corresponde ao nome da rede da máquina, mas nem sempre. Se o arquivo  `/etc/hostname`  existir, o sistema operacional usará o conteúdo da primeira linha como nome local, que a partir daí é chamado simplesmente de  _nome do host_  (hostname, em inglês). As linhas que começam com  `#`  dentro de  `/etc/hostname`  são ignoradas.

O arquivo  `/etc/hostname`  pode ser editado diretamente, mas o nome de host da máquina também pode ser definido com o comando  `hostnamectl`. Quando fornecido com o subcomando  `set-hostname`, o comando  `hostnamectl`  pega o nome dado como argumento e o escreve em  `/etc/hostname`:

    # hostnamectl set-hostname storage
    # cat /etc/hostname
    storage

O nome de host (ou “hospedeiro”) definido em  `/etc/hostname`  é o nome  _estático_, ou seja, o nome usado para inicializar o nome de host do sistema na inicialização. O nome de host estático pode ser uma string com até 64 caracteres de comprimento. No entanto, é recomendado que ele consista apenas em caracteres ASCII minúsculos e sem espaços ou pontos. Também é aconselhável limitá-lo ao formato permitido para rótulos de nomes de domínio DNS, embora esse não seja um requisito estrito.

O comando  `hostnamectl`  pode definir dois outros tipos de nomes de host além do nome de host estático:

- **Hostname pretty**: Ao contrário do nome de host estático, o nome de host pretty pode incluir todos os tipos de caracteres especiais. Ele pode ser usado para definir um nome mais descritivo para a máquina, por exemplo “Armazenamento compartilhado da LAN”:
```
    # hostnamectl --pretty set-hostname "LAN Shared Storage"
```
- **Hostname transiente**: Usado quando o nome de host estático não está definido ou quando ele é o nome  `localhost`  padrão. O nome de host transiente é normalmente definido junto com outras configurações automáticas, mas também pode ser modificado com o comando  `hostnamectl`, por exemplo:
```
# hostnamectl --transient set-hostname generic-host
```
Se nem a opção  `--pretty`  nem  `--transient`  forem usadas, os três tipos de nomes de host serão configurados com o nome fornecido. Para definir o nome de host estático, mas não os nomes pretty e transiente, usa-se a opção  `--static`. Em todos os casos, somente o nome de host estático é armazenado no arquivo  `/etc/hostname`.

- `/etc/hosts`: arquivo que cria uma relação do IP e nome da máquina (igual o que há no windows)
Ex. de entrada no `/etc/hosts`:
```
192.168.0.100		minhamaquina		minhamaquina.dominio.com.br
```
*O terceiro campo é opcional. Quando for no terminal e der um ping em `minhamaquina`, vai pingar no IP associado:

    $ ping minhamaquina
    PING minhamaquina (192.168.0.100) 56(84) bytes of data.
    64 bytes from minhamaquina (192.168.0.100): icmp_seq=1 ttl=64 time=0.257 ms
    64 bytes from minhamaquina (192.168.0.100): icmp_seq=2 ttl=64 time=0.381 ms

- `/etc/nsswitch.conf` (Name Service Switch): disponibiliza diversas informações, de onde buscar as informações de `passwd`, `group`, `shadow`, etc. Geralmente é indicado como `compat` (compatibilidade), mas poderia, por exemplo, indicar para buscar no `ldap`.

No entanto para LPI1, é importante saber a parte de `hosts` e `networks`:
- `hosts`: vai estar como `files`, o que indica para buscar primeiramente aos arquivos do sistema, como o `/etc/hosts` (o que faz relação IP e nome), e caso não encontre, vai buscar em algum DNS configurado (no arquivo vai estar o `mdns4_minimal`, que é um serviço de DNS interno - `multicast dns`).

Exercício interessante:<br>
Qual entrada de  `/etc/hosts`  associa os nomes  `firewall`  e  `router`  com o IP  `10.8.0.1`?<br>
Resposta: A linha  `10.8.0.1 firewall router`.

- `/etc/networks`: mesma relação com o /etc/hosts, mas esse seria para redes.
```
rede-local		192.168.1.0 #nomeia essa rede como rede-local
```

- `/etc/resolv.conf`: determinar qual servidor DNS será utilizado pelo sistema. Indica o `nameserver` (apenas um servidor de nomes é necessário, mas é possível informar até **três** deles - os suplementares serão usados como reserva - se nenhuma entrada de servidor de nomes estiver presente, o comportamento padrão é usar o servidor de nomes da máquina local), que é basicamente o servidor DNS que irá usar. (mais detalhes no tópico **109.3**)
Importante dizer que esse arquivo é dinamicamente gerenciado/escrito/gerado pelo `systemd-resolved(8)`, que basicamente é um link que vem do `/etc/resolv.conf`. Isso significa que poderia ter seu próprio arquivo parecido com `resolv.conf` apontando para o `resolv` do `systemd` (para ambiente de produção, por exemplo).
```
ls -l /etc/resolv.conf 
lrwxrwxrwx 1 root root 39 Nov  8 16:20 /etc/resolv.conf -> ../run/systemd/resolve/stub-resolv.conf
```

#### NetworkManager

De modo geral, a configuração costuma ser feita por arquivos, sendo eles:
- No padrão Debian, geralmente fica em `/etc/network/interfaces`.
- Já no Red Hat, fica em `/etc/sysconfig/network-scripts`

No entanto as distros mais novas tem tendenciado utilizar o **NetworkManager**(o que é exigido na LPI - em tese não é cobrado os scripts listados acima, apenas na LPI2)

Existem aplicativos cliente do NetworkManager para a linha de comando e para o ambiente gráfico. No caso deste último, o aplicativo cliente é incluído como um acessório do ambiente de desktop (com nomes como _nm-tray_, _network-manager-gnome_, _nm-applet_ ou _plasma-nm_) e geralmente fica acessível por meio de um ícone indicador no canto da barra da área de trabalho ou no utilitário de configuração do sistema

Os arquivos de configuração ficam em `/etc/NetworkManager`. Dentro há algumas pastas, sendo:
- `system-connections`: onde é salvo as redes conhecidas pelo NetworkManager, configuração de perfis, redes wifi, etc.

Para verificar se o serviço do NetworkManager está executando: `systemctl status NetworkManager`. O NetworkManager foi desenvolvido originalmente pela Red Hat, sendo atualmente um projeto GNOME.

É possível gerir o NetworkManager por CLI, utilizando o `nmcli`.

As categorias chamadas  _objetos_ são:
- `general`: Status e operações gerais do NetworkManager
- `networking`: Controle geral de rede.
- `radio`: Controles de rádio do NetworkManager.
- `connection`: Conexões do NetworkManager.
- `device`: Dispositivos gerenciados pelo NetworkManager.
- `agent`: Agente secreto ou agente polkit do NetworkManager.
- `monitor`: Monitora as mudanças do NetworkManager.


- `nmcli`: lista as interfaces detectadas pelo NetworkManager e os servidores DNS configurados no computador
- `nmcli device` (ou `nmcli d` ou `nmcli dev`): resumo das interfaces
- `nmcli device show`: mostra mais detalhes das interfaces (mostra IP, máscara formato CIDR, rota padrão e DNS)
- `nmcli device show enp2s0`: mostra mais detalhes das interfaces (mostra IP, máscara formato CIDR, rota padrão e DNS) da interface selecionada
- `nmcli --help`: mostra as diversas outras opções do `nmcli`
- `nmcli general status`: mostra as informações/status na conexão no momento
- `nmcli networking`: se a rede cabeada está habilitada/funcionando
- `nmcli radio`: se o wifi está habilitado/funcionando
- `nmcli connection`: enquanto device mostra informações referentes ao dispositivo em si, connections mostra informações da(s) conexão(ões), como o tipo (ethernet e wifi)

Supondo que a saída do comando `nmcli connection` seja (O comando `status` é usado por padrão se nenhum argumento de comando estiver presente, de modo que o comando `nmcli general` é interpretado, na verdade, como `nmcli general status`): 

    DEVICE		UUID		TYPE			STATE			CONNECTION
    enp0s2		779a5...	ethernet		connected		Wired connection 1	
    enp0s4		45f23...	ethernet		connected		Wired connection 2

Para baixar a `Wired connection 2`, use: `nmcli con down "Wired connection 2"`

- `nmcli connection add type ethernet con-name nome_conexao ifname enp2s0 ip4 192.168.0.20/24 gw4 192.168.0.1`: cria uma nova conexao chamada `nome_conexao`, na placa `enp2s0`, com IP `192.168.0.20` máscara `255.255.255.0` e gateway `192.168.0.1`.
- `nmcli connection up nome_conexao`: ativa a rede criada no comando acima.
- `nmcli connection del nome_conexao`: remove a rede `nome_conexao`

Se voltarmos em `/etc/NetworkManager`, em `system-connections`, foi criado um arquivo `nome_conexao`. Mais opções em `nmcli connection --help`

#### NetworkManager - redes sem fio

- `nmcli device wifi list`: mostra as redes disponíveis (SSIDs). A com asterisco (`*`) é a que está em uso.
- `nmcli device wifi rescan`: reescaeia e coloca uma flag se um novo Wi-Fi scan deve ser engatilhado. Depois rode o `list` novamente.
- `nmcli radio wifi on/off`: habilita/desabilita o rádio wifi. (se trocar `radio` por `networking`, habilita/desabilita rede cabeada)
- `nmcli device wifi connect NOME_SSID password 123456`: conecta na rede `NOME_SSID` com a senha `123456` (obviamente não usar essa senha em produção). Confirme se conector com o asterisco mostrado no `nmcli device wifi list`
- Se a rede wi-fi esconde seu nome SSID, o  `nmcli`  ainda assim pode se conectar a ela com os argumentos extras  `hidden yes`:
```
$ nmcli device wifi connect Hypnotoad password MyPassword hidden yes
```
- Se o sistema tiver mais de um adaptador wi-fi, indicamos o que deve ser usado com  `ifname`. Por exemplo, para se conectar usando o adaptador de nome  `wlo1`:
```
$ nmcli device wifi connect Hypnotoad password MyPassword ifname wlo1
```

>[!NOTE]
>
>`nmcli device wifi connect`, apenas o SSID é obrigatório, a senha pode ser omitida caso a conexão já tenha sido criada anteriormente. Se o comando for executado dentro de um emulador de terminal no ambiente gráfico, aparecerá uma caixa de diálogo solicitando a senha da rede. Quando executado em um console de texto, a senha pode ser fornecida junto com os outros argumentos, como no comando acima

- `nmcli device disconnect wlo1`: desconectar da rede conectada anteriormente (não chega a desligar a interface - tanto que `nmcli device list` funciona).

Se houver um adaptador sem fio disponível, mas ele não estiver sendo usado, ele pode ser desligado para economizar energia. Desta vez, o objeto  _radio_  deve ser passado para  `nmcli`:

    $ nmcli radio wifi off

Obviamente, o dispositivo sem fio pode ser ativado novamente com o comando  `nmcli radio wifi on`.

>[!NOTE]
>
>Uma vez que as conexões forem estabelecidas, nenhuma interação manual será necessária no futuro, pois o NetworkManager identifica as redes conhecidas disponíveis e se conecta a elas automaticamente. Se necessário, o NetworkManager possui plugins que podem estender suas funcionalidades, por exemplo para suportar conexões VPN.

>[!NOTE]
>
>o UUID da conexão muda a cada vez que a conexão é ativada e, portanto, é preferível usar o nome para manter a consistência

Redes que o PC já conectou (e conhece):  **/etc/NetworkManager/system-connections**  e se dar um  **ls -la**, vai listar todas as redes que já foram conectadas (tanto wireless como rede cabeada). Inclusive se der um cat (como root) **mostra até a senha da rede** em um dos arquivos de conexão sem fio.

>[!WARNING]
>
>Atenção para os **estados possíveis** na execução de “**nmcli networking connectivity**” (pelo man):
-   **none**: O host não está conectado em nenhuma rede.
-   **portal**: O host está atrás de um “captive portal” e ainda não possui total acesso à Internet. “Captive portal” é a tela de login à qual você é redirecionado ao se conectar em uma rede de hotel ou aeroporto por exemplo.
-   **limited**: O host está conectado à rede, mas não tem acesso à Internet.
-   **full**: O host está conectado à rede e tem total acesso à Internet.
-   **unknown**: O status da conectividade não pode ser encontrado.

##### uma breve apresentação de ifupdown

Primeiramente precisa verificar se o pacote `ifupdown` está instalado: `dpkg -l | grep ifupdown`, caso não tenha, instalar: `apt install ifupdown -y` (nas distros mais recentes esse pacote foi retirado devido a entenderem que o que deve ser utilizado é o `NetworkManager`).

No man `ifup`, fala claramente que tanto `ifup` (para subir interfaces) como `ifdown` (para baixar interfaces) são usados baseados no arquivo `/etc/network/interfaces` (para caso deseje não utilizar o NetworkManager, e usar por arquivo de configuração)

Se tentarmos dar um `ifdown` na interface `enp2s0`, vai retornar que a interface em questão é desconhecida, pois `enp2s0` não está listado no arquivo `/etc/network/interfaces`.

#### systemd-networkd

O `systemd` também tem um gerenciador de rede (`systemctl status systemd-networkd` - provavelmente vai estar desabilitado) muito parecido com o modo de administração do NetworkManager.

No entanto é possível mudar o gerenciamento para o **systemd-networkd**. Basta parar o NetworkManager (`systemctl stop NetworkManager`) e iniciar o systemd-networkd (`systemctl start systemd-networkd`)

Se tentar rodar `nmcli device`, vai dar erro, pois o NetworkManager foi parado anteriormente.

Os arquivos de configuração podem estar em:
- `/lib/systemd/network` (com arquivos `.link` e `.network`) é onde. Aqui seria o diretório de rede do sistema.
- `/etc/systemd/network` : diretório local de administração da rede.
- `/run/systemd/netif` ou `/run/systemd/network`: diretório volátil de tempo de execução da rede.

Os arquivos são processados em ordem lexicográfica, por isso é recomendável iniciar seus nomes com números para facilitar o ordenamento e a leitura.

Os arquivos em  `/etc`  têm a prioridade mais alta, ao passo que os arquivos em  `/run`  têm precedência sobre os arquivos com o mesmo nome em  `/lib`. Ou seja, se dois ou mais arquivos de configuração em diretórios diferentes tiverem o mesmo nome, o systemd-networkd ignora os que tiverem menor prioridade. Essa maneira de separar os arquivos permite mudar as configurações da interface sem que seja necessário modificar os arquivos originais: as modificações podem ser postas em  `/etc/systemd/network`  para sobrescrever as existentes em  `/lib/systemd/network`.

A finalidade de cada arquivo de configuração depende de seu sufixo. Os nomes de arquivos que terminam em  `.netdev`  são usados pelo systemd-networkd para criar dispositivos de rede virtuais, como dispositivos  _bridge_  ou  _tun_. Os arquivos que terminam em  `.link`  definem configurações de baixo nível para a interface de rede correspondente. O systemd-networkd detecta e configura os dispositivos de rede automaticamente conforme eles aparecem — além de ignorar dispositivos já configurados por outros meios — e, portanto, há pouca necessidade de adicionar esses arquivos na maioria das situações.

O sufixo mais importante é  `.network`. Os arquivos que empregam esse sufixo podem ser usados para configurar endereços de rede e rotas. Tal como acontece com os outros tipos de arquivos de configuração, o nome do arquivo define a ordem em que ele será processado. A interface de rede à qual o arquivo de configuração se refere é definida na seção  ``[Match]` ``  dentro do arquivo.

Por exemplo, a interface de rede ethernet  `enp3s5`  pode ser selecionada dentro do arquivo  `/etc/systemd/network/30-lan.network`  graças à entrada  `Name=enp3s5`  na seção  `[Match]`:
```
[Match]
Name=enp3s5
```
Também é possível usar uma lista de nomes separados por espaços em branco para selecionar diversas interfaces de rede de uma vez neste mesmo arquivo. Os nomes podem conter globs no estilo do shell, como  `en*`. Outras entradas permitem usar regras diferentes, como por exemplo selecionar um dispositivo de rede por seu endereço MAC:
```
[Match]
MACAddress=00:16:3e:8d:2b:5b
```
As configurações do dispositivo estão na seção  `[Network]`  do arquivo. Uma configuração de rede estática simples requer apenas as entradas  `Address`  e  `Gateway`:
```
[Match]
MACAddress=00:16:3e:8d:2b:5b

[Network]
Address=192.168.0.100/24
Gateway=192.168.0.1
```
Para usar o protocolo DHCP em vez de endereços IP estáticos, a entrada  `DHCP`  deve ser usada:
```
[Match]
MACAddress=00:16:3e:8d:2b:5b

[Network]
DHCP=yes
```
O serviço systemd-networkd tenta buscar os endereços IPv4 e IPv6 para a interface de rede. Para usar apenas IPv4, empregamos  `DHCP=ipv4`. Da mesma forma,  `DHCP=ipv6`  ignora as configurações IPv4 e usa apenas o endereço IPv6 fornecido.

As redes sem fio protegidas por senha também podem ser configuradas pelo systemd-networkd, mas o adaptador de rede já deve estar autenticado na rede antes que o systemd-networkd possa configurá-lo. A autenticação é realizada pelo  _WPA supplicant_, um programa dedicado a configurar adaptadores de rede para redes protegidas por senha.

O primeiro passo é criar o arquivo de credenciais com o comando  `wpa_passphrase`:
```
# wpa_passphrase MyWifi > /etc/wpa_supplicant/wpa_supplicant-wlo1.conf
```
Este comando pega a frase-senha para a rede sem fio  `MyWifi`  da entrada padrão e armazena seu hash em  `/etc/wpa_supplicant/wpa_supplicant-wlo1.conf`. Note que o nome do arquivo deve conter o nome apropriado da interface sem fio, por isso o  `wlo1`  no nome do arquivo.

O gerenciador do systemd lê os arquivos de frase-senha do WPA em  `/etc/wpa_supplicant/`  e cria o serviço correspondente para executar o WPA supplicant e abrir a interface. O arquivo de frase secreta criado no exemplo terá uma unidade de serviço correspondente chamada  `wpa_supplicant@wlo1.service`. O comando  `systemctl start wpa_supplicant@wlo1.service`  associará o adaptador sem fio ao ponto de acesso remoto. O comando  `systemctl enable wpa_supplicant@wlo1.service`  tornará essa associação automática durante a inicialização.

Finalmente, um arquivo  `.network`  correspondente à interface  `wlo1`  deve estar presente em  `/etc/systemd/network/`, já que o systemd-networkd vai usá-lo para configurar a interface assim que o WPA supplicant encerrar a associação com o ponto de acesso.

Lembrando que a LPI apenas cobra que saiba (awareness) que existe o `systemd-networkd`

#### nomenclaturas das placas de rede

As distribuições Linux mais antigas atribuíam às interfaces de rede ethernet nomes como  `eth0`,  `eth1`, etc., numeradas de acordo com a ordem em que o kernel identificava os dispositivos. As interfaces wireless eram nomeadas  `wlan0`,  `wlan1`, etc. Esta convenção de nomenclatura, no entanto, não esclarece qual porta Ethernet específica corresponde à interface  `eth0`, por exemplo. Dependendo de como o hardware fosse detectado, era possível inclusive que duas interfaces de rede trocassem de nome após uma reinicialização.

Para evitar essa ambiguidade, os sistemas Linux mais recentes empregam uma convenção de nomenclatura previsível para as interfaces de rede, criando uma aproximação maior entre o nome da interface e a conexão de hardware subjacente.

Nas distribuições Linux que usam o esquema de nomenclatura do systemd, todos os nomes de interfaces começam com um prefixo de dois caracteres que indica o tipo de interface:
- `en`: Ethernet
- `ib`: InfiniBand
- `sl`: Serial line IP (slip)
- `wl`: Rede de área local sem fio (WLAN)
- `ww`: Rede de longa distância sem fio (WWAN)

De prioridade mais alta para mais baixa, as seguintes regras são usadas pelo sistema operacional para nomear e numerar as interfaces de rede:

1.  Nomear a interface de acordo com o índice fornecido pela BIOS ou pelo firmware dos dispositivos incorporados, por exemplo,  `eno1`.
2.  Nomear a interface de acordo com o índice do slot PCI Express, conforme fornecido pela BIOS ou firmware, por exemplo,  `ens1`.
3.  Nomear a interface de acordo com seu endereço no barramento correspondente, por exemplo,  `enp3s5`.
4.  Nomear a interface de acordo com o endereço MAC da interface, por exemplo,  `enx78e7d1ea46da`.
5.  Nomear a interface usando a convenção legada, por exemplo,  `eth0`.

É correto pressupor, por exemplo, que a interface de rede  `enp3s5`  recebeu esse nome porque não se encaixava nos dois primeiros métodos de nomenclatura, de forma que seu endereço no barramento e no slot correspondentes foi usado. O endereço do dispositivo  `03:05.0`, encontrado na saída do comando  `lspci`, revela o dispositivo associado:

    $ lspci | fgrep Ethernet
    03:05.0 Ethernet controller: Realtek Semiconductor Co., Ltd. RTL-8110SC/8169SC Gigabit Ethernet (rev 10)

As interfaces de rede são criadas pelo próprio kernel do Linux, mas existem muitos comandos que podem ser usados para interagir com elas. Normalmente, a configuração ocorre automaticamente e não há necessidade de se alterar as configurações manualmente. Ainda assim, com o nome da interface, é possível informar ao kernel como proceder para configurá-la se necessário.

## 109.3 Resolução de problemas básicos de rede

Na LPI-1 versão 5, foi adicionado o uso do pacote `iproute2` (`dpkg -l | grep iproute2`), sendo o principal pacote abordado, tendo os principais comandos o `ip` e `ss`.

Quem trabalha com linux a mais tempo, muito provável está mais acostumado a trabalhar com os comandos `ifconfig`, `route` e `netstat`, que são comandos do pacote `net-tools` (para administrar interfaces de rede e rotas no sistema).

O `iproute2` é uma implementação mais moderna, e a tendencia é utilizá-lo no lugar dos comandos do pacote `net-tools`. O pacote `net-tools`, no ponto de vista do exame, exige apenas conhecimento (awareness)

Com o comando IP é possível configurar interfaces e criar rotas. Na lição 109.2, quando foi visto NetworkManager, era ele quem fazia as alterações e configurações diretamente nas interfaces, já com `ip`, é o administrador que faz esse contato direto com as interfaces e todas do computador.

- `ip link show`: mostra as interfaces em uso e se estão funcionando. Não mostra IP. `link` é referente às interfaces (mostra também se está UP/DOWN).
- `ip address show` (pode usar `addr`): mostra com informações do IP
-  `ip route show` ou `ip route list`: mostra as rotas, como a default (pc que não está navegando, pode ser que está sem rota default)

Pressupondo que o sistema de arquivos  `sys`  esteja montado, também podemos listar o conteúdo de  `/sys/class/net`

    $ ls /sys/class/net
    enp0s3  enp0s8  lo

#### manipular endereços na interface

- `ip addr add 192.168.1.50/24 dev enp0s2`: configura o IP `192.168.1.50` na interface `enp0s2` (uma interface de rede pode receber mais de 1 IP)
- `ip addr del 192.168.1.50/24 dev enp0s2`: remove o IP 192.168.1.50 da interface enp0s2
- `ip addr flush dev enp0s2` remove todos os IPs configurados na interface `enp0s2`
- `ip addr add 2001:db8::10/64 dev enp0s8`: define u IPv6 para interface `enp0s8`

*Lembrando que essas alterações são em memória, ao reiniciar o PC, ele pegará as configurações do NetworkManager ou outro programa que esteja configurado para gerenciar a rede.

#### manipular a interface em si

O comando `ip link` é usado para configurar a interface de baixo nível ou para configurações de protocolos, como `VLANs`, `ARP` ou `MTUs`, ou ainda para desabilitar uma interface.

Às vezes é necessário ajustar o MTU de uma interface. Da mesma forma que é possível habilitar/desabilitar interfaces, esse ajuste também pode ser feito com  `ifconfig`  ou  `ip link`:

    # ip link set enp0s8 mtu 2000
    # ip link show dev enp0s3
    2: enp0s3: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu **2000** qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000
        link/ether 08:00:27:54:53:59 brd ff:ff:ff:ff:ff:ff
    # ifconfig enp0s3 mtu 1500
    # ip link show dev enp0s3
    2: enp0s3: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu **1500** qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000
        link/ether 08:00:27:54:53:59 brd ff:ff:ff:ff:ff:ff

- `ip link set enp0s2 down` (para subir usa `up`): baixa a interface `enp0s2` (retira o UP quando `ip link show`). Caso tenha mudado o IP antes de dar down e up, acaba perdendo essa configuração e busca novamente no gerenciador padrão de rede (normalmente NetworkManager).


#### rotas

Se adicionar um IP qualquer em alguma interface, será criado uma rota para a placa de rede escolhida. Se pode exemplo, `ip addr add 10.0.0.10/24 dev enp0s2` for executado, nas rotas (`ip route show`) será adicionado uma entrada dessa forma:
```
10.0.0.0/24 dev enp0s2 proto kernel scope link scr ...
```
Isso indica que tudo que estiver na rede `10.0.0.0/24` vá para interface `enp0s2`

- `ip route del default`: remove a rota default
- `ip route add default via 192.168.1.1`: adiciona uma rota default (nesse caso vai anexar à interface que a rede `192.168.1.0` pertence)
- `ip route add defaul via 192.168.1.1 dev enp0s2`: nesse caso adiciona a rota default à interface desejada, que no caso é `enp0s2`.
- `ip route add 172.16.30.0/24 via 10.0.0.1 dev enp0s2` : todo tráfego que for para a rede `172.16.30.0` vai para a rede `10.0.0.1` (`dev enp0s2` é opcional, pois aqui também detecta pela rede),
- - `ip route del 172.16.30.0/24 via 10.0.0.1 dev enp0s2`: remove a rota criada anteriormente
- 
No comando ip, a  opção `-s` ou `--stats` ou `-statistics` também pode ser usada para obtenção de estatísticas, como pacotes enviados, recebidos e etc, por exemplo:
-   `ip -s address` 
-   `ip -s address show wlp3s0`
-   `ip -s link`
-   `ip -s link show wlp3s0`

#### net-tools (ifconfig e route)

-`ifconfig enp0s8 down`: baixa a interface (se der `ifconfig`, não mostrartá mais, para mostrar precisar usar `ifconfig -a` - display all interfaces which are currently available, even if `down`)
- `ifconfig enp0s8 up`: sobe a interface (vai voltar o que estiver no padrão do NetworkManager)
- `ifconfig enp0s8 10.0.0.100 netmask 255.255.255.0` (pode fazer por CIDR também: `10.0.0.100/24`): coloca o IP 10.0.0.100 na interface `enp0s8`.
- `ifconfig enp0s8 add 2001:db8::10/64`: configura IPv6 na interface.

*Note como, no IPv6, a palavra-chave  `add`  foi usada. Se um endereço IPv6 não for precedido por  `add`, será exibida uma mensagem de erro.

Se um interface já estiver down, e queira subir com IP, acrescente up no final do comando anterior, ficando:
```
ifconfig enp0s8 10.0.0.100 netmask 255.255.255.0 up
```
Adicionar mais de um IP na mesma interface: 

    ifconfig enp0s8:0 10.0.0.100 netmask 255.255.255.0
    ifconfig enp0s8:1 10.0.0.102 netmask 255.255.255.0
    etc

- `route`: mostra a tabela de roteamento (similar ao `ip route`). Rota `default` = `0.0.0.0`
- `route del default`: remove a rota default
- route add default gw 192.168.1.1: adiciona a rota default para o gateway 192.168.1.1
- `route add -net 172.16.30.0/24 gw 192.168.1.50`: tudo que chegar para a rede `172.16.30.0/24` mande para `192.168.1.50`.


#### Comandos Debug

- `hostname -d` (ou `--domain`): mostra o domínio
- `hostname -f` (ou `--fqdn` ou `--long`): mostra o full qualified domain name (nome completo - hostname + domínio). Nome de domínio pega do `/etc/hosts`. Pega informações do NIS domain name (ou do DNS). **NIS (Network Information Service)**, também conhecido como **YP (Yellow Pages)**, é um serviço de diretório usado em sistemas Unix e Linux para compartilhar informações administrativas de forma centralizada em uma rede. Ele é projetado para distribuir dados como usuários, senhas, grupos, informações de hosts, entre outros, para facilitar a administração de sistemas em redes locais.

O **YP domain name** (nome do domínio NIS) é o identificador que agrupa os servidores e clientes NIS que compartilham o mesmo conjunto de informações. Ele é essencial para que os clientes saibam de qual servidor NIS obter dados.

- `ping -c5 192.168.0.1`: dispara 5 `ECHO_REQUEST` para o host/IP, que por sua vez, se acessível, faz 5 `ECHO_REPLY`.
- `ping -c5 -i2 192.168.0.1`: dispara a cada 2 segundos (-i = interval)
- `ping www.google.com`: primeiro vai resolver o domínio, buscando em `/etc/hosts/` e depois no `DNS`. Lembrando que se não está resolvendo o domain name, pode ser que a conexão esteja tudo certo, mas algum problema no `DNS`. Caso esteja resolvendo o domain name e obtendo o IP, mas mesmo não retorna o ping, pode ter algum problema da rota padrão. Uma última opção de falha, seria algum firewall no caminho ou no próprio domínio, que as vezes pode estar configurado para não receber ICMP (por exemplo o domínio `www.lpi.org` não responde a pacotes ICMP)

O `ping` em linhas gerais, trabalha tanto em IPv4 como em IPv6, mas caso queira especificar:
- `ping -4`: especifica que é um endereço IPv4
- `ping -6`: especifica que é um endereço IPv6

Para testar o IPv6, rode `host ipv6.google.com`, para obter o endereço IPv6
- `ping6 2800:3f0:4001:804::200e`: faz o ping no domínio IPv6 do google (O PC assim como o roteador e sua ISP precisam estar preparados para IPv6 para conclusão do comando acima)

- `traceroute www.google.com`: imprime a rota que o pacote faz até chegar ao host  de destino (**NÃO** faz por **ICMP**, e sim por **UDP**)
- `traceroute -I www.google.com` (ou `--icmp`): imprime a rota que o pacote faz até chegar ao host  de destino **USANDO ICMP** (com `-I`, precisa ser **root**).
- `traceroute6 ipv6.google.com`: imprime a rota usando IPv6 (específico para `IPv6`)

Semelhante ao `traceroute` é o `tracepath`. O `tracepath` não precisa ser root para excutar, como acontece com algumas opções do `traceroute`. O tracepath também trabalha com pacotes `UDP`.

Veja a descrição do man do `tracepath`:<br>

*It traces the network path to destination discovering MTU along this path. It uses UDP port port or some random port. It is similar to traceroute. However, it does not require superuser privileges and has no fancy options. tracepath -6 is a good replacement for traceroute6 and classic example of application of Linux error queues. The situation with IPv4 is worse, because commercial IP routers do not return enough information in ICMP error messages. Probably, it will change, when they are updated. For now it uses Van Jacobson's trick, sweeping a range of UDP ports to maintain trace history.*

Entretanto `tracepath` é mais simples do que o `tracepath`. Para IPv6, tem o `tracepath6`

Exercícios interessantes
1. Qual subcomando de  `ip`  pode ser usado para configurar a marcação de vlan?<br>
`ip link`  tem uma opção  `vlan`  que pode ser empregada. Veja abaixo um exemplo de marcação de uma sub-interface com vlan 20.

    # ip link add link enp0s9 name enp0s9.20 type vlan id 20

2. Como fazer backup da tabela de roteamento? Como restaurar esse backup?
    
    O exemplo abaixo demonstra o backup e a restauração de uma tabela de roteamento:
  ```  
    # ip route save > /root/routes/route_backup
    # ip route restore < /root/routes/route_backup
```

3. Qual subcomando de  `ip`  pode ser usado para configurar opções de spanning tree?

Como no caso do gerenciamento de configurações de vlan, o  `ip link`  pode configurar o spanning tree usando o tipo  `bridge`. O exemplo mostra a adição de uma interface virtual com uma prioridade STP de 50:

    # ip link add link enp0s9 name enp0s9.50 type bridge priority 50

#### comando ss e netstat

O `ss` é um comando do pacote `ip route` (mais moderno). O `netstat` pertence ao pacote `net-tools` (mais antigo). Ambos são utilizados para ver as conexões ativas no computador.

    $ whatis ss
    ss (8)               - another utility to investigate sockets
    $ whatis netstat
    netstat (8)          - Print network connections, routing tables, interface statistics, masquerade connections, and multicast...

Eis algumas opções disponíveis para ambos os programas (`ss` e `netstat`):
- `-a`: Mostra todos os sockets.
- `-l`: Mostra os sockets de escuta.
- `-p`: Mostra o processo associado à conexão.
- `-n`: Impede pesquisas de nome para portas e endereços.
- `-t`: Mostra as conexões TCP.
- `-u`: Mostra as conexões UDP.

- `ss`: mostra todas as conexões (e sockets) da máquina (inclusive para abertura de arquivos - que também usam socket)
- `ss -tu` (`-t` ou `--tcp` e `-u` ou `--udp`): lista conexões dos pacotes TCP e UDP estabelecidas no momento (mostra apenas conexões estabelecidas).
- `ss -a` (`--all`): mostra ambas `listening` e `non-listening` sockets
- `ss -l (--listening)`: mostra sockets que estão somente em `listening`(normalmente esses já são omitidos por padrão)

As formas vistas até agora, o comando ss resolve o nome das portas, em vez de colocar o número delas, assim como os hosts, para não resolver, use `-n`:
- `ss -tuln`: mostra sockets somente em `listening`, que sejam TCP e UDP e não resolve os nomes (mostrando o número da porta em si, e não a sua descrição - a descrição é obtida em `/etc/services`)

Com o `netstat`, vai funcionar normalmente, mudando apenas um pouco o formato: `netstat -tuln`

- `netstat ou ss -tanp`: mostra as conexões da porta TCP e UDP, com estado de `listening`, não resolvendo nomes e portas e relacionando o serviço com seu respectivo `PID` (`-p`).

Os exemplos abaixo mostram a saída de um conjunto de opções comumente usado em ambos os programas:

    # netstat -tulnp
    Active Internet connections (only servers)
    Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
    tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      892/sshd
    tcp        0      0 127.0.0.1:25            0.0.0.0:*               LISTEN      1141/master
    tcp6       0      0 :::22                   :::*                    LISTEN      892/sshd
    tcp6       0      0 ::1:25                  :::*                    LISTEN      1141/master
    udp        0      0 0.0.0.0:68              0.0.0.0:*                           692/dhclient
    # ss -tulnp
    # ss -tulnp
    Netid  State      Recv-Q Send-Q      Local Address:Port                     Peer Address:Port
    udp    UNCONN     0      0                       **:68                                  *:**                   users:(("dhclient",pid=693,fd=6))
    tcp    LISTEN     0      128                     **:22                                  *:**                   users:(("sshd",pid=892,fd=3))
    tcp    LISTEN     0      100             127.0.0.1:25                                  **:**                   users:(("master",pid=1099,fd=13))
    tcp    LISTEN     0      128                  [::]:22                               [::]:*                   users:(("sshd",pid=892,fd=4))
    tcp    LISTEN     0      100                 [::1]:25                               [::]:*                   users:(("master",pid=1099,fd=14))

A coluna  `Recv-Q`  é o número de pacotes que um socket recebeu, mas não passou para seu programa. A coluna  `Send-Q`  é o número de pacotes que um socket enviou e que não foram confirmados pelo receptor. As colunas restantes são autoexplicativas.

Alguns exercícios interessantes

1. Qual comando poderia mostrar se há processos escutando na porta TCP 80?

Com  `ss`:

    $ ss -ln | grep ":80"

Com  `netstat`:

    $ netstat -ln | grep ":80"

Embora este não seja um requisito para o exame, você também poderia usar  `lsof`:

    # lsof -Pi:80

2. Como forçar o  `traceroute`  a usar uma interface diferente?

Usando a opção  `-i`:

    $ traceroute -i eth2 learning.lpi.org
    traceroute -i eth2 learning.lpi.org
    traceroute to learning.lpi.org (208.94.166.201), 30 hops max, 60 byte packets

3. O  `traceroute`  é capaz de relatar MTUs?

Sim, com a opção  `--mtu`:

    # traceroute -I --mtu  learning.lpi.org
    traceroute to learning.lpi.org (208.94.166.201), 30 hops max, 65000 byte packets
     1  047-132-144-001.res.spectrum.com (47.132.144.1)  9.974 ms **F=1500**  10.476 ms  4.743 ms
     2  096-034-094-106.biz.spectrum.com (96.34.94.106)  8.697 ms  9.963 ms  10.321 ms
    ...

#### netcat

Usado para teste de conexão no computador ou para abrir conexões locais. (arbitrary TCP and UDP connections and listens)

- `netcat 127.0.0.1 22`: teste localmente se é possível conectar na porta 22 (funciona parecido com `telnet`).

>[!NOTE]
>
>`netcat` e `nc` são o mesmo comando.

- `nc -l -p 1234`: abre a porta `1234` para ficar em `listening`. (`-l` = Listen for an incoming connection rather than initiating a connection to a remote host) e (`-p` = source_port: specify the source port `nc` should use, subject to privilege restrictions and availability)
- `nc 192.168.0.20 1234`: conecta na conexão aberta anteriormente (se digitar algo, aparece na outra ponta que está abrindo a conexão)
- `nc -vz 192.168.0.20 1234`: mostra uma mensagem se a conexão foi com sucesso. (`-v` Produce more verbose output) e (`-z` Only scan for listening daemons, without sending any data to them.  Cannot be used together with `-l`.)
- `nc -k -l -p 1234`: mantém a conexão para testes (`-k` When a connection is completed, listen for another one.  Requires `-l`.  When used together with the `-u` option, the server socket is not  connected and it can receive UDP datagrams from multiple hosts.)
- `nc -vz 192.168.0.20 1230-1240`: teste o range de portas definido entre `1230` e `1240`

O netcat funciona com endereços IPv4 e IPv6. Ele funciona com TCP e UDP. Pode inclusive ser usado para configurar um **shell remoto rudimentar**.
```
    $ hostname
    net2
    $ nc -u -e /bin/bash -l 1234
```
A opção  `-u`  significa UDP.  `-e`  instrui o netcat a enviar tudo o que recebe para a entrada padrão do executável que vem em seguida. Neste exemplo,  `/bin/bash`.

    $ hostname
    net1
    $ **nc -u net2.example.net 1234
    hostname
    net2
    pwd
    /home/emma

Percebeu como a saída do comando  `hostname`  corresponde à do host ouvinte e a saída do comando  `pwd`  é um diretório?

>[!WARNING]
>
>Nem toda instalação de  `nc`  suporta a opção  `-e`. Consulte as páginas de manual de sua instalação para obter informações de segurança sobre esta opção, bem como métodos alternativos para executar comandos em um sistema remoto.


## 109.4 Configurar o DNS do lado do cliente

- `/etc/hosts`: referências fixas entre IP e Nomes
- `/etc/nsswitch.conf`: determinar se a primeira consulta vai ser nos arquivos internos (padrão, como `hosts`)
- `/etc/resolv.conf`: arquivo principal onde é adicionado os servidores DNS (indicado por `nameserver`). Aqui que pode ter configuração de domínio: `domain dominio.com.br`
- `/etc/resolv.conf` está sendo gerado por  `/run/systemd/resolve/stub-resolv.conf` (resolvedor interno, pelo serviço `systemd.resolvd`)
- comando `resolvectl status` para ver os DNS configurados propriamente dito
- comando `resolvectl statistics` mostra estatísticas do servidor DNS, com cache, total de transações, etc.

A opção  `search` (em `/etc/resolv.conf`)  é usada para permitir pesquisas curtas. No exemplo, configuramos um único domínio para pesquisa,  `lpi.org`. Isso significa que qualquer tentativa de resolver um nome de host sem uma parte de domínio terá  `.lpi.org`  incluído antes da pesquisa. Por exemplo, se pesquisarmos por um host chamado  `learning`, o resolvedor buscará por  `learning.lpi.org`. É possível configurar até seis domínios de pesquisa.

Outra opção comum é  `domain`. Ela é usada para definir o nome de domínio local. Se esta opção estiver ausente, o padrão é usar tudo após o primeiro  `.`  no nome de host da máquina. Se o nome do host não contiver um  `.`, presume-se que a máquina faça parte do domínio raiz. Como no caso de  `search`,  `domain`  pode ser usado para pesquisas curtas de nomes.

Lembre-se de que  `domain`  e  `search`  são mutuamente exclusivos. Se ambos estiverem presentes, será usada a última instância no arquivo.

Muitas opções podem ser definidas de forma a afetar o comportamento do resolvedor. Para configurá-las, use a palavra-chave  `option`, seguida pelo nome da opção a ser configurada e, se for o caso, um  `:`  seguido pelo valor. Veja abaixo um exemplo de configuração da opção de tempo limite (timeout), ou seja, o período de tempo em segundos que o resolvedor espera por um servidor de nome antes de desistir:

    option timeout:3

O systemd inclui um serviço chamado `systemd-resolved`. Ele fornece mDNS, DNS e LLMNR. Quando está em execução, ele escuta as solicitações de DNS em `127.0.0.53`. Ele _não_ fornece um servidor DNS completo. Quaisquer solicitações de DNS que recebe são pesquisadas nos servidores configurados em `/etc/systemd/resolv.conf` ou `/etc/resolv.conf`. Se você deseja empregar o serviço, use `resolve` para `hosts` em `/etc/nsswitch.conf`. Lembre-se de que o pacote do sistema operacional que possui a biblioteca `systemd-resolution` pode não estar instalado por padrão

- `getent`, é útil para ver como as solicitações do mundo real serão resolvidas.
- `host`, é ótimo para consultas de DNS simples. 
- `dig` é prático para operações de DNS complexas que podem ajudar na resolução de problemas do servidor DNS.

- `host www.debian.org`: usa o servidor DNS para resolver o endereço www.debian.org. Se retirar o `www`, mostra todos os IPs relacionados ao domínio.
- `host www.debian.org 1.1.1.1`: consulta usando o server `1.1.1.1`
- `host -t mx debian.org`: mostra quais são os servidores que recebem query relacionadas aos emails no domínio. (`-t type`: This option specifies the query type. The type argument can be any recognized query type: `CNAME`, `NS`, `SOA`, `TXT`, `DNSKEY`, `AXFR`, etc)

- `dig` (antigamente usava `nslookup`): parecido com `host`, mas tem mais opções (internamente consulta o `systemd-resolve`).
- `dig www.debian.org @1.1.1.1`: consulta usando o server `1.1.1.1`
- `dig www.debian.org +short`: mostra só o IP (retira outros cabeçalhos)
- `dig -x 200.45.31.18`: resolve reverse lookups (mostra o nome associado ao IP)

- `getent`: pela entradas do Name Service Switch libraries (`/etc/nsswitch.conf`)
- `getent passwd`: mostra informações do `/etc/passwd`
- `getent passwd rodrigo`: mostra informações do usuário rodrigo
- `getent hosts www.debian.org`: resolve o domínio (tende resolver IPv6 - diferentemente de `host www.debian.org`, que traz IPv4 e IPv6)
- `getent ahostsv4 www.debian.org`: resolve em IPv4

Databases suportadas:
`ahosts` `ahostsv4` `ahostsv6` `aliases` `ethers` `group` `gshadow` `hosts` `initgroups` `netgroup` `networks` `passwd` `protocols` `rpc` `services` `shadow` (lembrar que `/etc/nsswitch.conf` que aponta por meio de `db files`)

Exercicios interessantes

1. Qual das opções a seguir é uma entrada correta de  `/etc/hosts`  entry?

| | |
|---|---|
|  ::1 localhost | certo |
| **localhost 127.0.0.1** | errado  |

`::1 localhost`  é a linha correta. A coluna da esquerda é sempre um endereço IPv4 ou IPv6.

2. O que significa a seguinte linha em  `/etc/nsswitch.conf`?
```
    hosts: files [SUCCESS=continue] dns
```
As pesquisas por nomes de host verificarão primeiro os arquivos de  `/etc/hosts`  e em seguida o DNS. Se uma entrada for encontrada nos arquivos e no DNS, a entrada no DNS será preferida.

3. O que faz o comando  `dig +noall +answer +question lpi.org`?

Ele pesquisa o registro A de  `lpi.org`  e exibe apenas a consulta e a resposta.

4. Como passar por cima dos padrões de  `dig`  sem especificá-los na linha de comando?

Criando um arquivo  `.digrc`  em seu diretório inicial

## 110.1 Executar tarefas administrativas de segurança

#### su e sudo
- `su`: muda de usuário para outro (loga como `root`: precisa digitar a senha do `root`)
- `sudo su`: loga como root usando a senha do usuário normal.

- `su lpi2`: loga com usuário `lpi2` (apenas muda o usuário - não executa o `.profile`, não cai no `home` do usuário propriamente dito)
- `su - lpi2`: loga com usuário `lpi2` (faz um novo login, como usuário `lpi2`, executando o `.profile` e caindo no home do usuário `lpi2`)
- `su -`: o mesmo que o explicado anteriormente. (aqui é feito um login propriamente dito, carrega as informações de `.profile`). Só `su` não faz efetivamente login.

Há alguns comandos que exigem que seja executado somente pro user root, como o `fdisk`, por exemplo.

Para executar uma vez, estando com usuário lpi1: `su -c "fdisk -l` (vai pedir senha do usuário root - `-c` = `--command`). Depois de executar volta ao usuário comum.

O `sudo` serve para situações que você não tenha a senha do usuário root (comum em ambientes de produção), e que precisa executar algo com privilégios de root.
- `sudo su -`: se estiver logado como `lpi1`, vai pedir a senha de `lpi1`, e loga como `root`. (isso porque `lpi1` tem permissões de logar como `root`)

Agora caso seja um usuário que não tenha permissão, e tente se logar, teremos a seguinte mensagem de erro:
```
$ sudo su -
[sudo] password for lpi2:    
Sorry, user lpi2 is not allowed to execute '/usr/bin/su -' as root on computer-name.

ou

lpi2 is not in the sudoers file. This incident will be reported.
```

Caso possua as permissões, pode simplesmente executar comandos como root usando: `sudo fdisk -l`

- `/etc/sudoers`: arquivo de configuração que vai dizer o que quais usuário podem fazer as alterações no sistema. A `%` no sufixo dos nomes `admin` e `sudo` indica que tanto `%admin` como `%sudo` são grupos.
- `%admin = ALL=(ALL) ALL`: membros do grupo `admin`, podem a partir de qualquer terminal (primeiro `ALL`), utilizando qualquer usuário (segundo `ALL`), podem executar qualquer comando (terceiro `ALL`)
- `%sudo ALL=(ALL:ALL) ALL`: mesmo raciocínio, agora para o grupo `sudo`. O usuário criado na instalação, muito provavelmente estará nesse grupo. Confirme com o comando `grep sudo /etc/group`. Para adicionar um usuário ao grupo `sudo`, digite: `sudo usermod -aG sudo usuario`. Para remover use: `sudo usermod -rG sudo usuario`

Se quiser personalizar uma regra, por exemplo para determinar que usuário `lpi2` possa desligar o computador, inclua o seguinte no arquivo `/etc/sudoers`

    lpi2 ALL=/sbin/poweroff

Caso queira listar os comandos que deseja liberar (lembrando vai pedir a senha do usuário, o que vai acontecer é como se estivesse no grupo `sudo`):

    Cmnd_Alias TESTE = /sbin/fdisk, /sbin/parted
    lpi2  ALL=TESTE

- `visudo`: vai direto para edição do `/etc/sudoers` (usando o editor padrão - para alterar o editor padrão: `update-alternatives --config editor`)

**Observações**: O  `sudo`  permite executar comandos simples com privilégios elevados em vez de lançar um novo subshell para root, como faria  `su`.
    
O uso básico de  `sudo`  é  `sudo -u  _target-username_  _command_`. Porém, para executar um comando como usuário root, a opção  `-u  _target-username_`  não é necessária:

    carol@debian:~$ sudo -u mimi whoami
    mimi
    carol@debian:~$ sudo whoami
    root

>[!NOTE]
>
>O  `sudoers`  usa uma marca temporal por usuário (e por terminal) para ocultar as credenciais, sendo assim possível usar o  `sudo`  sem uma senha por um período padrão de quinze minutos. Esse valor padrão pode ser modificado adicionando-se a opção  `timestamp_timeout`  como configuração de  `Defaults`  em  `/etc/sudoers`  (p. ex.:  `Defaults timestamp_timeout=1`  define o tempo limite do cache de credenciais como um minuto).

#### O arquivo  `/etc/sudoers`

O arquivo de configuração principal do  `sudo`  é  `/etc/sudoers`  (também existe o diretório  `/etc/sudoers.d`). É ali que os privilégios de  `sudo`  dos usuários são determinados. Em outras palavras, aqui você especifica quem pode executar quais comandos, sob quais nomes de usuário e em quais máquinas — bem como outras configurações. A sintaxe usada é a seguinte:

    carol@debian:~$ sudo less /etc/sudoers
    (...)
    # User privilege specification
    root    ALL=(ALL:ALL) ALL
    
    # Allow members of group sudo to execute any command
    %sudo   ALL=(ALL:ALL) ALL
    (...)

A especificação de privilégio para o usuário root é  `ALL=(ALL:ALL) ALL`. Isso se traduz assim: o usuário root (`root`) pode se logar com todos os hosts (`ALL`), em nome de todos os usuários e todos os grupos (`(ALL:ALL)`), além de executar todos os comandos (`ALL`). O mesmo vale para os membros do grupo  `sudo` — note como os nomes de grupos são identificados com um símbolo de porcentagem (`%`).

Assim, para que a usuária  `carol`  seja capaz de verificar o status de  `apache2`  de qualquer host em nome de qualquer usuário ou grupo, adicionaríamos a seguinte linha ao arquivo  `sudoers`:

    carol   ALL=(ALL:ALL) /usr/bin/systemctl status apache2

Para evitar a  `carol`  o incômodo de precisar fornecer sua senha para executar o comando  `systemctl status apache2`, modificamos a linha desta maneira:

    carol   ALL=(ALL:ALL) NOPASSWD: /usr/bin/systemctl status apache2

Digamos que agora você queira restringir seus hosts a 192.168.1.7 e permitir que  `carol`  execute  `systemctl status apache2`  no nome da usuária  `mimi`. A linha teria de ser modificada desta forma:

    carol   192.168.1.7=(mimi) /usr/bin/systemctl status apache2

Vamos então verificar o status do servidor web Apache como a usuária  `mimi`:

    carol@debian:~$ sudo -u mimi systemctl status apache2
    ● apache2.service - The Apache HTTP Server
       Loaded: loaded (/lib/systemd/system/apache2.service; enabled; vendor preset: enabled)
       Active: active (running) since Tue 2020-06-09 13:12:19 CEST; 29min ago
    (...)

Se  `carol`  fosse promovida a sysadmin e você quisesse conceder a ela todos os privilégios, a maneira mais fácil seria incluí-la no grupo especial  `sudo`  com  `usermod`  e a opção  `-G`  (e talvez também a opção  `-a`, que garante que o usuário não seja removido de nenhum outro grupo ao qual possa pertencer):

    root@debian:~# sudo useradd -aG sudo carol

>[!NOTE]
>
>Na família de distribuições Red Hat , o grupo  `wheel`  é equivalente ao grupo especial de administradores  `sudo`  dos sistemas Debian.

Além dos usuários e grupos, também podemos utilizar aliases em  `/etc/sudoers`. É possível definir três categorias principais de aliases:  _aliases de host_  (`Host_Alias`),  _aliases de usuário_  (`User_Alias`) e  _aliases de comando_  (`Cmnd_Alias`). Eis um exemplo:

    # Host alias specification
    
    Host_Alias SERVERS = 192.168.1.7, server1, server2
    
    # User alias specification
    
    User_Alias REGULAR_USERS = john, mary, alex
    
    User_Alias PRIVILEGED_USERS = mimi
    
    User_Alias ADMINS = carol, %sudo, PRIVILEGED_USERS, !REGULAR_USERS
    
    # Cmnd alias specification
    
    Cmnd_Alias SERVICES = /usr/bin/systemctl *
    
    # User privilege specification
    root    ALL=(ALL:ALL) ALL
    ADMINS  SERVERS=SERVICES
    
    # Allow members of group sudo to execute any command
    %sudo   ALL=(ALL:ALL) ALL

A partir deste arquivo  `sudoers`  de amostra, vamos explicar os três tipos de aliases com um pouco mais de detalhes:

- **Aliases de host**: Incluem uma lista separada por vírgulas de nomes de host, endereços IP, redes e grupos de rede (precedidos por  `+`). Máscaras de rede também podem estar especificadas. O alias de host  `SERVERS`  inclui um endereço IP e dois nomes de host:
```
Host_Alias SERVERS = 192.168.1.7, server1, server2
```
- **Aliases de usuário**: Incluem uma lista separada por vírgulas de usuários especificados como nomes de usuários, grupos (precedidos por  `%`) e grupos de rede (precedidos por  `+`). Para excluir usuários específicos, usamos  `!`. O alias de usuário  `ADMINS` — por exemplo — inclui a usuária  `carol`, os membros do grupo  `sudo`  e os membros do alias de usuário  `PRIVILEGE_USERS`  que não pertencem ao alias de usuário  `REGULAR_USERS`:
```
User_Alias ADMINS = carol, %sudo, PRIVILEGED_USERS, !REGULAR_USERS
```
- **Aliases de comando**: Incluem uma lista separada por vírgulas de comandos e diretórios. Se um diretório for especificado, qualquer arquivo que esteja nesse diretório será incluído — mas os subdiretórios serão ignorados. O alias do comando  `SERVICES`  inclui um único comando com todos os seus subcomandos — conforme especificado pelo asterisco (`*`):
```
Cmnd_Alias SERVICES = /usr/bin/systemctl *
```
Como resultado das especificações de alias, a linha  `ADMINS SERVERS=SERVICES`  na seção  `User privilege specification`  é traduzida como: todos os usuários pertencentes a  `ADMINS`  podem usar  `sudo`  para executar qualquer comando em  `SERVICES`  em qualquer servidor em  `SERVERS`.

>[!NOTE]
>
>Existe um quarto tipo de alias que pode ser incluído em  `/etc/sudoers`:  _aliases de execução_  (`Runas_Alias`). São muito semelhantes aos aliases de usuário, mas permitem especificar usuários por seu  _ID de usuário_  (UID). Esse recurso pode ser conveniente em certos casos.

#### who, w, last, lastb, lastlog

- `who`: mostra quem está logado no sistema, mostrando usuário, o terminal (`tty7` = terminal gráfico) e horário que logou. Se apertar `Ctrl+Alt+F2` (vai para o `tty2`), e se logar por lá, voltar para o `tty` e digita novamente `who`, vai mostrar a sessão de `tty2`
- `who -aH` (`-a` = `--all` e `-H` = `--heading`, colocar um header): mostra mais detalhes, assim como os terminais que não estão em uso, mostra também o `pid`.

O `who` aceita uma série de opções, dentre as quais podemos destacar as seguintes:
- `-b`,`--boot`: Exibe a hora da última inicialização do sistema.
- `-r`,`--runlevel`: Mostra o nível de execução atual.
- `-H`,`--heading`: Imprime o cabeçalho das colunas.

- `w`: mostra quem está logado e o que está fazendo (Show who is logged on and what they are doing.). Se voltar lá no `tty2` e executar o `top`, voltar para `tty7` e digitar `w`, mostra todas as informações do que o usuário que logou no `tty2` está fazendo, quanto está consumindo, etc. **JCPU** = uso de CPU no geral, **PCPU** = quanto o processo que está sendo executado (`top`) está consumindo. Ideal para monitorar sessões que estão consumindo muito recurso do computador.

>[!NOTE]
>
>Comparado ao  `who`, o  `w`  fornece uma saída um pouco mais detalhada:

Como no caso do  `who`, podemos passar nomes de usuários ao  `w`: `root@debian:~# w lpi2`

- `last`: histórico de logins no computador. Mostra o usuário que logou, o terminal que usou, quando foi feito o login, e quanto tempo ficou logado.
- `last lpi2`: mostra os últimos logins do usuário `lpi2`
- `lastb`: histórico de usuários que tentaram se logar, mas erraram a senha, ou usuário não existia. Esses dados (do `last`) são consultados de `/var/log/wtmp` (arquivo binário). Para ler usar last -f `/var/log/wtmp` (`-f` ou `--file`). O `lastb` é lido em `/var/log/btmp`. Para ler faz igual ao last: `last -f /var/log/btmp`

- `lastlog`: mostra quando os usuários do sistema fizeram login (login mesmo, não conta `su -`). `Observação`: usuários de sistema normalmente não devem ter feito login (precisa mostrar como `Never logged in`.
- `lastlog -u rodrigo` (`-u` ou `--user`): mostra o último login do usuário `lpi2`

#### passwd, usermod e chage

- `chage`: muda as definições de tempo para a senha expirar, conta inativa. Olhar novamente no item 107.1 parte 4. Similar ao `passwd`

- `passwd -S lpi2` (`-S` ou `--status`): mostra o status do usuário `lpi2`
```
lpi1@debian:~$ passwd -S
lpi1 P 12/07/2019 0 99999 7 -1
```
Eis uma análise dos sete campos obtidos na saída:
- `lpi1`: Nome de login do usuário.
- `P`: Indica que o usuário possui uma senha válida (`P`); outros valores possíveis são  `L`  para uma senha bloqueada e  `NP`  para nenhuma senha.
- `12/07/2019`: Data da última alteração da senha.
- `0`: Idade mínima em dias (o número mínimo de dias entre mudanças de senha). Um valor de  `0`  significa que a senha pode ser alterada a qualquer momento.
- `99999`: Idade máxima em dias (o número máximo de dias em que a senha é válida). Um valor de  `99999`  desabilita a expiração da senha.
- `7`: Período de aviso em dias (o número de dias antes da expiração da senha em que um usuário será avisado).
- `-1`: Período de inatividade da senha em dias (o número de dias inativos após a expiração da senha até que a conta seja bloqueada). Um valor de  `-1`  remove a inatividade de uma conta.

- `passwd -x30 lpi2` (`-x` ou `--maxday`): define para a senha expirar daqui `30` dias. (consulte com `chage -l lpi2`) (similar ao `chage -M` ou `--maxdays`)
```
chage -l lpi2
Last password change					: Nov 13, 2024
Password expires					: Dec 13, 2024
Password inactive					: never
Account expires						: never
Minimum number of days between password change		: 0
Maximum number of days between password change		: 30 #definiu aqui
Number of days of warning before password expires	: 7
```
- `passwd -n2 lpi2` (ou `--mindays`): define o mínimo de dias que o usuário pode trocar a senha. Similar ao `chage -m` ou `--mindays`.

- `passwd -w4 lpi2` ( ou`--warndays`): número de dias que vai alertar que a senha vai expirar (Number of days of warning before password expires). No `chage`, seria `chage -W` ou `--warndays`
- `passwd -i10 lpi2` (ou `--inactive`): depois de 10 dias que a conta expirar, a conta vai ficar inativa. O `chage` seria `chage -I` ou `--inactive`
- `passwd -l lpi2` (ou `--lock`): trava (lock) o usuário `lpi2` (colocar `!` no primeiro caractere do campo de senha do `/etc/shadow`) - usando quando precisa investigar o usuário. Para destravar `passwd -u lpi1` (ou `--unlock`): retira a exclamação `/etc/shadow`. Quando estiver lock, no `passwd -S lpi2` vai mostrar um `L` de `Locked`. Se estiver `unlocked`, vai mostrar um `P` de `Password`. No `chage` seria `chage -E` ou `--expiredate` para fazer lock do usuário e `chage -1` para deixar `unlocked`

- `usermod -L lpi2` (ou `--lock`): trava (lock) o usuário
- `usernod -U lpi2` (ou `--unlock`): remove lock da conta.
- `usermod -e lpi2` (ou `--expiredate`): colocar uma data de expiração.
- `usermod -f lpi2` (ou `--inactive`): quantidade de dias que vai ficar inativo quando expirar a senha

#### find, ulimit, limits.conf

Partindo do cenário que `/usr/bin/passwd` tem o bit **SUID** ligado (`rwsr-xr-x`) e que qualquer usuário pode executá-lo como `root` e, diferentemente de `/bin/rm`, que por segurança não possui bit **SUID** ligado (pois qualquer usuário poderia excluir pastas críticas), é interessante monitorar por arquivos com **SUID** ligado, com o comando find.

- `find / -perm -4000 -ls` (ou `-2000`): `4000` procura por **SUID** e `2000` pelo **SGID** (o `-ls` no final é apenas para listar).
- `find / \( -perm -2000 -o -perm -4000 \) -ls
`: procura tanto por **SUID** como por **GUID** (precisa proteger com parênteses e escapá-los - o `-o` = or/ou).
- `find / -perm /6000`: busca tanto **SUID** como **GUID**

>[!NOTE]
>
>Pode usar com a notação simbólica: `find / -perm -u+s` para 4000 ou `find / -perm -g+s` para 2000.

Situação ideal seria criar um script que guarde essa informação diariamente, e compare, e caso haja mudança emita um alerta ao Administrador.

Outra medida de segurança é buscar por arquivos que não tenham usuários associados, novamente com o `find`:
- `find / -path /proc -prune -nouser -ls`: mostra todos

Alguns exercícios interessantes dessa seção:

1. O `chage` permite alterar as informações de expiração de senha de um usuário. Como root, complete a seguinte tabela, fornecendo os comandos corretos para o usuário `mary`:
2. 
| Significado           | Comandos `chage`                  |
|---------------------------|--------------------------------------|
| Faça a senha ser válida por 365 dias.                                       | `chage -M 365 mary`, `chage --maxdays 365 mary`                             |
| Faça o usuário alterar a senha no próximo login.                           | `chage -d 0 mary`, `chage --lastday 0 mary`                                 |
| Defina o número mínimo de dias entre as alterações de senha para 1.         | `chage -m 1 mary`, `chage --mindays 1 mary`                                 |
| Desative a expiração da senha.                                              | `chage -M 99999 mary`, `chage --maxdays 99999 mary`                         |
| Permita que o usuário altere sua senha a qualquer momento.                  | `chage -m 0 mary`, `chage --mindays 0 mary`                                 |
| Defina o período de aviso para 7 dias e a data de expiração da conta para 20 de agosto de 2050. | `chage -W 7 -E 2050-08-20 mary`, `chage --warndays 7 --expiredate 2050-08-20 mary` |
| Imprima as informações de validade da senha atual do usuário.               | `chage -l mary`, `chage --list mary`                                        |

2. Considere a seguinte linha de saída de comando  `last`  e responda às perguntas:
```
carol    pts/0        192.168.1.4      Sun May 31 14:16 - 14:22  (00:06)
```
-   `carol`  estava conectada a partir de um host remoto? Por quê?
    Sim, o endereço IP do host remoto está na terceira coluna.
    
-   Quanto tempo durou a sessão de  `carol`?
    Seis minutos (como mostrado na última coluna).
    
-   `carol`  estava conectada através de um terminal de texto clássico? Por quê?
    Não,  `pts/0`  na segunda coluna indica que a conexão foi feita por meio de um emulador de terminal gráfico (ou  _Pseudo Terminal Slave_).

3. Além de  `SUID`  e  `SGID`, existe uma terceira permissão especial: o  _sticky bit_. No momento, ele é usado principalmente em diretórios como  `/tmp`  para evitar que usuários regulares excluam ou movam arquivos que não sejam seus. Realize as seguintes tarefas:

-   Defina o  _sticky bit_  em  `~/temporal`:
    ```
    `chmod +t temporal`,  `chmod 1755 temporal`
    ```
-   Encontre diretórios com o  _sticky bit_  (e quaisquer outras permissões) definidas em seu diretório inicial:
    ```
    `find ~ -perm -1000`,  `find ~ -perm /1000`
    ```
-   Remova o  _sticky bit_  de  `~/temporal`:
    ```
    `chmod -t temporal`,  `chmod 0755 temporal`
    ```
## 110.2 Configurar a segurança do host



## 110.3 Proteção de dados com criptografia

#### O que é criptografia

Uma maneira de garantir que dados sejam enviados de um ponto a outro de maneira segura, tendo os objetivos principais:
	- Autenticidade (do remetente)
	- Confidencialidade (da mensagem)
	- Integridade (da mensagem)
	- Irretratabilidade (do remetente)

#### SSH - Secure Shell

- protocolo de criptográfica de rede
- cria um canal seguro de comunicação entre 2 hosts, um cliente e um servidor
- utiliza chaves assimétricas, ou seja, um conjunto de chaves públicas e privadas
- OpenSSH é a implementação mais comum

#### Chaves Assimétricas

- cada máquina possui sua chave pública e sua chave privada, que são associadas
- a **chave pública** será compartilhada com o remetente, que a utilizará para **criptografar** a mensagem antes de enviá-la
- a **chave privada** é utilizada pelo destinatário para **descriptografar** os dados recebidos

- `apt install openssh-server`: instala o OpenSSH Server (`/etc/ssh/sshd_config` - que recebe conexões). Instala também as chaves públicas e privadas (os conjuntos). Observar se o servidor `sshd` está rodando (`ps axu | grep sshd`)

Um detalhe interessante em relação às chaves, no caso as privadas, apenas root (chmod 600) que conseguirá ler ou escrever. Os demais usuário não terão permissão, com exceção das chaves públicas (chmod 644). Chave privada é secreta, já a pública não é.

#### conexão por senha

- `ssh lpi1@meu-servidor`: onde `lpi1` é o usuário do host remoto e meu-servidor pode ser o nome ou IP do servidor. A primeira conexão o host remoto envia a chave pública para o host que está conectando, para negociarem a conexão (geralmente será armazedo em `~/.ssh/known_hosts`). Se a chave mudar, vai dar erro ao conectar, e será necessário substituir a chave pública dentro de `~/.ssh/known_hosts`
- `ssh -l lpi1 meu-servidor`: outra forma de login, especificando o usuário com o comando `-l` (login_name). Se usar sem usuário, vai mandar o usuário do PC de origem para o servidor remoto (caso coincidam, vai funcionar)
- `ssh -v lpi1@meu-servidor`: modo verbose, para acompanhar os passos da conexão. Interessante notar que há um passo, chamado `Authentications that can continue`, que informa que deve tentar conexão primeiramente com publickey e depois password (`Authentications that can continue: publickey,password`)

>[!NOTE]
>
>Sobre o comando ssh, vale apontar também a opção `-i`, que pode ser utilizada para selecionar um arquivo de chave privada específico.

#### conexão por chaves (sem senha)

Primeiramente é preciso criar as chaves privada e pública no Host de origem.

- `ssh-keygen -t rsa -b 1024`: cria uma chave privada e pública usando o `-t` para especificiar o tipo da chave (se não especificar cria `Ed25519 Key` por padrão - é bom sempre verificar o man, pois as vezes muda esse padrão). O `-b` é de quantidade de bits que será usado para criar a chave.

>[!NOTE]
>
>Valores possíveis: `dsa` | `ecdsa` | `ecdsa-sk` | `ed25519` | `ed25519-sk` | `rsa` (Specifies the type of key to create.  The possible values are “dsa”, “ecdsa”,  “ecdsa-sk”, “ed25519”, “ed25519-sk”, or “rsa”)

>[!WARNING]
>
>Lembrando que o comando `ssh-keygen` gera as chaves para o usuário que está logado, armazendo em sua pasta home padrão (`~/.ssh/`)

Agora é necessário adicionar a chave pública no servidor que deseja acessar remotamente, mais especificamente no home do usuário do servidor, e criar o arquivo `authorized_keys` e colar a chave pública gerada no host de origem. Caso não exista o diretório `~/.ssh`, crie com o `mkdir` e mude as permissões para `600`. Caso tenha criado como root, mude para o usuário que prentende usar para o login, com `chown lpi1:lpi1 authorized_keys`.

Use o comando `ssh-copy-id -i id_rsa.pub lpi1@meu-servidor` para enviar a chave pública para o host servidor. Caso não exista o arquivo `authorized_key`, o comando no `ssh-copy-id` cria remotamente (e já adiciona a chave pública informada com o comando `-i`). É muito mais prático fazer o envio com esse comando.

A conexão por chave é muito interessante quando é necessário conectar com muita frequência em determinado computador, ou quando algum script precisar acessar algum outro computador, evitando o uso de senhas.

#### autenticação usando passphrase

Lembrando que passphrase é uma senha das chaves. Crie uma passphrase usando o oomando de gerar chaves, no caso o `ssh-keygen -t rsa -b 1024`.

Como é uma nova chave, compartilhe a chave pública ao servidor remoto (via `authorized_keys`)

Agora por meio do **ssh-agent** (`ps axu | grep ssh-agent`), as senhas das chaves (passphrase) serão memorizadas. Digite `ssh-add` para solicitar a senhas das chaves e criar identities que manterão a senha, por meio do 110.

Após delegar ao **ssh-agent**, efetue o login normalmente. O normal é logar diretamente, sem pedido de senha.

Para limpar as senhas digitadas, use `ssh-add -D` (Deletes all identities from the agent)

#### Ciphers

Basicamente há 4 tipos de chaves para criar com o comando `-t` de `ssh-keygen`, sendo eles: **dsa**, **ecdsa**, **ed25519** e **rsa** (opções na aula - no linux ubuntu 24.04 LTS, já aparece com as opções  **dsa** | **ecdsa** | **ecdsa-sk** | **ed25519** | **ed25519-sk** | **rsa**).

Lembrando que em uma conexão remota, os dois pontos precisam entender a criptografia usada das chaves.

#### Tunel SSH e SCP

Usado para serviços que **não** são criptografados (como VNC, telnet, FTP).

Supõe que queira conectar via telnet em um servidor, usando a porta 23 no servidor (porta padrão do telnet), usando um túnel, que no computador cliente (de origem), irá usar a porta 2323, use o comando:
- `ssh -N -f -L 2323:10.0.0.112:23 lpi1@10.0.0.112`: o `-N` indica para **NÃO** executar comando remoto. O `-f` é para rodar o `ssh` em background. O `-L` é para especificar a conexão (o túnel no caso), que pode ser nos seguintes formatos:
  - `-L [bind_address:]port:host:hostport`
  - `-L [bind_address:]port:remote_socket`
  - `-L local_socket:host:hostport`
  - `-L local_socket:remote_socket`
No final faz a conexão, com formato já estudado (`lpi1@10.0.0.112`)

Confirme se o processo está em execução, com `ps axu | grep ssh`:
```
lpi1    4173    0.0 0.0     44920   684  ?  Ss  11:16   0:00 -N -f -L 2323:10.0.0.112:23 lpi1@10.0.0.112
```

Confirme também se o processo ssh está escutando na porta `2323`: `netstat -nalpt | grep 2323`
```
tcp     0   0   127.0.0.1:2323     0.0.0.0:*    LISTEN 4173/ssh
tcp     0   0   ::1:2323            :::*        LISTEN 4173/ssh
```

Confirme também com `nmap`: `nmap localhost` (pode ser que mostre como `3d-nfsd`, pois é o serviço que está mapeado com a porta `2323` em `/etc/services`, mas vai funcionar normalmente, pois a porta estava livre)

A partir do computador cliente, faça conexão via túnel: `telnet localhost 2323`

Para desfaze o túnel ssh use: `killall ssh`

Outra funcionalidade do túnel é fazer conexão no servidor X do servidor.

- `ssh -X lpi1@10.0.0.112 "gnome-calculator"` executa na interface gráfica do PC Servidor, a partir do PC cliente (abre o programa no PC Cliente, mas o processo fica no PC Servidor, tudo via ssh)

`-X` Enables X11 forwarding. This can also be specified on a per-host basis in a configuration file.             X11 forwarding should be enabled with caution.  Users with the ability to bypass file permissions on the remote host (for the user's X authorization database) can access the local X11 display through the forwarded connection.  An attacker may then be able to perform activities such as keystroke monitoring

PC Servidor (está rodando, mas aparece apenas no Cliente)
```
$ ps axu | grep calculator
lpi1   188775 24.2  0.5 587108 88412 ?        Ssl  19:15   0:00 gnome-calculator
```

PC Cliente (programa aparece, mas está rodando no Servidor)
```
$ ps axu | grep calculator
lpi1   21476 0.3  0.1 17252 88960 pts/0        S+  19:15   ssh -X lpi1@192.168.0.10 gnome-calculator
```

**Observação**: pode omitir o comando, e assim que logar, ir digitando os programas que deseja rodar no Servidor.

- `ssh lpi1@10.0.0.1 "ls -l; free"`: executa o comando remotamente e volta no terminal que origiou o comando (fechando a conexão)

- `scp`: usado para enviar e receber arquivos via ssh.
- `scp arquivo.txt lpi1@linux-server:/tmp`: joga o arquivo `arquivo.txt` para a pasta `/tmp` no servidor.
- `scp lpi1@linux-server:~/arquivotexte.tgz .`: pega o arquivo `arquivotexte.tgz` que está no servidor e baixa/salva no diretório corrente (devido ao ponto `.`)

#### GPG - GNU Privacy Guard

Programa usado para assinar documentos, emails, etc para realizar a transmissão segura. Mesmo conceito de chaves assimétricas que o SSH usa para conexão, mas nesse caso, para arquivos.

Verificar se está instalado: `dpkg -l | grep gnupg`

- `gpg --gen-key`: gerar a chave pública e privada. (No exemplo do vídeo da aula, provavelmente houve atualização, considerar usar `--full-generate-key`)
- `gpg --list-keys`: lista as chaves criadas, que ficam em `~/.gnupg`

Agora é realizar o mesmo conceito de enviar a chave pública para a pessoa que vai receber os arquivos, logo precisa exportar essa chave pública

- `gpg --export "rodrigo" > chave-rodrigo.pub`: o nome é o mesmo escolhido na hora da criação (ou veja o nome com o comando de listar as chaves), e redireciona para um arquivo, nesse caso, `chave-rodrigo.pub`
- `gpg --output nova-chave.pub --export "rodrigo"`: apenas outra forma de exportar a chave pública (veja com `cat` que não é possível visualizar)
- `gpg --output nova-chave.pub --armor --export "rodrigo"`: exporta a chave pública em formato ASCII (em texto, mais simples para envio)

Depois precisa fazer o envio da chave, que pode ser copiando o conteúdo dela, enviando os arquivos, ou pode ser exportando para um servidor de chaves.

- `gpg --keyserver keys.gnupg.net --send-keys id_chave`: envia a chave `id_chave` (obtido do comando de listar chaves), e faz o envio para o servidor `key.gnupg.net` (se tiver um server, indique o IP dele)
- `gpg --keyserver keys.gnupg.net --gen-revoke id_chave`: cancela a chave no servidor

Agora a pessoa que vai receber o documento cifrado, precisa importar essa chave para ela, para poder decifrar o documento

- `gpg --import chave.pub`: importa a chave para o sistema, considerando que tenha copiado a chave para o computador.
- `gpg --keyserver keys.gnupg.net --recv-keys id_chave`: importa buscando de um servidor de chaves. (confirme com o comando de listar as chaves se realmente importou)

#### Criptografar, Descriptografar, Assinar

- `gpg --recipient "rodrigo" --output nome-criptografado.gpg --encrypt nome.txt`: criptografa o arquivo nome.txt para envio. `--recipient` indica a identificação da chave pública que será usada. `--output é o nome do arquivo após criptografar` e `--encrypt é o nome do arquivo a ser criptografado`. Pode usar `--armor` para criptografar em modo ASCII

O envio pode ser da forma que preferir, pode ser por `scp`, por exemplo.

- `scp nome-criptografado.gpg lpi1@10.0.0.113:~/`: envia para o diretório home (da máquina que criou o arquivo para a outra que irá lê-lo)
- `scp lpi1@10.0.0.113:~/nome-criptografado.gpg .`: puxa o arquivo criptografado (considerando que esteja no PC que irá receber o arquivo, puxando do PC que criptografou o arquivo)

Agora basta descriptografar o arquivo, usando a chave privada.
- `gpg --output nome-descriptografado.txt --decrypt nome-criptografado.gpg`: vai descriptografar, e vai pedir a a senha da chave privada, caso tenha. Depois já é possível ler o arquivo.

#### Assinar um arquivo

Não criptografa, apenas certifica que foi a pessoa que gerou o arquivo (confirma que foi realmente a pessoa que criou).

Agora o fluxo é o dono do arquivo assinar com a sua respectiva chave privada, e quem recebe a mensagem usa a chave pública do usuário que criou para conferir.

Importante dizer que o arquivo é legível normalmente, apenas a assinatura que é verificada.

- `gpg --sign arquivo.pdf`: assina o arquivo `arquivo.pdf`. Pode usar `--armor` para assinar em texto ascii. Vai criar um arquivo chamado `arquivo.pdf.gpg` ou `arquivo.pdf.asc` se usou a opção `--armor`

Após copiar o arquivo de assinatura para o outro computador, use a chave pública para verificar a assinatura:
- `gpg --verify arquivo.pdf.gpg` ou `.asc`: verifica a assinatura. Atentar se retorna `Good signture`:
```
gpg: Signature made Thu 09 Dec 2024 19:50:16 AM -03
gpg:                using RSA key 8E54602D4010AE770A9C9ADE39EC219E01086829
gpg: Good signature from "rodrigo (rodrigo's key) <email@gmail.com>" [unknown]
gpg: WARNING: This key is not certified with a trusted signature!
gpg:          There is no indication that the signature belongs to the owner.
Primary key fingerprint: 8E84 602D 4310 AE77 0A9C  9ADE 39EC 219E 0108 9829
```

- `gpg --decrypt arquivo.pdf.asc` ou `.gpg`: mostra o conteúdo do arquivo e no rodapé mostra a assinatura.

Caso envie esse arquivo para algum usuário que não tenha a chave pública, e tente verificar a assinatura (`--verify`), não será possível fazer a verificação.

Caso use o comando `--decrypt`, será possível ler o arquivo (lembre-se, não está criptografado, apenas assinado), no entanto no rodapé teremos uma mensagem que não é possível verificar a assinatura (`gpg: Can't check signature: public key not found`)

#### gpg-agent

É um agent parecido com o do SSH (`ps axu | grep gpg-agent`), que fica monitorando para guardar a passphrase temporariamente em memória, para não ter que ficar digitando repetidas vezes. Ele sobe em memória ao usar algum comando `gpg`.

Ao assinar um documento, por exemplo (`gpg --sign syslog`), vai pedir a passphrase (para acessar a chave privada), e caso assine outro documento, não vai mais pedir para digitar.

Se matarmos o `gpg-agent` (`gpgconf --kill gpg-agent`), e tentar assinar novamente um arquivo, vai, novamente, pedir para digitar a passphrase, e, consequentemente, subir o `gpg-agent` novamente.

Esse acesso é feito por meio de um socket, que fica na variável de ambiente `GPG_AGENT_INFO=/run/user/1000/gnupg/S.gpg-agent:0:1`, visto com o comando `env | grep GPG`

